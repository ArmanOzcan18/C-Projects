From do.not.reply@cloud.cs.columbia.edu Fri Sep  9 20:22:02 2022
Date: Fri, 9 Sep 2022 20:22:02 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab1.mbox
Message-ID: <YxvYqToYNzLgqZcc@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="+e02i/qDOQvPgQOz"
Content-Disposition: inline
Status: RO
Content-Length: 1627
Lines: 50


--+e02i/qDOQvPgQOz
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 07f7a9d8ccc46f3ff33596844fec48515d9b1412 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 9 Sep 2022 20:14:28 -0400
Subject: [PATCH] I just tried this for the first time.

---
 README.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..d2eb181 100644
--- a/README.txt
+++ b/README.txt
@@ -1,8 +1,8 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
+  - Arman Ozcan
+  - ao2794
+  - lab 1
   - description for each part
 
 The description should indicate whether your solution for the part is
-- 
2.34.1


--+e02i/qDOQvPgQOz
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab1.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 07f7a9d8ccc46f3ff33596844fec48515d9b1412 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 9 Sep 2022 20:14:28 =
-0400=0ASubject: [PATCH] I just tried this for the first time.=0A=0A---=0A =
README.txt | 6 +++---=0A 1 file changed, 3 insertions(+), 3 deletions(-)=0A=
=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..d2eb181 100644=0A-=
-- a/README.txt=0A+++ b/README.txt=0A@@ -1,8 +1,8 @@=0A This file should co=
ntain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment number=0A=
+  - Arman Ozcan=0A+  - ao2794=0A+  - lab 1=0A   - description for each par=
t=0A =0A The description should indicate whether your solution for the part=
 is=0A-- =0A2.34.1=0A=0A
--+e02i/qDOQvPgQOz--

From do.not.reply@cloud.cs.columbia.edu Tue Sep 20 23:51:23 2022
Date: Tue, 20 Sep 2022 23:51:23 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab1.mbox
Message-ID: <YyqKOcIVOQ8Vlqhh@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="FoXw7rQ058Z9GFB9"
Content-Disposition: inline
Status: RO
Content-Length: 25311
Lines: 586


--FoXw7rQ058Z9GFB9
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 07f7a9d8ccc46f3ff33596844fec48515d9b1412 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 9 Sep 2022 20:14:28 -0400
Subject: [PATCH 1/6] I just tried this for the first time.

---
 README.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..d2eb181 100644
--- a/README.txt
+++ b/README.txt
@@ -1,8 +1,8 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
+  - Arman Ozcan
+  - ao2794
+  - lab 1
   - description for each part
 
 The description should indicate whether your solution for the part is
-- 
2.34.1


From 3baa34c36bdb6d72ceb1f20c39e7f35ca69a7087 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 14 Sep 2022 19:06:00 -0400
Subject: [PATCH 2/6] Wrote print and count methods in words.c and corrected
 the debug mentioned in class.

---
 part2/wordle-main.c    |  2 +-
 part2/words.c          | 56 ++++++++++++++++++++++++++++++++++++++++--
 part2/words/short-list |  6 +++++
 3 files changed, 61 insertions(+), 3 deletions(-)

diff --git a/part2/wordle-main.c b/part2/wordle-main.c
index 392253a..02ce7b5 100644
--- a/part2/wordle-main.c
+++ b/part2/wordle-main.c
@@ -192,7 +192,7 @@ void show_usage(const char* exec_name)
  */
 int pick_word(void)
 {
-    size_t num_words = count_words(words_path);
+    int num_words = count_words(words_path);
 
     if (num_words <= 0)
         return 1;
diff --git a/part2/words.c b/part2/words.c
index 64be6b8..0fa9b72 100644
--- a/part2/words.c
+++ b/part2/words.c
@@ -70,7 +70,34 @@ int read_word(char* dest, unsigned int pos, const char* words_path)
  */
 int count_words(const char* words_path)
 {
-    return 10; // TODO: implement this
+    // Open file containing words.
+    FILE* words_file = fopen(words_path, "rb");
+
+    // Could not open file; report error by returning 1.
+    if (words_file == NULL)
+	return -1;
+	
+    int count = 0; // Keep count of how many valid words we have encountered.
+    char word_buf[32]; // Assume no word is longer than 32 characters.
+
+    // Each word is on its own line. Read each word into word_buf.
+    while (fgets(word_buf, sizeof(word_buf), words_file) > 0) {
+
+        // At this point, word contains a newline. Trim it out:
+        word_buf[strlen(word_buf) - 1] = '\0';
+
+        if (valid_word(word_buf)) {
+            count++;
+	}
+
+    }
+
+    // Done reading from the words file, so let's close it.
+    fclose(words_file);
+
+    // Return the number of words encountered.
+    return count;
+  
 }
 
 /*
@@ -80,5 +107,30 @@ int count_words(const char* words_path)
  */
 int print_words(const char* words_path)
 {
-    return 0; // TODO: implement this
+    // Open file containing words.
+    FILE* words_file = fopen(words_path, "rb");
+
+    // Could not open file; report error by returning 1.
+    if (words_file == NULL)
+        return -1;
+
+    char word_buf[32]; // Assume no word is longer than 32 characters.
+
+    // Each word is on its own line. Read each word into word_buf.
+    while (fgets(word_buf, sizeof(word_buf), words_file) > 0) {
+	
+	// At this point, word contains a newline. Trim it out:
+        word_buf[strlen(word_buf) - 1] = '\0';
+        
+	if (valid_word(word_buf)) {
+	    //Print the word
+	    printf("%s\n",word_buf);
+        }
+    }
+
+    // Done reading from the words file, so let's close it.
+    fclose(words_file);
+
+    // Did not end up finding any words, so report error by returning 1.
+    return 0;
 }
diff --git a/part2/words/short-list b/part2/words/short-list
index b337fcc..16cd178 100644
--- a/part2/words/short-list
+++ b/part2/words/short-list
@@ -18,3 +18,9 @@ funky
 music
 quick
 achoo
+ready
+often
+teddy
+money
+witty
+sunny
-- 
2.34.1


From 11571e4b3bd0e3862e8e698ade65e1799763f3e6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 14 Sep 2022 23:49:04 -0400
Subject: [PATCH 3/6] Wrote give_hint() method.

---
 part2/game.c | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/part2/game.c b/part2/game.c
index 86641e9..84f7f02 100644
--- a/part2/game.c
+++ b/part2/game.c
@@ -54,7 +54,25 @@ int read_guess(char* guess, int size, const char* prompt)
  */
 void give_hint(const char* answer, const char* guess)
 {
-    // TODO: implement this
+    int answer_len = strlen(answer);
+    char output[answer_len];
+
+    for(int i=0; i<answer_len; i++){
+    	for(int j=0; j<answer_len; j++){
+	    if(guess[i]==answer[j]){
+	    	if(i==j){
+		    output[i]='+';
+		    goto cont;
+		}
+		else
+		    output[i]='-';
+	    }
+	}
+	if(output[i]!='+' && output[i]!='-')
+		output[i]='_';
+	cont:
+    }
+    printf("%s\n", output);
 }
 
 /*
-- 
2.34.1


From 1ea564d3399640c8893b24b60bc7226f023560b1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 18 Sep 2022 23:44:21 -0400
Subject: [PATCH 4/6] erased the extra words from the short word list and did
 the first honesty question

---
 part1/honesty-quiz.txt | 5 ++++-
 part2/words/short-list | 6 ------
 2 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/part1/honesty-quiz.txt b/part1/honesty-quiz.txt
index ec7bb0d..c391e03 100644
--- a/part1/honesty-quiz.txt
+++ b/part1/honesty-quiz.txt
@@ -1,5 +1,8 @@
 [1]
-
+No. While I certainly don't think hiring a tutor is a fair to other
+students who cannot, I don't think this one constitutes cheating as long as
+the tutor didn't explicitly show the areas in the code where there is a
+problem.
 [2]
 
 [3]
diff --git a/part2/words/short-list b/part2/words/short-list
index 16cd178..b337fcc 100644
--- a/part2/words/short-list
+++ b/part2/words/short-list
@@ -18,9 +18,3 @@ funky
 music
 quick
 achoo
-ready
-often
-teddy
-money
-witty
-sunny
-- 
2.34.1


From 5bacb573d299e002100194885cfbe92bfbf9758a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Tue, 20 Sep 2022 00:56:23 -0400
Subject: [PATCH 5/6] new commit

---
 part1/honesty-quiz.txt | 24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

diff --git a/part1/honesty-quiz.txt b/part1/honesty-quiz.txt
index c391e03..46dac0f 100644
--- a/part1/honesty-quiz.txt
+++ b/part1/honesty-quiz.txt
@@ -4,17 +4,29 @@ students who cannot, I don't think this one constitutes cheating as long as
 the tutor didn't explicitly show the areas in the code where there is a
 problem.
 [2]
-
+Yes, because even though that person didn't copy the code, looking at that
+correct piece of code by itself would directly help them write the code
+themselves, so it would be a violation.
 [3]
-
+Yes, the possession of solutions would mean that the intention of the
+student is to cheat if needed.
 [4a]
-
+No, anything from the lecture should be able to discussed between students.
 [4b]
-
+Yes, describing the solution regardless of how small it is is wrong and
+would constitute cheating.
 [4c]
-
+No, although I believe that it is a weird question to ask, as long as the
+other person only talk about the objective of the homework assignment but
+not how to reach that objective, that should be fine. Because knowing what
+you are supposed to learn by doing the assignment and actually doing the
+assignment are two different things.
 [5]
 
 [6]
-
+No, as long as only the error is searched on Google and correction is done
+by the student themselves, I think it is fine. Because in most situations
+knowing what an error means wouldn't tell you how to solve that
+error.
 [7]
+Yes, the moment you intentionally look at a solution, that's cheating.
-- 
2.34.1


From 4af8c8e4752637af9d0bf294424428898a12e7d0 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Tue, 20 Sep 2022 23:48:00 -0400
Subject: [PATCH 6/6] This is my final commit ready for submission.

---
 README.txt             |  2 +-
 part1/honesty-quiz.txt | 10 +++++++---
 part2/game.c           |  4 ++--
 part2/words.c          | 10 +++++-----
 4 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/README.txt b/README.txt
index d2eb181..e183b40 100644
--- a/README.txt
+++ b/README.txt
@@ -3,7 +3,7 @@ This file should contain:
   - Arman Ozcan
   - ao2794
   - lab 1
-  - description for each part
+  - My solution should be working. I passed all the test.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
diff --git a/part1/honesty-quiz.txt b/part1/honesty-quiz.txt
index 46dac0f..cdb9b91 100644
--- a/part1/honesty-quiz.txt
+++ b/part1/honesty-quiz.txt
@@ -13,8 +13,10 @@ student is to cheat if needed.
 [4a]
 No, anything from the lecture should be able to discussed between students.
 [4b]
-Yes, describing the solution regardless of how small it is is wrong and
-would constitute cheating.
+No, this one is tricky. But as long as you only explain your friend a
+small "conceptual" element without sitting at a computer and writing the
+code itself, it should be fine. Working out on paper through tables and
+diagrams would be a great way to help and also wouldn't be considered cheating.
 [4c]
 No, although I believe that it is a weird question to ask, as long as the
 other person only talk about the objective of the homework assignment but
@@ -22,7 +24,9 @@ not how to reach that objective, that should be fine. Because knowing what
 you are supposed to learn by doing the assignment and actually doing the
 assignment are two different things.
 [5]
-
+Yes, because as outlined in the academic honesty policies, even if you
+didn't learn anything from the online solution, looking at it constitutes
+cheating.
 [6]
 No, as long as only the error is searched on Google and correction is done
 by the student themselves, I think it is fine. Because in most situations
diff --git a/part2/game.c b/part2/game.c
index 84f7f02..1decb9d 100644
--- a/part2/game.c
+++ b/part2/game.c
@@ -68,8 +68,8 @@ void give_hint(const char* answer, const char* guess)
 		    output[i]='-';
 	    }
 	}
-	if(output[i]!='+' && output[i]!='-')
-		output[i]='_';
+	if(output[i]!='-')
+	    output[i]='_';
 	cont:
     }
     printf("%s\n", output);
diff --git a/part2/words.c b/part2/words.c
index 0fa9b72..95989e7 100644
--- a/part2/words.c
+++ b/part2/words.c
@@ -28,7 +28,7 @@ int read_word(char* dest, unsigned int pos, const char* words_path)
     // Open file containing words.
     FILE* words_file = fopen(words_path, "rb");
 
-    // Could not open file; report error by returning 1.
+    // Could not open file; report error by returning -1.
     if (words_file == NULL)
         return -1;
 
@@ -59,7 +59,7 @@ int read_word(char* dest, unsigned int pos, const char* words_path)
     // Done reading from the words file, so let's close it.
     fclose(words_file);
 
-    // Did not end up finding any words, so report error by returning 1.
+    // Did not end up finding any words, so report error by returning -1.
     return -1;
 }
 
@@ -73,7 +73,7 @@ int count_words(const char* words_path)
     // Open file containing words.
     FILE* words_file = fopen(words_path, "rb");
 
-    // Could not open file; report error by returning 1.
+    // Could not open file; report error by returning -1.
     if (words_file == NULL)
 	return -1;
 	
@@ -110,7 +110,7 @@ int print_words(const char* words_path)
     // Open file containing words.
     FILE* words_file = fopen(words_path, "rb");
 
-    // Could not open file; report error by returning 1.
+    // Could not open file; report error by returning -1.
     if (words_file == NULL)
         return -1;
 
@@ -131,6 +131,6 @@ int print_words(const char* words_path)
     // Done reading from the words file, so let's close it.
     fclose(words_file);
 
-    // Did not end up finding any words, so report error by returning 1.
+    // Successfully printed any valid words in the file, so return 0
     return 0;
 }
-- 
2.34.1


--FoXw7rQ058Z9GFB9
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab1.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 07f7a9d8ccc46f3ff33596844fec48515d9b1412 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 9 Sep 2022 20:14:28 =
-0400=0ASubject: [PATCH 1/6] I just tried this for the first time.=0A=0A---=
=0A README.txt | 6 +++---=0A 1 file changed, 3 insertions(+), 3 deletions(-=
)=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..d2eb181 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -1,8 +1,8 @@=0A This file shoul=
d contain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment numbe=
r=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab 1=0A   - description for each=
 part=0A =0A The description should indicate whether your solution for the =
part is=0A-- =0A2.34.1=0A=0A=0AFrom 3baa34c36bdb6d72ceb1f20c39e7f35ca69a708=
7 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate=
: Wed, 14 Sep 2022 19:06:00 -0400=0ASubject: [PATCH 2/6] Wrote print and co=
unt methods in words.c and corrected=0A the debug mentioned in class.=0A=0A=
---=0A part2/wordle-main.c    |  2 +-=0A part2/words.c          | 56 ++++++=
++++++++++++++++++++++++++++++++++--=0A part2/words/short-list |  6 +++++=
=0A 3 files changed, 61 insertions(+), 3 deletions(-)=0A=0Adiff --git a/par=
t2/wordle-main.c b/part2/wordle-main.c=0Aindex 392253a..02ce7b5 100644=0A--=
- a/part2/wordle-main.c=0A+++ b/part2/wordle-main.c=0A@@ -192,7 +192,7 @@ v=
oid show_usage(const char* exec_name)=0A  */=0A int pick_word(void)=0A {=0A=
-    size_t num_words =3D count_words(words_path);=0A+    int num_words =3D=
 count_words(words_path);=0A =0A     if (num_words <=3D 0)=0A         retur=
n 1;=0Adiff --git a/part2/words.c b/part2/words.c=0Aindex 64be6b8..0fa9b72 =
100644=0A--- a/part2/words.c=0A+++ b/part2/words.c=0A@@ -70,7 +70,34 @@ int=
 read_word(char* dest, unsigned int pos, const char* words_path)=0A  */=0A =
int count_words(const char* words_path)=0A {=0A-    return 10; // TODO: imp=
lement this=0A+    // Open file containing words.=0A+    FILE* words_file =
=3D fopen(words_path, "rb");=0A+=0A+    // Could not open file; report erro=
r by returning 1.=0A+    if (words_file =3D=3D NULL)=0A+	return -1;=0A+	=0A=
+    int count =3D 0; // Keep count of how many valid words we have encount=
ered.=0A+    char word_buf[32]; // Assume no word is longer than 32 charact=
ers.=0A+=0A+    // Each word is on its own line. Read each word into word_b=
uf.=0A+    while (fgets(word_buf, sizeof(word_buf), words_file) > 0) {=0A+=
=0A+        // At this point, word contains a newline. Trim it out:=0A+    =
    word_buf[strlen(word_buf) - 1] =3D '\0';=0A+=0A+        if (valid_word(=
word_buf)) {=0A+            count++;=0A+	}=0A+=0A+    }=0A+=0A+    // Done =
reading from the words file, so let's close it.=0A+    fclose(words_file);=
=0A+=0A+    // Return the number of words encountered.=0A+    return count;=
=0A+  =0A }=0A =0A /*=0A@@ -80,5 +107,30 @@ int count_words(const char* wor=
ds_path)=0A  */=0A int print_words(const char* words_path)=0A {=0A-    retu=
rn 0; // TODO: implement this=0A+    // Open file containing words.=0A+    =
FILE* words_file =3D fopen(words_path, "rb");=0A+=0A+    // Could not open =
file; report error by returning 1.=0A+    if (words_file =3D=3D NULL)=0A+  =
      return -1;=0A+=0A+    char word_buf[32]; // Assume no word is longer =
than 32 characters.=0A+=0A+    // Each word is on its own line. Read each w=
ord into word_buf.=0A+    while (fgets(word_buf, sizeof(word_buf), words_fi=
le) > 0) {=0A+	=0A+	// At this point, word contains a newline. Trim it out:=
=0A+        word_buf[strlen(word_buf) - 1] =3D '\0';=0A+        =0A+	if (va=
lid_word(word_buf)) {=0A+	    //Print the word=0A+	    printf("%s\n",word_b=
uf);=0A+        }=0A+    }=0A+=0A+    // Done reading from the words file, =
so let's close it.=0A+    fclose(words_file);=0A+=0A+    // Did not end up =
finding any words, so report error by returning 1.=0A+    return 0;=0A }=0A=
diff --git a/part2/words/short-list b/part2/words/short-list=0Aindex b337fc=
c..16cd178 100644=0A--- a/part2/words/short-list=0A+++ b/part2/words/short-=
list=0A@@ -18,3 +18,9 @@ funky=0A music=0A quick=0A achoo=0A+ready=0A+often=
=0A+teddy=0A+money=0A+witty=0A+sunny=0A-- =0A2.34.1=0A=0A=0AFrom 11571e4b3b=
d0e3862e8e698ade65e1799763f3e6 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan=
 <ao2794@columbia.edu>=0ADate: Wed, 14 Sep 2022 23:49:04 -0400=0ASubject: [=
PATCH 3/6] Wrote give_hint() method.=0A=0A---=0A part2/game.c | 20 ++++++++=
+++++++++++-=0A 1 file changed, 19 insertions(+), 1 deletion(-)=0A=0Adiff -=
-git a/part2/game.c b/part2/game.c=0Aindex 86641e9..84f7f02 100644=0A--- a/=
part2/game.c=0A+++ b/part2/game.c=0A@@ -54,7 +54,25 @@ int read_guess(char*=
 guess, int size, const char* prompt)=0A  */=0A void give_hint(const char* =
answer, const char* guess)=0A {=0A-    // TODO: implement this=0A+    int a=
nswer_len =3D strlen(answer);=0A+    char output[answer_len];=0A+=0A+    fo=
r(int i=3D0; i<answer_len; i++){=0A+    	for(int j=3D0; j<answer_len; j++){=
=0A+	    if(guess[i]=3D=3Danswer[j]){=0A+	    	if(i=3D=3Dj){=0A+		    outpu=
t[i]=3D'+';=0A+		    goto cont;=0A+		}=0A+		else=0A+		    output[i]=3D'-';=
=0A+	    }=0A+	}=0A+	if(output[i]!=3D'+' && output[i]!=3D'-')=0A+		output[i=
]=3D'_';=0A+	cont:=0A+    }=0A+    printf("%s\n", output);=0A }=0A =0A /*=
=0A-- =0A2.34.1=0A=0A=0AFrom 1ea564d3399640c8893b24b60bc7226f023560b1 Mon S=
ep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, =
18 Sep 2022 23:44:21 -0400=0ASubject: [PATCH 4/6] erased the extra words fr=
om the short word list and did=0A the first honesty question=0A=0A---=0A pa=
rt1/honesty-quiz.txt | 5 ++++-=0A part2/words/short-list | 6 ------=0A 2 fi=
les changed, 4 insertions(+), 7 deletions(-)=0A=0Adiff --git a/part1/honest=
y-quiz.txt b/part1/honesty-quiz.txt=0Aindex ec7bb0d..c391e03 100644=0A--- a=
/part1/honesty-quiz.txt=0A+++ b/part1/honesty-quiz.txt=0A@@ -1,5 +1,8 @@=0A=
 [1]=0A-=0A+No. While I certainly don't think hiring a tutor is a fair to o=
ther=0A+students who cannot, I don't think this one constitutes cheating as=
 long as=0A+the tutor didn't explicitly show the areas in the code where th=
ere is a=0A+problem.=0A [2]=0A =0A [3]=0Adiff --git a/part2/words/short-lis=
t b/part2/words/short-list=0Aindex 16cd178..b337fcc 100644=0A--- a/part2/wo=
rds/short-list=0A+++ b/part2/words/short-list=0A@@ -18,9 +18,3 @@ funky=0A =
music=0A quick=0A achoo=0A-ready=0A-often=0A-teddy=0A-money=0A-witty=0A-sun=
ny=0A-- =0A2.34.1=0A=0A=0AFrom 5bacb573d299e002100194885cfbe92bfbf9758a Mon=
 Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Tue=
, 20 Sep 2022 00:56:23 -0400=0ASubject: [PATCH 5/6] new commit=0A=0A---=0A =
part1/honesty-quiz.txt | 24 ++++++++++++++++++------=0A 1 file changed, 18 =
insertions(+), 6 deletions(-)=0A=0Adiff --git a/part1/honesty-quiz.txt b/pa=
rt1/honesty-quiz.txt=0Aindex c391e03..46dac0f 100644=0A--- a/part1/honesty-=
quiz.txt=0A+++ b/part1/honesty-quiz.txt=0A@@ -4,17 +4,29 @@ students who ca=
nnot, I don't think this one constitutes cheating as long as=0A the tutor d=
idn't explicitly show the areas in the code where there is a=0A problem.=0A=
 [2]=0A-=0A+Yes, because even though that person didn't copy the code, look=
ing at that=0A+correct piece of code by itself would directly help them wri=
te the code=0A+themselves, so it would be a violation.=0A [3]=0A-=0A+Yes, t=
he possession of solutions would mean that the intention of the=0A+student =
is to cheat if needed.=0A [4a]=0A-=0A+No, anything from the lecture should =
be able to discussed between students.=0A [4b]=0A-=0A+Yes, describing the s=
olution regardless of how small it is is wrong and=0A+would constitute chea=
ting.=0A [4c]=0A-=0A+No, although I believe that it is a weird question to =
ask, as long as the=0A+other person only talk about the objective of the ho=
mework assignment but=0A+not how to reach that objective, that should be fi=
ne. Because knowing what=0A+you are supposed to learn by doing the assignme=
nt and actually doing the=0A+assignment are two different things.=0A [5]=0A=
 =0A [6]=0A-=0A+No, as long as only the error is searched on Google and cor=
rection is done=0A+by the student themselves, I think it is fine. Because i=
n most situations=0A+knowing what an error means wouldn't tell you how to s=
olve that=0A+error.=0A [7]=0A+Yes, the moment you intentionally look at a s=
olution, that's cheating.=0A-- =0A2.34.1=0A=0A=0AFrom 4af8c8e4752637af9d0bf=
294424428898a12e7d0 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@co=
lumbia.edu>=0ADate: Tue, 20 Sep 2022 23:48:00 -0400=0ASubject: [PATCH 6/6] =
This is my final commit ready for submission.=0A=0A---=0A README.txt       =
      |  2 +-=0A part1/honesty-quiz.txt | 10 +++++++---=0A part2/game.c    =
       |  4 ++--=0A part2/words.c          | 10 +++++-----=0A 4 files chang=
ed, 15 insertions(+), 11 deletions(-)=0A=0Adiff --git a/README.txt b/README=
=2Etxt=0Aindex d2eb181..e183b40 100644=0A--- a/README.txt=0A+++ b/README.tx=
t=0A@@ -3,7 +3,7 @@ This file should contain:=0A   - Arman Ozcan=0A   - ao2=
794=0A   - lab 1=0A-  - description for each part=0A+  - My solution should=
 be working. I passed all the test.=0A =0A The description should indicate =
whether your solution for the part is=0A working or not.  You may also want=
 to include anything else you would=0Adiff --git a/part1/honesty-quiz.txt b=
/part1/honesty-quiz.txt=0Aindex 46dac0f..cdb9b91 100644=0A--- a/part1/hones=
ty-quiz.txt=0A+++ b/part1/honesty-quiz.txt=0A@@ -13,8 +13,10 @@ student is =
to cheat if needed.=0A [4a]=0A No, anything from the lecture should be able=
 to discussed between students.=0A [4b]=0A-Yes, describing the solution reg=
ardless of how small it is is wrong and=0A-would constitute cheating.=0A+No=
, this one is tricky. But as long as you only explain your friend a=0A+smal=
l "conceptual" element without sitting at a computer and writing the=0A+cod=
e itself, it should be fine. Working out on paper through tables and=0A+dia=
grams would be a great way to help and also wouldn't be considered cheating=
=2E=0A [4c]=0A No, although I believe that it is a weird question to ask, a=
s long as the=0A other person only talk about the objective of the homework=
 assignment but=0A@@ -22,7 +24,9 @@ not how to reach that objective, that s=
hould be fine. Because knowing what=0A you are supposed to learn by doing t=
he assignment and actually doing the=0A assignment are two different things=
=2E=0A [5]=0A-=0A+Yes, because as outlined in the academic honesty policies=
, even if you=0A+didn't learn anything from the online solution, looking at=
 it constitutes=0A+cheating.=0A [6]=0A No, as long as only the error is sea=
rched on Google and correction is done=0A by the student themselves, I thin=
k it is fine. Because in most situations=0Adiff --git a/part2/game.c b/part=
2/game.c=0Aindex 84f7f02..1decb9d 100644=0A--- a/part2/game.c=0A+++ b/part2=
/game.c=0A@@ -68,8 +68,8 @@ void give_hint(const char* answer, const char* =
guess)=0A 		    output[i]=3D'-';=0A 	    }=0A 	}=0A-	if(output[i]!=3D'+' &&=
 output[i]!=3D'-')=0A-		output[i]=3D'_';=0A+	if(output[i]!=3D'-')=0A+	    o=
utput[i]=3D'_';=0A 	cont:=0A     }=0A     printf("%s\n", output);=0Adiff --=
git a/part2/words.c b/part2/words.c=0Aindex 0fa9b72..95989e7 100644=0A--- a=
/part2/words.c=0A+++ b/part2/words.c=0A@@ -28,7 +28,7 @@ int read_word(char=
* dest, unsigned int pos, const char* words_path)=0A     // Open file conta=
ining words.=0A     FILE* words_file =3D fopen(words_path, "rb");=0A =0A-  =
  // Could not open file; report error by returning 1.=0A+    // Could not =
open file; report error by returning -1.=0A     if (words_file =3D=3D NULL)=
=0A         return -1;=0A =0A@@ -59,7 +59,7 @@ int read_word(char* dest, un=
signed int pos, const char* words_path)=0A     // Done reading from the wor=
ds file, so let's close it.=0A     fclose(words_file);=0A =0A-    // Did no=
t end up finding any words, so report error by returning 1.=0A+    // Did n=
ot end up finding any words, so report error by returning -1.=0A     return=
 -1;=0A }=0A =0A@@ -73,7 +73,7 @@ int count_words(const char* words_path)=
=0A     // Open file containing words.=0A     FILE* words_file =3D fopen(wo=
rds_path, "rb");=0A =0A-    // Could not open file; report error by returni=
ng 1.=0A+    // Could not open file; report error by returning -1.=0A     i=
f (words_file =3D=3D NULL)=0A 	return -1;=0A 	=0A@@ -110,7 +110,7 @@ int pr=
int_words(const char* words_path)=0A     // Open file containing words.=0A =
    FILE* words_file =3D fopen(words_path, "rb");=0A =0A-    // Could not o=
pen file; report error by returning 1.=0A+    // Could not open file; repor=
t error by returning -1.=0A     if (words_file =3D=3D NULL)=0A         retu=
rn -1;=0A =0A@@ -131,6 +131,6 @@ int print_words(const char* words_path)=0A=
     // Done reading from the words file, so let's close it.=0A     fclose(=
words_file);=0A =0A-    // Did not end up finding any words, so report erro=
r by returning 1.=0A+    // Successfully printed any valid words in the fil=
e, so return 0=0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A
--FoXw7rQ058Z9GFB9--

From do.not.reply@cloud.cs.columbia.edu Sun Oct  2 14:38:40 2022
Date: Sun, 2 Oct 2022 14:38:40 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab2.mbox
Message-ID: <Yznar96n3pzhBs4M@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="wxb4+gB2GdWhVbKv"
Content-Disposition: inline
Status: RO
Content-Length: 13539
Lines: 378


--wxb4+gB2GdWhVbKv
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 17:34:41 -0400
Subject: [PATCH 1/5] First commit, I wrote README.txt

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..1a636b2 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 2
+  - My program should work as it should!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 18:12:48 -0400
Subject: [PATCH 2/5] I wrote Makefile for part1.

---
 part1/Makefile  | 13 +++++++++++++
 part1/convert.c |  3 ++-
 2 files changed, 15 insertions(+), 1 deletion(-)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..dcdd935
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,13 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+
+convert: convert.o
+	$(CC) $(LDFLAGS) -o convert convert.o
+
+convert.o: convert.c
+	$(CC) $(CFLAGS) -c -o convert.o convert.c
+
+.PHONY: clean
+clean:
+	rm -rf convert *.o
diff --git a/part1/convert.c b/part1/convert.c
index ce35b0e..0b3fa1c 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -13,6 +13,7 @@ int main(int argc, char **argv)
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-
+    printf("binary:       %x\n", x);
+    
     return 0;
 }
-- 
2.34.1


From 8866c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 20:14:53 -0400
Subject: [PATCH 3/5] I wrote the binary printer for part1.

---
 part1/convert.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/part1/convert.c b/part1/convert.c
index 0b3fa1c..8e1e5a9 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -10,10 +10,23 @@ int main(int argc, char **argv)
 
     int x = atoi(argv[1]); // Parse the first argument as an int
 
+    char binary[] = "0000 0000 0000 0000 0000 0000 0000 0000";
+    
+    int compare  = 1;
+    int count = 0;
+    
+    while(count != 32){
+        if(x & compare){
+            binary[38  -count -count/4]='1';
+        }
+        compare = compare << 1;
+        count++;
+    }  
+
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-    printf("binary:       %x\n", x);
-    
+    printf("binary:       %s\n", binary);
+   
     return 0;
 }
-- 
2.34.1


From c10b3a64c6f553348d06e40f7264add9d8df973e Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 1 Oct 2022 17:47:45 -0400
Subject: [PATCH 4/5] I created twecho.c and twecho.h.

---
 part2/twecho.c | 8 ++++++++
 part2/twecho.h | 3 +++
 2 files changed, 11 insertions(+)
 create mode 100644 part2/twecho.c
 create mode 100644 part2/twecho.h

diff --git a/part2/twecho.c b/part2/twecho.c
new file mode 100644
index 0000000..0885bd6
--- /dev/null
+++ b/part2/twecho.c
@@ -0,0 +1,8 @@
+#include "twecho.h"
+
+char **duplicateArgs(int argc, char **argv){
+}
+
+void freeDuplicatedArgs(char **copy){
+}
+
diff --git a/part2/twecho.h b/part2/twecho.h
new file mode 100644
index 0000000..13530ba
--- /dev/null
+++ b/part2/twecho.h
@@ -0,0 +1,3 @@
+char **duplicateArgs(int argc, char **argv);
+
+void freeDuplicatedArgs(char **copy);
-- 
2.34.1


From 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 03:48:01 -0400
Subject: [PATCH 5/5] I wrote twecho.c!

---
 part1/Makefile | 12 ++++++----
 part2/twecho.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index dcdd935..43a589d 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -1,13 +1,17 @@
 CC = gcc
 CFLAGS = -g -Wall -Wpedantic -std=c17
 LDFLAGS =
-
+LDLIBS =
+	
+# convert depends on convert.o
 convert: convert.o
-	$(CC) $(LDFLAGS) -o convert convert.o
 
+# convert.o depends on convert.c
 convert.o: convert.c
-	$(CC) $(CFLAGS) -c -o convert.o convert.c
 
 .PHONY: clean
 clean:
-	rm -rf convert *.o
+	rm -f *.o a.out core convert
+
+.PHONY: all
+all: clean convert
diff --git a/part2/twecho.c b/part2/twecho.c
index 0885bd6..a73b58b 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -1,8 +1,70 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
 #include "twecho.h"
 
+//don't forget to add malloc null check!
+
 char **duplicateArgs(int argc, char **argv){
+
+    char **copy = malloc((argc+1) * sizeof(char *));
+    if (copy == NULL) {     
+        perror("malloc returned NULL");
+        exit(1);
+    }
+    char **p = copy;
+        
+    
+    while(*argv){
+        *p = malloc(((strlen(*argv)+1) * sizeof(char)));
+        if (p == NULL) {
+            perror("malloc returned NULL");
+            exit(1);
+        }
+        size_t i;
+        for(i = 0; i < strlen(*argv); i++){
+            *(*p+i)=toupper(*(*argv+i));
+        }
+        *(*p+strlen(*argv)) = '\0';
+
+        argv++;
+        p++;
+    }   
+    *p = NULL;
+    
+    return copy;
 }
 
+/*
+    char **copy = duplicateArgs(argc, argv);
+    char **p = copy;
+
+    argv++; //shifts by 8 bytes
+    p++; //shifts by 8 btyes, now it points at the pointer which point at the address of 
+    while (*argv) {
+        printf("%s %s\n", *argv++, *p++);
+    }
+
+    freeDuplicatedArgs(copy);
+*/
+
+
 void freeDuplicatedArgs(char **copy){
+    int i=1;
+    char **original = copy;
+
+    while(*copy){
+        char *temp = *copy;
+        free(temp);
+        printf("%d. String is freed\n", i);
+        copy++;
+        i++;
+    }
+    
+    free(original);
+    printf("The array is freed\n");
+    
+    return;
 }
 
-- 
2.34.1


--wxb4+gB2GdWhVbKv
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 17:34:41=
 -0400=0ASubject: [PATCH 1/5] First commit, I wrote README.txt=0A=0A---=0A =
README.txt | 8 ++++----=0A 1 file changed, 4 insertions(+), 4 deletions(-)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..1a636b2 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -1,9 +1,9 @@=0A This file shoul=
d contain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment numbe=
r=0A-  - description for each part=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - =
lab 2=0A+  - My program should work as it should!=0A =0A The description sh=
ould indicate whether your solution for the part is=0A working or not.  You=
 may also want to include anything else you would=0A-- =0A2.34.1=0A=0A=0AFr=
om a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001=0AFrom=
: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 18:12:48 -0400=
=0ASubject: [PATCH 2/5] I wrote Makefile for part1.=0A=0A---=0A part1/Makef=
ile  | 13 +++++++++++++=0A part1/convert.c |  3 ++-=0A 2 files changed, 15 =
insertions(+), 1 deletion(-)=0A create mode 100644 part1/Makefile=0A=0Adiff=
 --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 000=
0000..dcdd935=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,13 @@=0A+=
CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A+LDFLAGS =3D=0A+=
=0A+convert: convert.o=0A+	$(CC) $(LDFLAGS) -o convert convert.o=0A+=0A+con=
vert.o: convert.c=0A+	$(CC) $(CFLAGS) -c -o convert.o convert.c=0A+=0A+.PHO=
NY: clean=0A+clean:=0A+	rm -rf convert *.o=0Adiff --git a/part1/convert.c b=
/part1/convert.c=0Aindex ce35b0e..0b3fa1c 100644=0A--- a/part1/convert.c=0A=
+++ b/part1/convert.c=0A@@ -13,6 +13,7 @@ int main(int argc, char **argv)=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-=0A+    printf("binary:   =
    %x\n", x);=0A+    =0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom 88=
66c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001=0AFrom: Arm=
an Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 20:14:53 -0400=0ASu=
bject: [PATCH 3/5] I wrote the binary printer for part1.=0A=0A---=0A part1/=
convert.c | 17 +++++++++++++++--=0A 1 file changed, 15 insertions(+), 2 del=
etions(-)=0A=0Adiff --git a/part1/convert.c b/part1/convert.c=0Aindex 0b3fa=
1c..8e1e5a9 100644=0A--- a/part1/convert.c=0A+++ b/part1/convert.c=0A@@ -10=
,10 +10,23 @@ int main(int argc, char **argv)=0A =0A     int x =3D atoi(arg=
v[1]); // Parse the first argument as an int=0A =0A+    char binary[] =3D "=
0000 0000 0000 0000 0000 0000 0000 0000";=0A+    =0A+    int compare  =3D 1=
;=0A+    int count =3D 0;=0A+    =0A+    while(count !=3D 32){=0A+        i=
f(x & compare){=0A+            binary[38  -count -count/4]=3D'1';=0A+      =
  }=0A+        compare =3D compare << 1;=0A+        count++;=0A+    }  =0A+=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-    printf("binary:       =
%x\n", x);=0A-    =0A+    printf("binary:       %s\n", binary);=0A+   =0A  =
   return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom c10b3a64c6f553348d06e40f7264a=
dd9d8df973e Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.e=
du>=0ADate: Sat, 1 Oct 2022 17:47:45 -0400=0ASubject: [PATCH 4/5] I created=
 twecho.c and twecho.h.=0A=0A---=0A part2/twecho.c | 8 ++++++++=0A part2/tw=
echo.h | 3 +++=0A 2 files changed, 11 insertions(+)=0A create mode 100644 p=
art2/twecho.c=0A create mode 100644 part2/twecho.h=0A=0Adiff --git a/part2/=
twecho.c b/part2/twecho.c=0Anew file mode 100644=0Aindex 0000000..0885bd6=
=0A--- /dev/null=0A+++ b/part2/twecho.c=0A@@ -0,0 +1,8 @@=0A+#include "twec=
ho.h"=0A+=0A+char **duplicateArgs(int argc, char **argv){=0A+}=0A+=0A+void =
freeDuplicatedArgs(char **copy){=0A+}=0A+=0Adiff --git a/part2/twecho.h b/p=
art2/twecho.h=0Anew file mode 100644=0Aindex 0000000..13530ba=0A--- /dev/nu=
ll=0A+++ b/part2/twecho.h=0A@@ -0,0 +1,3 @@=0A+char **duplicateArgs(int arg=
c, char **argv);=0A+=0A+void freeDuplicatedArgs(char **copy);=0A-- =0A2.34.=
1=0A=0A=0AFrom 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00=
 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 2 Oct 2022 03:=
48:01 -0400=0ASubject: [PATCH 5/5] I wrote twecho.c!=0A=0A---=0A part1/Make=
file | 12 ++++++----=0A part2/twecho.c | 62 +++++++++++++++++++++++++++++++=
+++++++++++++++++++=0A 2 files changed, 70 insertions(+), 4 deletions(-)=0A=
=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex dcdd935..43a589d 10=
0644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -1,13 +1,17 @@=0A C=
C =3D gcc=0A CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A LDFLAGS =3D=0A-=
=0A+LDLIBS =3D=0A+	=0A+# convert depends on convert.o=0A convert: convert.o=
=0A-	$(CC) $(LDFLAGS) -o convert convert.o=0A =0A+# convert.o depends on co=
nvert.c=0A convert.o: convert.c=0A-	$(CC) $(CFLAGS) -c -o convert.o convert=
=2Ec=0A =0A .PHONY: clean=0A clean:=0A-	rm -rf convert *.o=0A+	rm -f *.o a.=
out core convert=0A+=0A+.PHONY: all=0A+all: clean convert=0Adiff --git a/pa=
rt2/twecho.c b/part2/twecho.c=0Aindex 0885bd6..a73b58b 100644=0A--- a/part2=
/twecho.c=0A+++ b/part2/twecho.c=0A@@ -1,8 +1,70 @@=0A+#include <stdio.h>=
=0A+#include <stdlib.h>=0A+#include <ctype.h>=0A+#include <string.h>=0A #in=
clude "twecho.h"=0A =0A+//don't forget to add malloc null check!=0A+=0A cha=
r **duplicateArgs(int argc, char **argv){=0A+=0A+    char **copy =3D malloc=
((argc+1) * sizeof(char *));=0A+    if (copy =3D=3D NULL) {     =0A+       =
 perror("malloc returned NULL");=0A+        exit(1);=0A+    }=0A+    char *=
*p =3D copy;=0A+        =0A+    =0A+    while(*argv){=0A+        *p =3D mal=
loc(((strlen(*argv)+1) * sizeof(char)));=0A+        if (p =3D=3D NULL) {=0A=
+            perror("malloc returned NULL");=0A+            exit(1);=0A+   =
     }=0A+        size_t i;=0A+        for(i =3D 0; i < strlen(*argv); i++)=
{=0A+            *(*p+i)=3Dtoupper(*(*argv+i));=0A+        }=0A+        *(*=
p+strlen(*argv)) =3D '\0';=0A+=0A+        argv++;=0A+        p++;=0A+    } =
  =0A+    *p =3D NULL;=0A+    =0A+    return copy;=0A }=0A =0A+/*=0A+    ch=
ar **copy =3D duplicateArgs(argc, argv);=0A+    char **p =3D copy;=0A+=0A+ =
   argv++; //shifts by 8 bytes=0A+    p++; //shifts by 8 btyes, now it poin=
ts at the pointer which point at the address of =0A+    while (*argv) {=0A+=
        printf("%s %s\n", *argv++, *p++);=0A+    }=0A+=0A+    freeDuplicate=
dArgs(copy);=0A+*/=0A+=0A+=0A void freeDuplicatedArgs(char **copy){=0A+    =
int i=3D1;=0A+    char **original =3D copy;=0A+=0A+    while(*copy){=0A+   =
     char *temp =3D *copy;=0A+        free(temp);=0A+        printf("%d. St=
ring is freed\n", i);=0A+        copy++;=0A+        i++;=0A+    }=0A+    =
=0A+    free(original);=0A+    printf("The array is freed\n");=0A+    =0A+ =
   return;=0A }=0A =0A-- =0A2.34.1=0A=0A
--wxb4+gB2GdWhVbKv--

From do.not.reply@cloud.cs.columbia.edu Sun Oct  2 14:40:01 2022
Date: Sun, 2 Oct 2022 14:40:01 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab2.mbox
Message-ID: <YznbAAM0CvM9jDRd@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="5Q/YuqQgeZBRdzKS"
Content-Disposition: inline
Status: RO
Content-Length: 18413
Lines: 516


--5Q/YuqQgeZBRdzKS
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 17:34:41 -0400
Subject: [PATCH 1/6] First commit, I wrote README.txt

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..1a636b2 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 2
+  - My program should work as it should!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 18:12:48 -0400
Subject: [PATCH 2/6] I wrote Makefile for part1.

---
 part1/Makefile  | 13 +++++++++++++
 part1/convert.c |  3 ++-
 2 files changed, 15 insertions(+), 1 deletion(-)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..dcdd935
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,13 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+
+convert: convert.o
+	$(CC) $(LDFLAGS) -o convert convert.o
+
+convert.o: convert.c
+	$(CC) $(CFLAGS) -c -o convert.o convert.c
+
+.PHONY: clean
+clean:
+	rm -rf convert *.o
diff --git a/part1/convert.c b/part1/convert.c
index ce35b0e..0b3fa1c 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -13,6 +13,7 @@ int main(int argc, char **argv)
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-
+    printf("binary:       %x\n", x);
+    
     return 0;
 }
-- 
2.34.1


From 8866c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 20:14:53 -0400
Subject: [PATCH 3/6] I wrote the binary printer for part1.

---
 part1/convert.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/part1/convert.c b/part1/convert.c
index 0b3fa1c..8e1e5a9 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -10,10 +10,23 @@ int main(int argc, char **argv)
 
     int x = atoi(argv[1]); // Parse the first argument as an int
 
+    char binary[] = "0000 0000 0000 0000 0000 0000 0000 0000";
+    
+    int compare  = 1;
+    int count = 0;
+    
+    while(count != 32){
+        if(x & compare){
+            binary[38  -count -count/4]='1';
+        }
+        compare = compare << 1;
+        count++;
+    }  
+
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-    printf("binary:       %x\n", x);
-    
+    printf("binary:       %s\n", binary);
+   
     return 0;
 }
-- 
2.34.1


From c10b3a64c6f553348d06e40f7264add9d8df973e Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 1 Oct 2022 17:47:45 -0400
Subject: [PATCH 4/6] I created twecho.c and twecho.h.

---
 part2/twecho.c | 8 ++++++++
 part2/twecho.h | 3 +++
 2 files changed, 11 insertions(+)
 create mode 100644 part2/twecho.c
 create mode 100644 part2/twecho.h

diff --git a/part2/twecho.c b/part2/twecho.c
new file mode 100644
index 0000000..0885bd6
--- /dev/null
+++ b/part2/twecho.c
@@ -0,0 +1,8 @@
+#include "twecho.h"
+
+char **duplicateArgs(int argc, char **argv){
+}
+
+void freeDuplicatedArgs(char **copy){
+}
+
diff --git a/part2/twecho.h b/part2/twecho.h
new file mode 100644
index 0000000..13530ba
--- /dev/null
+++ b/part2/twecho.h
@@ -0,0 +1,3 @@
+char **duplicateArgs(int argc, char **argv);
+
+void freeDuplicatedArgs(char **copy);
-- 
2.34.1


From 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 03:48:01 -0400
Subject: [PATCH 5/6] I wrote twecho.c!

---
 part1/Makefile | 12 ++++++----
 part2/twecho.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index dcdd935..43a589d 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -1,13 +1,17 @@
 CC = gcc
 CFLAGS = -g -Wall -Wpedantic -std=c17
 LDFLAGS =
-
+LDLIBS =
+	
+# convert depends on convert.o
 convert: convert.o
-	$(CC) $(LDFLAGS) -o convert convert.o
 
+# convert.o depends on convert.c
 convert.o: convert.c
-	$(CC) $(CFLAGS) -c -o convert.o convert.c
 
 .PHONY: clean
 clean:
-	rm -rf convert *.o
+	rm -f *.o a.out core convert
+
+.PHONY: all
+all: clean convert
diff --git a/part2/twecho.c b/part2/twecho.c
index 0885bd6..a73b58b 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -1,8 +1,70 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
 #include "twecho.h"
 
+//don't forget to add malloc null check!
+
 char **duplicateArgs(int argc, char **argv){
+
+    char **copy = malloc((argc+1) * sizeof(char *));
+    if (copy == NULL) {     
+        perror("malloc returned NULL");
+        exit(1);
+    }
+    char **p = copy;
+        
+    
+    while(*argv){
+        *p = malloc(((strlen(*argv)+1) * sizeof(char)));
+        if (p == NULL) {
+            perror("malloc returned NULL");
+            exit(1);
+        }
+        size_t i;
+        for(i = 0; i < strlen(*argv); i++){
+            *(*p+i)=toupper(*(*argv+i));
+        }
+        *(*p+strlen(*argv)) = '\0';
+
+        argv++;
+        p++;
+    }   
+    *p = NULL;
+    
+    return copy;
 }
 
+/*
+    char **copy = duplicateArgs(argc, argv);
+    char **p = copy;
+
+    argv++; //shifts by 8 bytes
+    p++; //shifts by 8 btyes, now it points at the pointer which point at the address of 
+    while (*argv) {
+        printf("%s %s\n", *argv++, *p++);
+    }
+
+    freeDuplicatedArgs(copy);
+*/
+
+
 void freeDuplicatedArgs(char **copy){
+    int i=1;
+    char **original = copy;
+
+    while(*copy){
+        char *temp = *copy;
+        free(temp);
+        printf("%d. String is freed\n", i);
+        copy++;
+        i++;
+    }
+    
+    free(original);
+    printf("The array is freed\n");
+    
+    return;
 }
 
-- 
2.34.1


From 1408305c266d57f6e5a6c8b09dfb402c9dfcfde9 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 14:39:09 -0400
Subject: [PATCH 6/6] Final commit!

---
 README.txt     |  4 ++--
 part2/Makefile | 17 +++++++++++++++++
 part2/twecho.c | 23 ++---------------------
 3 files changed, 21 insertions(+), 23 deletions(-)
 create mode 100644 part2/Makefile

diff --git a/README.txt b/README.txt
index 1a636b2..9e16cd4 100644
--- a/README.txt
+++ b/README.txt
@@ -2,8 +2,8 @@ This file should contain:
 
   - Arman Ozcan
   - ao2794
-  - lab 2
-  - My program should work as it should!
+  - Lab 2
+  - My program seems to  work as it should.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..924e0f5
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,17 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+	
+twecho: twecho.o main.o
+
+twecho.o: twecho.c twecho.h
+
+main.o: main.c twecho.h
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core twecho
+
+.PHONY: all
+all: clean twecho
diff --git a/part2/twecho.c b/part2/twecho.c
index a73b58b..616dbea 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -4,8 +4,6 @@
 #include <string.h>
 #include "twecho.h"
 
-//don't forget to add malloc null check!
-
 char **duplicateArgs(int argc, char **argv){
 
     char **copy = malloc((argc+1) * sizeof(char *));
@@ -36,34 +34,17 @@ char **duplicateArgs(int argc, char **argv){
     return copy;
 }
 
-/*
-    char **copy = duplicateArgs(argc, argv);
-    char **p = copy;
-
-    argv++; //shifts by 8 bytes
-    p++; //shifts by 8 btyes, now it points at the pointer which point at the address of 
-    while (*argv) {
-        printf("%s %s\n", *argv++, *p++);
-    }
-
-    freeDuplicatedArgs(copy);
-*/
-
-
 void freeDuplicatedArgs(char **copy){
-    int i=1;
+    
     char **original = copy;
 
     while(*copy){
         char *temp = *copy;
-        free(temp);
-        printf("%d. String is freed\n", i);
+        free(temp);    
         copy++;
-        i++;
     }
     
     free(original);
-    printf("The array is freed\n");
     
     return;
 }
-- 
2.34.1


--5Q/YuqQgeZBRdzKS
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 17:34:41=
 -0400=0ASubject: [PATCH 1/6] First commit, I wrote README.txt=0A=0A---=0A =
README.txt | 8 ++++----=0A 1 file changed, 4 insertions(+), 4 deletions(-)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..1a636b2 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -1,9 +1,9 @@=0A This file shoul=
d contain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment numbe=
r=0A-  - description for each part=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - =
lab 2=0A+  - My program should work as it should!=0A =0A The description sh=
ould indicate whether your solution for the part is=0A working or not.  You=
 may also want to include anything else you would=0A-- =0A2.34.1=0A=0A=0AFr=
om a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001=0AFrom=
: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 18:12:48 -0400=
=0ASubject: [PATCH 2/6] I wrote Makefile for part1.=0A=0A---=0A part1/Makef=
ile  | 13 +++++++++++++=0A part1/convert.c |  3 ++-=0A 2 files changed, 15 =
insertions(+), 1 deletion(-)=0A create mode 100644 part1/Makefile=0A=0Adiff=
 --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 000=
0000..dcdd935=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,13 @@=0A+=
CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A+LDFLAGS =3D=0A+=
=0A+convert: convert.o=0A+	$(CC) $(LDFLAGS) -o convert convert.o=0A+=0A+con=
vert.o: convert.c=0A+	$(CC) $(CFLAGS) -c -o convert.o convert.c=0A+=0A+.PHO=
NY: clean=0A+clean:=0A+	rm -rf convert *.o=0Adiff --git a/part1/convert.c b=
/part1/convert.c=0Aindex ce35b0e..0b3fa1c 100644=0A--- a/part1/convert.c=0A=
+++ b/part1/convert.c=0A@@ -13,6 +13,7 @@ int main(int argc, char **argv)=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-=0A+    printf("binary:   =
    %x\n", x);=0A+    =0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom 88=
66c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001=0AFrom: Arm=
an Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 20:14:53 -0400=0ASu=
bject: [PATCH 3/6] I wrote the binary printer for part1.=0A=0A---=0A part1/=
convert.c | 17 +++++++++++++++--=0A 1 file changed, 15 insertions(+), 2 del=
etions(-)=0A=0Adiff --git a/part1/convert.c b/part1/convert.c=0Aindex 0b3fa=
1c..8e1e5a9 100644=0A--- a/part1/convert.c=0A+++ b/part1/convert.c=0A@@ -10=
,10 +10,23 @@ int main(int argc, char **argv)=0A =0A     int x =3D atoi(arg=
v[1]); // Parse the first argument as an int=0A =0A+    char binary[] =3D "=
0000 0000 0000 0000 0000 0000 0000 0000";=0A+    =0A+    int compare  =3D 1=
;=0A+    int count =3D 0;=0A+    =0A+    while(count !=3D 32){=0A+        i=
f(x & compare){=0A+            binary[38  -count -count/4]=3D'1';=0A+      =
  }=0A+        compare =3D compare << 1;=0A+        count++;=0A+    }  =0A+=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-    printf("binary:       =
%x\n", x);=0A-    =0A+    printf("binary:       %s\n", binary);=0A+   =0A  =
   return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom c10b3a64c6f553348d06e40f7264a=
dd9d8df973e Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.e=
du>=0ADate: Sat, 1 Oct 2022 17:47:45 -0400=0ASubject: [PATCH 4/6] I created=
 twecho.c and twecho.h.=0A=0A---=0A part2/twecho.c | 8 ++++++++=0A part2/tw=
echo.h | 3 +++=0A 2 files changed, 11 insertions(+)=0A create mode 100644 p=
art2/twecho.c=0A create mode 100644 part2/twecho.h=0A=0Adiff --git a/part2/=
twecho.c b/part2/twecho.c=0Anew file mode 100644=0Aindex 0000000..0885bd6=
=0A--- /dev/null=0A+++ b/part2/twecho.c=0A@@ -0,0 +1,8 @@=0A+#include "twec=
ho.h"=0A+=0A+char **duplicateArgs(int argc, char **argv){=0A+}=0A+=0A+void =
freeDuplicatedArgs(char **copy){=0A+}=0A+=0Adiff --git a/part2/twecho.h b/p=
art2/twecho.h=0Anew file mode 100644=0Aindex 0000000..13530ba=0A--- /dev/nu=
ll=0A+++ b/part2/twecho.h=0A@@ -0,0 +1,3 @@=0A+char **duplicateArgs(int arg=
c, char **argv);=0A+=0A+void freeDuplicatedArgs(char **copy);=0A-- =0A2.34.=
1=0A=0A=0AFrom 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00=
 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 2 Oct 2022 03:=
48:01 -0400=0ASubject: [PATCH 5/6] I wrote twecho.c!=0A=0A---=0A part1/Make=
file | 12 ++++++----=0A part2/twecho.c | 62 +++++++++++++++++++++++++++++++=
+++++++++++++++++++=0A 2 files changed, 70 insertions(+), 4 deletions(-)=0A=
=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex dcdd935..43a589d 10=
0644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -1,13 +1,17 @@=0A C=
C =3D gcc=0A CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A LDFLAGS =3D=0A-=
=0A+LDLIBS =3D=0A+	=0A+# convert depends on convert.o=0A convert: convert.o=
=0A-	$(CC) $(LDFLAGS) -o convert convert.o=0A =0A+# convert.o depends on co=
nvert.c=0A convert.o: convert.c=0A-	$(CC) $(CFLAGS) -c -o convert.o convert=
=2Ec=0A =0A .PHONY: clean=0A clean:=0A-	rm -rf convert *.o=0A+	rm -f *.o a.=
out core convert=0A+=0A+.PHONY: all=0A+all: clean convert=0Adiff --git a/pa=
rt2/twecho.c b/part2/twecho.c=0Aindex 0885bd6..a73b58b 100644=0A--- a/part2=
/twecho.c=0A+++ b/part2/twecho.c=0A@@ -1,8 +1,70 @@=0A+#include <stdio.h>=
=0A+#include <stdlib.h>=0A+#include <ctype.h>=0A+#include <string.h>=0A #in=
clude "twecho.h"=0A =0A+//don't forget to add malloc null check!=0A+=0A cha=
r **duplicateArgs(int argc, char **argv){=0A+=0A+    char **copy =3D malloc=
((argc+1) * sizeof(char *));=0A+    if (copy =3D=3D NULL) {     =0A+       =
 perror("malloc returned NULL");=0A+        exit(1);=0A+    }=0A+    char *=
*p =3D copy;=0A+        =0A+    =0A+    while(*argv){=0A+        *p =3D mal=
loc(((strlen(*argv)+1) * sizeof(char)));=0A+        if (p =3D=3D NULL) {=0A=
+            perror("malloc returned NULL");=0A+            exit(1);=0A+   =
     }=0A+        size_t i;=0A+        for(i =3D 0; i < strlen(*argv); i++)=
{=0A+            *(*p+i)=3Dtoupper(*(*argv+i));=0A+        }=0A+        *(*=
p+strlen(*argv)) =3D '\0';=0A+=0A+        argv++;=0A+        p++;=0A+    } =
  =0A+    *p =3D NULL;=0A+    =0A+    return copy;=0A }=0A =0A+/*=0A+    ch=
ar **copy =3D duplicateArgs(argc, argv);=0A+    char **p =3D copy;=0A+=0A+ =
   argv++; //shifts by 8 bytes=0A+    p++; //shifts by 8 btyes, now it poin=
ts at the pointer which point at the address of =0A+    while (*argv) {=0A+=
        printf("%s %s\n", *argv++, *p++);=0A+    }=0A+=0A+    freeDuplicate=
dArgs(copy);=0A+*/=0A+=0A+=0A void freeDuplicatedArgs(char **copy){=0A+    =
int i=3D1;=0A+    char **original =3D copy;=0A+=0A+    while(*copy){=0A+   =
     char *temp =3D *copy;=0A+        free(temp);=0A+        printf("%d. St=
ring is freed\n", i);=0A+        copy++;=0A+        i++;=0A+    }=0A+    =
=0A+    free(original);=0A+    printf("The array is freed\n");=0A+    =0A+ =
   return;=0A }=0A =0A-- =0A2.34.1=0A=0A=0AFrom 1408305c266d57f6e5a6c8b09df=
b402c9dfcfde9 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia=
=2Eedu>=0ADate: Sun, 2 Oct 2022 14:39:09 -0400=0ASubject: [PATCH 6/6] Final=
 commit!=0A=0A---=0A README.txt     |  4 ++--=0A part2/Makefile | 17 ++++++=
+++++++++++=0A part2/twecho.c | 23 ++---------------------=0A 3 files chang=
ed, 21 insertions(+), 23 deletions(-)=0A create mode 100644 part2/Makefile=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 1a636b2..9e16cd4 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -2,8 +2,8 @@ This file should c=
ontain:=0A =0A   - Arman Ozcan=0A   - ao2794=0A-  - lab 2=0A-  - My program=
 should work as it should!=0A+  - Lab 2=0A+  - My program seems to  work as=
 it should.=0A =0A The description should indicate whether your solution fo=
r the part is=0A working or not.  You may also want to include anything els=
e you would=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mode =
100644=0Aindex 0000000..924e0f5=0A--- /dev/null=0A+++ b/part2/Makefile=0A@@=
 -0,0 +1,17 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=
=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+	=0A+twecho: twecho.o main.o=0A+=0A+twecho=
=2Eo: twecho.c twecho.h=0A+=0A+main.o: main.c twecho.h=0A+=0A+.PHONY: clean=
=0A+clean:=0A+	rm -f *.o a.out core twecho=0A+=0A+.PHONY: all=0A+all: clean=
 twecho=0Adiff --git a/part2/twecho.c b/part2/twecho.c=0Aindex a73b58b..616=
dbea 100644=0A--- a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -4,8 +4,6 @@=
=0A #include <string.h>=0A #include "twecho.h"=0A =0A-//don't forget to add=
 malloc null check!=0A-=0A char **duplicateArgs(int argc, char **argv){=0A =
=0A     char **copy =3D malloc((argc+1) * sizeof(char *));=0A@@ -36,34 +34,=
17 @@ char **duplicateArgs(int argc, char **argv){=0A     return copy;=0A }=
=0A =0A-/*=0A-    char **copy =3D duplicateArgs(argc, argv);=0A-    char **=
p =3D copy;=0A-=0A-    argv++; //shifts by 8 bytes=0A-    p++; //shifts by =
8 btyes, now it points at the pointer which point at the address of =0A-   =
 while (*argv) {=0A-        printf("%s %s\n", *argv++, *p++);=0A-    }=0A-=
=0A-    freeDuplicatedArgs(copy);=0A-*/=0A-=0A-=0A void freeDuplicatedArgs(=
char **copy){=0A-    int i=3D1;=0A+    =0A     char **original =3D copy;=0A=
 =0A     while(*copy){=0A         char *temp =3D *copy;=0A-        free(tem=
p);=0A-        printf("%d. String is freed\n", i);=0A+        free(temp);  =
  =0A         copy++;=0A-        i++;=0A     }=0A     =0A     free(original=
);=0A-    printf("The array is freed\n");=0A     =0A     return;=0A }=0A-- =
=0A2.34.1=0A=0A
--5Q/YuqQgeZBRdzKS--

From do.not.reply@cloud.cs.columbia.edu Sun Oct  2 23:34:58 2022
Date: Sun, 2 Oct 2022 23:34:58 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab2.mbox
Message-ID: <YzpYYStOsPH7ogNk@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="Y8t+oDPVYhXpBuk9"
Content-Disposition: inline
Status: RO
Content-Length: 23365
Lines: 610


--Y8t+oDPVYhXpBuk9
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 17:34:41 -0400
Subject: [PATCH 1/7] First commit, I wrote README.txt

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..1a636b2 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 2
+  - My program should work as it should!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 18:12:48 -0400
Subject: [PATCH 2/7] I wrote Makefile for part1.

---
 part1/Makefile  | 13 +++++++++++++
 part1/convert.c |  3 ++-
 2 files changed, 15 insertions(+), 1 deletion(-)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..dcdd935
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,13 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+
+convert: convert.o
+	$(CC) $(LDFLAGS) -o convert convert.o
+
+convert.o: convert.c
+	$(CC) $(CFLAGS) -c -o convert.o convert.c
+
+.PHONY: clean
+clean:
+	rm -rf convert *.o
diff --git a/part1/convert.c b/part1/convert.c
index ce35b0e..0b3fa1c 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -13,6 +13,7 @@ int main(int argc, char **argv)
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-
+    printf("binary:       %x\n", x);
+    
     return 0;
 }
-- 
2.34.1


From 8866c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 25 Sep 2022 20:14:53 -0400
Subject: [PATCH 3/7] I wrote the binary printer for part1.

---
 part1/convert.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/part1/convert.c b/part1/convert.c
index 0b3fa1c..8e1e5a9 100644
--- a/part1/convert.c
+++ b/part1/convert.c
@@ -10,10 +10,23 @@ int main(int argc, char **argv)
 
     int x = atoi(argv[1]); // Parse the first argument as an int
 
+    char binary[] = "0000 0000 0000 0000 0000 0000 0000 0000";
+    
+    int compare  = 1;
+    int count = 0;
+    
+    while(count != 32){
+        if(x & compare){
+            binary[38  -count -count/4]='1';
+        }
+        compare = compare << 1;
+        count++;
+    }  
+
     printf("signed dec:   %d\n", x);
     printf("unsigned dec: %u\n", x);
     printf("hex:          %x\n", x);
-    printf("binary:       %x\n", x);
-    
+    printf("binary:       %s\n", binary);
+   
     return 0;
 }
-- 
2.34.1


From c10b3a64c6f553348d06e40f7264add9d8df973e Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 1 Oct 2022 17:47:45 -0400
Subject: [PATCH 4/7] I created twecho.c and twecho.h.

---
 part2/twecho.c | 8 ++++++++
 part2/twecho.h | 3 +++
 2 files changed, 11 insertions(+)
 create mode 100644 part2/twecho.c
 create mode 100644 part2/twecho.h

diff --git a/part2/twecho.c b/part2/twecho.c
new file mode 100644
index 0000000..0885bd6
--- /dev/null
+++ b/part2/twecho.c
@@ -0,0 +1,8 @@
+#include "twecho.h"
+
+char **duplicateArgs(int argc, char **argv){
+}
+
+void freeDuplicatedArgs(char **copy){
+}
+
diff --git a/part2/twecho.h b/part2/twecho.h
new file mode 100644
index 0000000..13530ba
--- /dev/null
+++ b/part2/twecho.h
@@ -0,0 +1,3 @@
+char **duplicateArgs(int argc, char **argv);
+
+void freeDuplicatedArgs(char **copy);
-- 
2.34.1


From 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 03:48:01 -0400
Subject: [PATCH 5/7] I wrote twecho.c!

---
 part1/Makefile | 12 ++++++----
 part2/twecho.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index dcdd935..43a589d 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -1,13 +1,17 @@
 CC = gcc
 CFLAGS = -g -Wall -Wpedantic -std=c17
 LDFLAGS =
-
+LDLIBS =
+	
+# convert depends on convert.o
 convert: convert.o
-	$(CC) $(LDFLAGS) -o convert convert.o
 
+# convert.o depends on convert.c
 convert.o: convert.c
-	$(CC) $(CFLAGS) -c -o convert.o convert.c
 
 .PHONY: clean
 clean:
-	rm -rf convert *.o
+	rm -f *.o a.out core convert
+
+.PHONY: all
+all: clean convert
diff --git a/part2/twecho.c b/part2/twecho.c
index 0885bd6..a73b58b 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -1,8 +1,70 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
 #include "twecho.h"
 
+//don't forget to add malloc null check!
+
 char **duplicateArgs(int argc, char **argv){
+
+    char **copy = malloc((argc+1) * sizeof(char *));
+    if (copy == NULL) {     
+        perror("malloc returned NULL");
+        exit(1);
+    }
+    char **p = copy;
+        
+    
+    while(*argv){
+        *p = malloc(((strlen(*argv)+1) * sizeof(char)));
+        if (p == NULL) {
+            perror("malloc returned NULL");
+            exit(1);
+        }
+        size_t i;
+        for(i = 0; i < strlen(*argv); i++){
+            *(*p+i)=toupper(*(*argv+i));
+        }
+        *(*p+strlen(*argv)) = '\0';
+
+        argv++;
+        p++;
+    }   
+    *p = NULL;
+    
+    return copy;
 }
 
+/*
+    char **copy = duplicateArgs(argc, argv);
+    char **p = copy;
+
+    argv++; //shifts by 8 bytes
+    p++; //shifts by 8 btyes, now it points at the pointer which point at the address of 
+    while (*argv) {
+        printf("%s %s\n", *argv++, *p++);
+    }
+
+    freeDuplicatedArgs(copy);
+*/
+
+
 void freeDuplicatedArgs(char **copy){
+    int i=1;
+    char **original = copy;
+
+    while(*copy){
+        char *temp = *copy;
+        free(temp);
+        printf("%d. String is freed\n", i);
+        copy++;
+        i++;
+    }
+    
+    free(original);
+    printf("The array is freed\n");
+    
+    return;
 }
 
-- 
2.34.1


From 1408305c266d57f6e5a6c8b09dfb402c9dfcfde9 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 14:39:09 -0400
Subject: [PATCH 6/7] Final commit!

---
 README.txt     |  4 ++--
 part2/Makefile | 17 +++++++++++++++++
 part2/twecho.c | 23 ++---------------------
 3 files changed, 21 insertions(+), 23 deletions(-)
 create mode 100644 part2/Makefile

diff --git a/README.txt b/README.txt
index 1a636b2..9e16cd4 100644
--- a/README.txt
+++ b/README.txt
@@ -2,8 +2,8 @@ This file should contain:
 
   - Arman Ozcan
   - ao2794
-  - lab 2
-  - My program should work as it should!
+  - Lab 2
+  - My program seems to  work as it should.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..924e0f5
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,17 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+	
+twecho: twecho.o main.o
+
+twecho.o: twecho.c twecho.h
+
+main.o: main.c twecho.h
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core twecho
+
+.PHONY: all
+all: clean twecho
diff --git a/part2/twecho.c b/part2/twecho.c
index a73b58b..616dbea 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -4,8 +4,6 @@
 #include <string.h>
 #include "twecho.h"
 
-//don't forget to add malloc null check!
-
 char **duplicateArgs(int argc, char **argv){
 
     char **copy = malloc((argc+1) * sizeof(char *));
@@ -36,34 +34,17 @@ char **duplicateArgs(int argc, char **argv){
     return copy;
 }
 
-/*
-    char **copy = duplicateArgs(argc, argv);
-    char **p = copy;
-
-    argv++; //shifts by 8 bytes
-    p++; //shifts by 8 btyes, now it points at the pointer which point at the address of 
-    while (*argv) {
-        printf("%s %s\n", *argv++, *p++);
-    }
-
-    freeDuplicatedArgs(copy);
-*/
-
-
 void freeDuplicatedArgs(char **copy){
-    int i=1;
+    
     char **original = copy;
 
     while(*copy){
         char *temp = *copy;
-        free(temp);
-        printf("%d. String is freed\n", i);
+        free(temp);    
         copy++;
-        i++;
     }
     
     free(original);
-    printf("The array is freed\n");
     
     return;
 }
-- 
2.34.1


From e6f9ebb7e7feb31fb971d1af79738a20b8199eb7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 2 Oct 2022 23:33:22 -0400
Subject: [PATCH 7/7] This is the actual final commit. I added the Valgrind
 output to README.txt.

---
 README.txt | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/README.txt b/README.txt
index 9e16cd4..75871f8 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,40 @@ The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==1796067== Memcheck, a memory error detector
+==1796067== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1796067== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1796067== Command: ./convert 512
+==1796067== 
+signed dec:   512
+unsigned dec: 512
+hex:          200
+binary:       0000 0000 0000 0000 0000 0010 0000 0000
+==1796067== 
+==1796067== HEAP SUMMARY:
+==1796067==     in use at exit: 0 bytes in 0 blocks
+==1796067==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
+==1796067== 
+==1796067== All heap blocks were freed -- no leaks are possible
+==1796067== 
+==1796067== For lists of detected and suppressed errors, rerun with: -s
+==1796067== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==1799725== Memcheck, a memory error detector
+==1799725== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==1799725== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==1799725== Command: ./twecho This is an example sentence!
+==1799725== 
+This THIS
+is IS
+an AN
+example EXAMPLE
+sentence! SENTENCE!
+==1799725== 
+==1799725== HEAP SUMMARY:
+==1799725==     in use at exit: 0 bytes in 0 blocks
+==1799725==   total heap usage: 8 allocs, 8 frees, 1,630 bytes allocated
+==1799725== 
+==1799725== All heap blocks were freed -- no leaks are possible
+==1799725== 
+==1799725== For lists of detected and suppressed errors, rerun with: -s
+==1799725== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
-- 
2.34.1


--Y8t+oDPVYhXpBuk9
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d2295c12b98a5d72f79275d04c3583c82877af4a Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 17:34:41=
 -0400=0ASubject: [PATCH 1/7] First commit, I wrote README.txt=0A=0A---=0A =
README.txt | 8 ++++----=0A 1 file changed, 4 insertions(+), 4 deletions(-)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..1a636b2 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -1,9 +1,9 @@=0A This file shoul=
d contain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment numbe=
r=0A-  - description for each part=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - =
lab 2=0A+  - My program should work as it should!=0A =0A The description sh=
ould indicate whether your solution for the part is=0A working or not.  You=
 may also want to include anything else you would=0A-- =0A2.34.1=0A=0A=0AFr=
om a3ee19f72f1d98536314b4dcf0e25ad81a786cbe Mon Sep 17 00:00:00 2001=0AFrom=
: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 18:12:48 -0400=
=0ASubject: [PATCH 2/7] I wrote Makefile for part1.=0A=0A---=0A part1/Makef=
ile  | 13 +++++++++++++=0A part1/convert.c |  3 ++-=0A 2 files changed, 15 =
insertions(+), 1 deletion(-)=0A create mode 100644 part1/Makefile=0A=0Adiff=
 --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 000=
0000..dcdd935=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,13 @@=0A+=
CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A+LDFLAGS =3D=0A+=
=0A+convert: convert.o=0A+	$(CC) $(LDFLAGS) -o convert convert.o=0A+=0A+con=
vert.o: convert.c=0A+	$(CC) $(CFLAGS) -c -o convert.o convert.c=0A+=0A+.PHO=
NY: clean=0A+clean:=0A+	rm -rf convert *.o=0Adiff --git a/part1/convert.c b=
/part1/convert.c=0Aindex ce35b0e..0b3fa1c 100644=0A--- a/part1/convert.c=0A=
+++ b/part1/convert.c=0A@@ -13,6 +13,7 @@ int main(int argc, char **argv)=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-=0A+    printf("binary:   =
    %x\n", x);=0A+    =0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom 88=
66c614642a25cbdc79e5059eea2f37fd6c7cd1 Mon Sep 17 00:00:00 2001=0AFrom: Arm=
an Ozcan <ao2794@columbia.edu>=0ADate: Sun, 25 Sep 2022 20:14:53 -0400=0ASu=
bject: [PATCH 3/7] I wrote the binary printer for part1.=0A=0A---=0A part1/=
convert.c | 17 +++++++++++++++--=0A 1 file changed, 15 insertions(+), 2 del=
etions(-)=0A=0Adiff --git a/part1/convert.c b/part1/convert.c=0Aindex 0b3fa=
1c..8e1e5a9 100644=0A--- a/part1/convert.c=0A+++ b/part1/convert.c=0A@@ -10=
,10 +10,23 @@ int main(int argc, char **argv)=0A =0A     int x =3D atoi(arg=
v[1]); // Parse the first argument as an int=0A =0A+    char binary[] =3D "=
0000 0000 0000 0000 0000 0000 0000 0000";=0A+    =0A+    int compare  =3D 1=
;=0A+    int count =3D 0;=0A+    =0A+    while(count !=3D 32){=0A+        i=
f(x & compare){=0A+            binary[38  -count -count/4]=3D'1';=0A+      =
  }=0A+        compare =3D compare << 1;=0A+        count++;=0A+    }  =0A+=
=0A     printf("signed dec:   %d\n", x);=0A     printf("unsigned dec: %u\n"=
, x);=0A     printf("hex:          %x\n", x);=0A-    printf("binary:       =
%x\n", x);=0A-    =0A+    printf("binary:       %s\n", binary);=0A+   =0A  =
   return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom c10b3a64c6f553348d06e40f7264a=
dd9d8df973e Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.e=
du>=0ADate: Sat, 1 Oct 2022 17:47:45 -0400=0ASubject: [PATCH 4/7] I created=
 twecho.c and twecho.h.=0A=0A---=0A part2/twecho.c | 8 ++++++++=0A part2/tw=
echo.h | 3 +++=0A 2 files changed, 11 insertions(+)=0A create mode 100644 p=
art2/twecho.c=0A create mode 100644 part2/twecho.h=0A=0Adiff --git a/part2/=
twecho.c b/part2/twecho.c=0Anew file mode 100644=0Aindex 0000000..0885bd6=
=0A--- /dev/null=0A+++ b/part2/twecho.c=0A@@ -0,0 +1,8 @@=0A+#include "twec=
ho.h"=0A+=0A+char **duplicateArgs(int argc, char **argv){=0A+}=0A+=0A+void =
freeDuplicatedArgs(char **copy){=0A+}=0A+=0Adiff --git a/part2/twecho.h b/p=
art2/twecho.h=0Anew file mode 100644=0Aindex 0000000..13530ba=0A--- /dev/nu=
ll=0A+++ b/part2/twecho.h=0A@@ -0,0 +1,3 @@=0A+char **duplicateArgs(int arg=
c, char **argv);=0A+=0A+void freeDuplicatedArgs(char **copy);=0A-- =0A2.34.=
1=0A=0A=0AFrom 1dc717cc80c885387e2dd7ea9f6c832d81c84570 Mon Sep 17 00:00:00=
 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 2 Oct 2022 03:=
48:01 -0400=0ASubject: [PATCH 5/7] I wrote twecho.c!=0A=0A---=0A part1/Make=
file | 12 ++++++----=0A part2/twecho.c | 62 +++++++++++++++++++++++++++++++=
+++++++++++++++++++=0A 2 files changed, 70 insertions(+), 4 deletions(-)=0A=
=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex dcdd935..43a589d 10=
0644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -1,13 +1,17 @@=0A C=
C =3D gcc=0A CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A LDFLAGS =3D=0A-=
=0A+LDLIBS =3D=0A+	=0A+# convert depends on convert.o=0A convert: convert.o=
=0A-	$(CC) $(LDFLAGS) -o convert convert.o=0A =0A+# convert.o depends on co=
nvert.c=0A convert.o: convert.c=0A-	$(CC) $(CFLAGS) -c -o convert.o convert=
=2Ec=0A =0A .PHONY: clean=0A clean:=0A-	rm -rf convert *.o=0A+	rm -f *.o a.=
out core convert=0A+=0A+.PHONY: all=0A+all: clean convert=0Adiff --git a/pa=
rt2/twecho.c b/part2/twecho.c=0Aindex 0885bd6..a73b58b 100644=0A--- a/part2=
/twecho.c=0A+++ b/part2/twecho.c=0A@@ -1,8 +1,70 @@=0A+#include <stdio.h>=
=0A+#include <stdlib.h>=0A+#include <ctype.h>=0A+#include <string.h>=0A #in=
clude "twecho.h"=0A =0A+//don't forget to add malloc null check!=0A+=0A cha=
r **duplicateArgs(int argc, char **argv){=0A+=0A+    char **copy =3D malloc=
((argc+1) * sizeof(char *));=0A+    if (copy =3D=3D NULL) {     =0A+       =
 perror("malloc returned NULL");=0A+        exit(1);=0A+    }=0A+    char *=
*p =3D copy;=0A+        =0A+    =0A+    while(*argv){=0A+        *p =3D mal=
loc(((strlen(*argv)+1) * sizeof(char)));=0A+        if (p =3D=3D NULL) {=0A=
+            perror("malloc returned NULL");=0A+            exit(1);=0A+   =
     }=0A+        size_t i;=0A+        for(i =3D 0; i < strlen(*argv); i++)=
{=0A+            *(*p+i)=3Dtoupper(*(*argv+i));=0A+        }=0A+        *(*=
p+strlen(*argv)) =3D '\0';=0A+=0A+        argv++;=0A+        p++;=0A+    } =
  =0A+    *p =3D NULL;=0A+    =0A+    return copy;=0A }=0A =0A+/*=0A+    ch=
ar **copy =3D duplicateArgs(argc, argv);=0A+    char **p =3D copy;=0A+=0A+ =
   argv++; //shifts by 8 bytes=0A+    p++; //shifts by 8 btyes, now it poin=
ts at the pointer which point at the address of =0A+    while (*argv) {=0A+=
        printf("%s %s\n", *argv++, *p++);=0A+    }=0A+=0A+    freeDuplicate=
dArgs(copy);=0A+*/=0A+=0A+=0A void freeDuplicatedArgs(char **copy){=0A+    =
int i=3D1;=0A+    char **original =3D copy;=0A+=0A+    while(*copy){=0A+   =
     char *temp =3D *copy;=0A+        free(temp);=0A+        printf("%d. St=
ring is freed\n", i);=0A+        copy++;=0A+        i++;=0A+    }=0A+    =
=0A+    free(original);=0A+    printf("The array is freed\n");=0A+    =0A+ =
   return;=0A }=0A =0A-- =0A2.34.1=0A=0A=0AFrom 1408305c266d57f6e5a6c8b09df=
b402c9dfcfde9 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia=
=2Eedu>=0ADate: Sun, 2 Oct 2022 14:39:09 -0400=0ASubject: [PATCH 6/7] Final=
 commit!=0A=0A---=0A README.txt     |  4 ++--=0A part2/Makefile | 17 ++++++=
+++++++++++=0A part2/twecho.c | 23 ++---------------------=0A 3 files chang=
ed, 21 insertions(+), 23 deletions(-)=0A create mode 100644 part2/Makefile=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 1a636b2..9e16cd4 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -2,8 +2,8 @@ This file should c=
ontain:=0A =0A   - Arman Ozcan=0A   - ao2794=0A-  - lab 2=0A-  - My program=
 should work as it should!=0A+  - Lab 2=0A+  - My program seems to  work as=
 it should.=0A =0A The description should indicate whether your solution fo=
r the part is=0A working or not.  You may also want to include anything els=
e you would=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mode =
100644=0Aindex 0000000..924e0f5=0A--- /dev/null=0A+++ b/part2/Makefile=0A@@=
 -0,0 +1,17 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=
=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+	=0A+twecho: twecho.o main.o=0A+=0A+twecho=
=2Eo: twecho.c twecho.h=0A+=0A+main.o: main.c twecho.h=0A+=0A+.PHONY: clean=
=0A+clean:=0A+	rm -f *.o a.out core twecho=0A+=0A+.PHONY: all=0A+all: clean=
 twecho=0Adiff --git a/part2/twecho.c b/part2/twecho.c=0Aindex a73b58b..616=
dbea 100644=0A--- a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -4,8 +4,6 @@=
=0A #include <string.h>=0A #include "twecho.h"=0A =0A-//don't forget to add=
 malloc null check!=0A-=0A char **duplicateArgs(int argc, char **argv){=0A =
=0A     char **copy =3D malloc((argc+1) * sizeof(char *));=0A@@ -36,34 +34,=
17 @@ char **duplicateArgs(int argc, char **argv){=0A     return copy;=0A }=
=0A =0A-/*=0A-    char **copy =3D duplicateArgs(argc, argv);=0A-    char **=
p =3D copy;=0A-=0A-    argv++; //shifts by 8 bytes=0A-    p++; //shifts by =
8 btyes, now it points at the pointer which point at the address of =0A-   =
 while (*argv) {=0A-        printf("%s %s\n", *argv++, *p++);=0A-    }=0A-=
=0A-    freeDuplicatedArgs(copy);=0A-*/=0A-=0A-=0A void freeDuplicatedArgs(=
char **copy){=0A-    int i=3D1;=0A+    =0A     char **original =3D copy;=0A=
 =0A     while(*copy){=0A         char *temp =3D *copy;=0A-        free(tem=
p);=0A-        printf("%d. String is freed\n", i);=0A+        free(temp);  =
  =0A         copy++;=0A-        i++;=0A     }=0A     =0A     free(original=
);=0A-    printf("The array is freed\n");=0A     =0A     return;=0A }=0A-- =
=0A2.34.1=0A=0A=0AFrom e6f9ebb7e7feb31fb971d1af79738a20b8199eb7 Mon Sep 17 =
00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 2 Oct =
2022 23:33:22 -0400=0ASubject: [PATCH 7/7] This is the actual final commit.=
 I added the Valgrind=0A output to README.txt.=0A=0A---=0A README.txt | 37 =
+++++++++++++++++++++++++++++++++++++=0A 1 file changed, 37 insertions(+)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 9e16cd4..75871f8 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -9,3 +9,40 @@ The description s=
hould indicate whether your solution for the part is=0A working or not.  Yo=
u may also want to include anything else you would=0A like to communicate t=
o the grader such as extra functionalities you=0A implemented or how you tr=
ied to fix your non-working code.=0A+=3D=3D1796067=3D=3D Memcheck, a memory=
 error detector=0A+=3D=3D1796067=3D=3D Copyright (C) 2002-2017, and GNU GPL=
'd, by Julian Seward et al.=0A+=3D=3D1796067=3D=3D Using Valgrind-3.18.1 an=
d LibVEX; rerun with -h for copyright info=0A+=3D=3D1796067=3D=3D Command: =
=2E/convert 512=0A+=3D=3D1796067=3D=3D =0A+signed dec:   512=0A+unsigned de=
c: 512=0A+hex:          200=0A+binary:       0000 0000 0000 0000 0000 0010 =
0000 0000=0A+=3D=3D1796067=3D=3D =0A+=3D=3D1796067=3D=3D HEAP SUMMARY:=0A+=
=3D=3D1796067=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D179606=
7=3D=3D   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated=0A+=3D=
=3D1796067=3D=3D =0A+=3D=3D1796067=3D=3D All heap blocks were freed -- no l=
eaks are possible=0A+=3D=3D1796067=3D=3D =0A+=3D=3D1796067=3D=3D For lists =
of detected and suppressed errors, rerun with: -s=0A+=3D=3D1796067=3D=3D ER=
ROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)=0A+=3D=3D17997=
25=3D=3D Memcheck, a memory error detector=0A+=3D=3D1799725=3D=3D Copyright=
 (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D1799725=3D=
=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info=0A+=
=3D=3D1799725=3D=3D Command: ./twecho This is an example sentence!=0A+=3D=
=3D1799725=3D=3D =0A+This THIS=0A+is IS=0A+an AN=0A+example EXAMPLE=0A+sent=
ence! SENTENCE!=0A+=3D=3D1799725=3D=3D =0A+=3D=3D1799725=3D=3D HEAP SUMMARY=
:=0A+=3D=3D1799725=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D1=
799725=3D=3D   total heap usage: 8 allocs, 8 frees, 1,630 bytes allocated=
=0A+=3D=3D1799725=3D=3D =0A+=3D=3D1799725=3D=3D All heap blocks were freed =
-- no leaks are possible=0A+=3D=3D1799725=3D=3D =0A+=3D=3D1799725=3D=3D For=
 lists of detected and suppressed errors, rerun with: -s=0A+=3D=3D1799725=
=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)=0A-- =
=0A2.34.1=0A=0A
--Y8t+oDPVYhXpBuk9--

From do.not.reply@cloud.cs.columbia.edu Sun Oct 16 23:59:34 2022
Date: Sun, 16 Oct 2022 23:59:34 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab3.mbox
Message-ID: <Y0zTJmFKJDkYyj8H@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="5uDsrq7Iv/ojqvOG"
Content-Disposition: inline
Status: RO
Content-Length: 77097
Lines: 1799


--5uDsrq7Iv/ojqvOG
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 5c52afd50c37f1c364f1c5b1c14db8a4d209fa9e Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 15 Oct 2022 17:07:14 -0400
Subject: [PATCH 01/10] Wrote some in README.txt.

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 66dfd3e..a61f6c4 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 3
+  -  
   
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From 5e4a259ee602df0a378bf67c18e490aafbe5b401 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 15 Oct 2022 17:53:51 -0400
Subject: [PATCH 02/10] Started mylist.c.

---
 part1/mylist.c | 133 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 133 insertions(+)
 create mode 100644 part1/mylist.c

diff --git a/part1/mylist.c b/part1/mylist.c
new file mode 100644
index 0000000..2aa4c48
--- /dev/null
+++ b/part1/mylist.c
@@ -0,0 +1,133 @@
+#include <stdlib.h>
+#include "mylist.h"
+
+/*
+ * A node in a linked list.
+ */
+struct Node {
+    void *data;
+    struct Node *next;
+};
+
+/*
+ * A linked list.
+ * 'head' points to the first node in the list, or is NULL if empty.
+ */
+struct List {
+    struct Node *head;
+};
+
+/*
+ * Initialize an empty list.
+ */
+static inline void initList(struct List *list)
+{
+    list->head = NULL;
+}
+
+/*
+ * In all functions below, the 'list' parameter is assumed to point to
+ * a valid struct List.
+ */
+
+/*
+ * Create a node that holds the given data pointer,
+ * and add the node to the front of the list.
+ *
+ * Note that this function does not manage the lifetime of the object
+ * pointed to by 'data'.
+ *
+ * It returns the newly created node on success and NULL on failure.
+ */
+struct Node *addFront(struct List *list, void *data);
+
+/*
+ * Traverse the list, calling f() with each data item.
+ */
+void traverseList(struct List *list, void (*f)(void *));
+
+/*
+ * Traverse the list, comparing each data item with 'dataSought' using
+ * 'compar' function.  ('compar' returns 0 if the data pointed to by
+ * the two parameters are equal, non-zero value otherwise.)
+ *
+ * Returns the first node containing the matching data,
+ * NULL if not found.
+ */
+struct Node *findNode(struct List *list, const void *dataSought,
+    int (*compar)(const void *, const void *));
+
+/*
+ * Flip the sign of the double value pointed to by 'data' by
+ * multiplying -1 to it and putting the result back into the memory
+ * location.
+ */
+void flipSignDouble(void *data);
+
+/*
+ * Compare two double values pointed to by the two pointers.
+ * Return 0 if they are the same value, 1 otherwise.
+ */
+int compareDouble(const void *data1, const void *data2);
+
+/*
+ * Returns 1 if the list is empty, 0 otherwise.
+ */
+static inline int isEmptyList(struct List *list)
+{
+    return (list->head == NULL);
+}
+
+/*
+ * Remove the first node from the list, deallocate the memory for the
+ * node, and return the 'data' pointer that was stored in the node.
+ * Returns NULL is the list is empty.
+ */
+void *popFront(struct List *list);
+
+/*
+ * Remove all nodes from the list, deallocating the memory for the
+ * nodes.  You can implement this function using popFront().
+ */
+void removeAllNodes(struct List *list);
+
+/*
+ * Create a node that holds the given data pointer,
+ * and add the node right after the node passed in as the 'prevNode'
+ * parameter.  If 'prevNode' is NULL, this function is equivalent to
+ * addFront().
+ *
+ * Note that prevNode, if not NULL, is assumed to be one of the nodes
+ * in the given list.  The behavior of this function is undefined if
+ * prevNode does not belong in the given list.
+ *
+ * Note that this function does not manage the lifetime of the object
+ * pointed to by 'data'.
+ *
+ * It returns the newly created node on success and NULL on failure.
+ */
+struct Node *addAfter(struct List *list,
+    struct Node *prevNode, void *data);
+
+/*
+ * Reverse the list.
+ *
+ * Note that this function reverses the list purely by manipulating
+ * pointers.  It does NOT call malloc() directly or indirectly (which
+ * means that it does not call addFront() or addAfter()).
+ *
+ * Implementation hint: keep track of 3 consecutive nodes (previous,
+ * current, next) and move them along in a while loop.  Your function
+ * should start like this:
+ *
+ *    struct Node *prv = NULL;
+ *    struct Node *cur = list->head;
+ *    struct Node *nxt;
+ *
+ *    while (cur)
+ *        ...
+ *
+ * And at the end, prv will end up pointing to the first element of
+ * the reversed list.  Don't forget to assign it to list->head.
+ */
+void reverseList(struct List *list);
-- 
2.34.1


From 9ece44912c9ae2c57575f4ee04703705d7beab42 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 15 Oct 2022 18:21:57 -0400
Subject: [PATCH 03/10] Started writing the Makefile.

---
 part1/Makefile | 63 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..cf80b4c
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,63 @@
+# Same C compiler and compiler flags as before:
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+
+# No linker flags, though these will later come in handy for the library user.
+LDFLAGS =
+LDLIBS =
+
+# We will use the ar utility to create archive files from object files, so it's
+# good practice to explicitly specify the "ar" command we would like to use:
+AR = ar
+
+# We can use the ARFLAGS variable to pass flags to the ar program.  For reasons
+# beyond our control and beyond the scope of this course, we need to add the -U
+# flag to ensure that Make doesn't try to rebuild the library archive when it
+# doesn't need to.  You can read more about why we need the -U flag here:
+# https://stackoverflow.com/a/73912307/10497710.
+ARFLAGS += -U
+
+# We can link archive files directly with object files; the linker command
+# produced by the Make implicit rule will look something like:
+#
+#   gcc  numbers-test.o  libnumbers.a  -o numbers-test
+#
+mylist-test: mylist-test.o libmylist.a
+
+# This is the rule for building the libnumbers.a archive file.  This rule says
+# that the libnumbers.a archive file should contain two object files---prime.o
+# and power.o---and should be updated whenever prime.o or power.o are updated.
+#
+# We rely on Make's implicit rules to update libnumbers.a when necessary.  The
+# template recipe for the implicit rule looks something like this:
+#
+#   $(AR)  $(ARFLAGS)  <archive-file.a>  <member-object-file.o>
+#
+# Our archive rule will lead to a recipe for each of the member object files,
+# which will turn out to be:
+#
+#   ar  rv -U  libnumbers.a  prime.o
+#
+# And:
+#
+#   ar  rv -U  libnumbers.a  power.o
+#
+# The "r" flag tells ar to add power.o (or prime.o) to libnumbers.a with
+# (r)eplacement (i.e., add it, and replace it if already present).
+#
+# The "v" flag tells ar to be verbose, i.e., output information about what it's
+# doing.
+#
+# The "-U" flag tells ar to preseve timestamps for archive members; this is
+# necessary so that Make doesn't try to replace archive members unnecessarily.
+libmylist.a: libmylist.a(mylist.o)
+
+# We use implicit rules to deal with object files, like before:
+mylist.o: mylist.c mylist.h
+mylist-test.o: mylist-test.c mylist.h
+
+# The usual .PHONY target for cleaning up the build directory; we also delete
+# any archive files built here.
+.PHONY: clean
+clean:
+	rm -rf mylist-test *.o *.a a.out
-- 
2.34.1


From e1056b273b9bf59110736aafa84f619666095a22 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 18:22:38 -0400
Subject: [PATCH 04/10] I wrote the methods until findNode.

---
 part1/Makefile |  7 ++++-
 part1/mylist.c | 85 ++++++++++++++++++++++++++++++++++++++------------
 2 files changed, 71 insertions(+), 21 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index cf80b4c..4541332 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -60,4 +60,9 @@ mylist-test.o: mylist-test.c mylist.h
 # any archive files built here.
 .PHONY: clean
 clean:
-	rm -rf mylist-test *.o *.a a.out
+	rm -rf mylist-test actualoutput.txt *.o *.a a.out
+
+.PHONY: compare
+compare: 
+	./mylist-test > actualoutput.txt
+	diff actualoutput.txt mylist-test-output.txt
diff --git a/part1/mylist.c b/part1/mylist.c
index 2aa4c48..0045ef5 100644
--- a/part1/mylist.c
+++ b/part1/mylist.c
@@ -3,29 +3,28 @@
 
 /*
  * A node in a linked list.
- */
+
 struct Node {
     void *data;
     struct Node *next;
 };
 
-/*
+
  * A linked list.
  * 'head' points to the first node in the list, or is NULL if empty.
- */
+
 struct List {
     struct Node *head;
 };
 
-/*
  * Initialize an empty list.
- */
+
 static inline void initList(struct List *list)
 {
     list->head = NULL;
 }
 
-/*
+
  * In all functions below, the 'list' parameter is assumed to point to
  * a valid struct List.
  */
@@ -39,12 +38,28 @@ static inline void initList(struct List *list)
  *
  * It returns the newly created node on success and NULL on failure.
  */
-struct Node *addFront(struct List *list, void *data);
+struct Node *addFront(struct List *list, void *data){
+    struct Node *n = malloc(sizeof(struct Node));
+    if(n == NULL){    
+        //perror("malloc returned NULL");
+        return NULL;
+    }    
+    n->data = data;
+    n->next = list->head;
+    list->head = n;
+    return n;
+}
 
 /*
  * Traverse the list, calling f() with each data item.
  */
-void traverseList(struct List *list, void (*f)(void *));
+void traverseList(struct List *list, void (*f)(void *)){
+    struct Node *n = list->head;
+    while(n != NULL){
+        (*f)(n->data);
+        n = n->next;
+    }
+}
 
 /*
  * Traverse the list, comparing each data item with 'dataSought' using
@@ -54,42 +69,68 @@ void traverseList(struct List *list, void (*f)(void *));
  * Returns the first node containing the matching data,
  * NULL if not found.
  */
-struct Node *findNode(struct List *list, const void *dataSought,
-    int (*compar)(const void *, const void *));
+struct Node *findNode(struct List *list, const void *dataSought, int (*compar)(const void *, const void *)){
+    struct Node *n = list->head;
+    while(n != NULL){
+        if(!(*compar)(dataSought,n->data))
+            return n;
+        n = n->next;
+    }
+    return NULL;
+}
 
 /*
  * Flip the sign of the double value pointed to by 'data' by
  * multiplying -1 to it and putting the result back into the memory
  * location.
  */
-void flipSignDouble(void *data);
-
+void flipSignDouble(void *data){
+    if(data != NULL){
+        double *temp = (double *) data;
+        *temp *= -1;
+    }
+    return;
+}
 /*
  * Compare two double values pointed to by the two pointers.
  * Return 0 if they are the same value, 1 otherwise.
  */
-int compareDouble(const void *data1, const void *data2);
-
+int compareDouble(const void *data1, const void *data2){
+    if(data1 != NULL && data2 != NULL){
+        double *double1 = (double *) data1;
+        double *double2 = (double *) data2;
+        if(*double1 == *double2)
+            return 0;
+        return 1;
+    }
+    return 1;
+}
 /*
  * Returns 1 if the list is empty, 0 otherwise.
- */
+
 static inline int isEmptyList(struct List *list)
 {
     return (list->head == NULL);
 }
 
+*/
+
 /*
  * Remove the first node from the list, deallocate the memory for the
  * node, and return the 'data' pointer that was stored in the node.
  * Returns NULL is the list is empty.
  */
-void *popFront(struct List *list);
+void *popFront(struct List *list){
+    return NULL;
+}
 
 /*
  * Remove all nodes from the list, deallocating the memory for the
  * nodes.  You can implement this function using popFront().
  */
-void removeAllNodes(struct List *list);
+void removeAllNodes(struct List *list){
+    return;
+}
 
 /*
  * Create a node that holds the given data pointer,
@@ -106,8 +147,9 @@ void removeAllNodes(struct List *list);
  *
  * It returns the newly created node on success and NULL on failure.
  */
-struct Node *addAfter(struct List *list,
-    struct Node *prevNode, void *data);
+struct Node *addAfter(struct List *list, struct Node *prevNode, void *data){
+    return NULL;
+}
 
 /*
  * Reverse the list.
@@ -130,4 +172,7 @@ struct Node *addAfter(struct List *list,
  * And at the end, prv will end up pointing to the first element of
  * the reversed list.  Don't forget to assign it to list->head.
  */
-void reverseList(struct List *list);
+void reverseList(struct List *list){
+    return;
+}
+
-- 
2.34.1


From e7ab2172be76ce534d492a613bbab1d6d3816c30 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 19:39:08 -0400
Subject: [PATCH 05/10] Completed mylist.c, will look for edge cases now.

---
 part1/mylist.c | 50 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 48 insertions(+), 2 deletions(-)

diff --git a/part1/mylist.c b/part1/mylist.c
index 0045ef5..7b3ab44 100644
--- a/part1/mylist.c
+++ b/part1/mylist.c
@@ -121,7 +121,18 @@ static inline int isEmptyList(struct List *list)
  * Returns NULL is the list is empty.
  */
 void *popFront(struct List *list){
-    return NULL;
+    if(isEmptyList(list))
+        return NULL;
+    struct Node *n = list->head;
+    void *data = n->data;
+    if(n->next == NULL){
+        free(n);
+        list->head = NULL;
+    }else{
+        list->head = n->next;
+        free(n);
+    }
+    return data;
 }
 
 /*
@@ -129,6 +140,7 @@ void *popFront(struct List *list){
  * nodes.  You can implement this function using popFront().
  */
 void removeAllNodes(struct List *list){
+    while(popFront(list) != NULL);
     return;
 }
 
@@ -148,7 +160,29 @@ void removeAllNodes(struct List *list){
  * It returns the newly created node on success and NULL on failure.
  */
 struct Node *addAfter(struct List *list, struct Node *prevNode, void *data){
-    return NULL;
+   if(prevNode == NULL)
+       return addFront(list, data);
+   
+   if(isEmptyList(list))
+       return NULL;
+
+   struct Node *n = malloc(sizeof(struct Node));
+       if(n == NULL){
+           //perror("malloc returned NULL");
+           return NULL;
+       }
+   n->data = data;
+
+   struct Node * compNode = list->head;
+   while(compNode != NULL){
+       if(compNode == prevNode){
+           n->next = compNode->next;
+           compNode->next = n;
+           return n;
+       }
+       compNode = compNode->next;
+   }
+   return NULL;
 }
 
 /*
@@ -173,6 +207,18 @@ struct Node *addAfter(struct List *list, struct Node *prevNode, void *data){
  * the reversed list.  Don't forget to assign it to list->head.
  */
 void reverseList(struct List *list){
+    struct Node *prv = NULL;
+    struct Node *cur = list->head;
+    struct Node *nxt;
+
+    while(cur){
+        nxt = cur->next;
+        cur->next = prv;
+        prv = cur;
+        cur = nxt;
+    }
+
+    list->head = prv;
     return;
 }
 
-- 
2.34.1


From 5176d0bc0a49e81f5b57bbfd0866dc8ff7335a87 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 20:33:49 -0400
Subject: [PATCH 06/10] Made small changes in mylist.c to make it simpler.

---
 part1/mylist.c | 59 ++++++++++++++++++++------------------------------
 1 file changed, 23 insertions(+), 36 deletions(-)

diff --git a/part1/mylist.c b/part1/mylist.c
index 7b3ab44..b2f0691 100644
--- a/part1/mylist.c
+++ b/part1/mylist.c
@@ -40,10 +40,8 @@ static inline void initList(struct List *list)
  */
 struct Node *addFront(struct List *list, void *data){
     struct Node *n = malloc(sizeof(struct Node));
-    if(n == NULL){    
-        //perror("malloc returned NULL");
+    if(n == NULL)  
         return NULL;
-    }    
     n->data = data;
     n->next = list->head;
     list->head = n;
@@ -85,36 +83,32 @@ struct Node *findNode(struct List *list, const void *dataSought, int (*compar)(c
  * location.
  */
 void flipSignDouble(void *data){
-    if(data != NULL){
-        double *temp = (double *) data;
-        *temp *= -1;
-    }
+    if(data == NULL)
+        return;
+
+    double *temp = (double *) data;
+    *temp *= -1;   
     return;
 }
+
 /*
  * Compare two double values pointed to by the two pointers.
  * Return 0 if they are the same value, 1 otherwise.
  */
 int compareDouble(const void *data1, const void *data2){
-    if(data1 != NULL && data2 != NULL){
-        double *double1 = (double *) data1;
-        double *double2 = (double *) data2;
-        if(*double1 == *double2)
-            return 0;
+    if(data1 == NULL || data2 == NULL)
         return 1;
-    }
-    return 1;
-}
-/*
- * Returns 1 if the list is empty, 0 otherwise.
 
-static inline int isEmptyList(struct List *list)
-{
-    return (list->head == NULL);
+    double *double1 = (double *) data1; 
+    double *double2 = (double *) data2;
+   
+    if(*double1 == *double2)
+        return 0;
+    
+    return 1;
+    
 }
 
-*/
-
 /*
  * Remove the first node from the list, deallocate the memory for the
  * node, and return the 'data' pointer that was stored in the node.
@@ -125,13 +119,9 @@ void *popFront(struct List *list){
         return NULL;
     struct Node *n = list->head;
     void *data = n->data;
-    if(n->next == NULL){
-        free(n);
-        list->head = NULL;
-    }else{
-        list->head = n->next;
-        free(n);
-    }
+    list->head = n->next;
+    free(n);
+   
     return data;
 }
 
@@ -162,15 +152,11 @@ void removeAllNodes(struct List *list){
 struct Node *addAfter(struct List *list, struct Node *prevNode, void *data){
    if(prevNode == NULL)
        return addFront(list, data);
-   
-   if(isEmptyList(list))
-       return NULL;
 
    struct Node *n = malloc(sizeof(struct Node));
-       if(n == NULL){
-           //perror("malloc returned NULL");
-           return NULL;
-       }
+   if(n == NULL)
+       return NULL;
+
    n->data = data;
 
    struct Node * compNode = list->head;
@@ -182,6 +168,7 @@ struct Node *addAfter(struct List *list, struct Node *prevNode, void *data){
        }
        compNode = compNode->next;
    }
+ 
    return NULL;
 }
 
-- 
2.34.1


From 27c0466fc8edcd05f35b9b2018871d14428cb52f Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 20:36:40 -0400
Subject: [PATCH 07/10] Inserted the Valgrind output for part1.

---
 README.txt | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/README.txt b/README.txt
index a61f6c4..d8d50aa 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,40 @@ The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==64906== Memcheck, a memory error detector
+==64906== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==64906== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==64906== Command: ./mylist-test
+==64906== 
+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 
+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 
+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 
+testing findNode(): OK
+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]
+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 ]
+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]
+popped 3.0, the rest is: [ 2.0 1.0 ]
+popped 2.0, the rest is: [ 1.0 ]
+popped 1.0, the rest is: [ ]
+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 
+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]
+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]
+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]
+popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]
+popped 3.0, and reversed the rest: [ 7.0 6.0 5.0 4.0 ]
+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]
+popped 4.0, and reversed the rest: [ 6.0 5.0 ]
+popped 6.0, and reversed the rest: [ 5.0 ]
+popped 5.0, and reversed the rest: [ ]
+==64906== 
+==64906== HEAP SUMMARY:
+==64906==     in use at exit: 0 bytes in 0 blocks
+==64906==   total heap usage: 19 allocs, 19 frees, 1,312 bytes allocated
+==64906== 
+==64906== All heap blocks were freed -- no leaks are possible
+==64906== 
+==64906== For lists of detected and suppressed errors, rerun with: -s
+==64906== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
-- 
2.34.1


From 28e70b1913240db20e5bb6a62eebc28acea2bfd7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 22:01:04 -0400
Subject: [PATCH 08/10] Started doing the second part. Wrote Makefile.

---
 part1/Makefile  |  18 +++---
 part2/Makefile  |  34 ++++++++++
 part2/revecho.c | 162 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 203 insertions(+), 11 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/revecho.c

diff --git a/part1/Makefile b/part1/Makefile
index 4541332..595d308 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -20,15 +20,15 @@ ARFLAGS += -U
 # We can link archive files directly with object files; the linker command
 # produced by the Make implicit rule will look something like:
 #
-#   gcc  numbers-test.o  libnumbers.a  -o numbers-test
+#   gcc  mylist-test.o  libmylist.a  -o mylist-test
 #
 mylist-test: mylist-test.o libmylist.a
 
-# This is the rule for building the libnumbers.a archive file.  This rule says
-# that the libnumbers.a archive file should contain two object files---prime.o
-# and power.o---and should be updated whenever prime.o or power.o are updated.
+# This is the rule for building the libmylist.a archive file.  This rule says
+# that the libmylist.a archive file should contain one object file---mylist.o
+#---and should be updated whenever mylist.o is updated.
 #
-# We rely on Make's implicit rules to update libnumbers.a when necessary.  The
+# We rely on Make's implicit rules to update libmylist.a when necessary.  The
 # template recipe for the implicit rule looks something like this:
 #
 #   $(AR)  $(ARFLAGS)  <archive-file.a>  <member-object-file.o>
@@ -36,13 +36,9 @@ mylist-test: mylist-test.o libmylist.a
 # Our archive rule will lead to a recipe for each of the member object files,
 # which will turn out to be:
 #
-#   ar  rv -U  libnumbers.a  prime.o
+#   ar  rv -U  libmylist.a mylist.o
 #
-# And:
-#
-#   ar  rv -U  libnumbers.a  power.o
-#
-# The "r" flag tells ar to add power.o (or prime.o) to libnumbers.a with
+# The "r" flag tells ar to add mylist.o to libmylist.a with
 # (r)eplacement (i.e., add it, and replace it if already present).
 #
 # The "v" flag tells ar to be verbose, i.e., output information about what it's
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..9813f63
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,34 @@
+# As usual, we define the C compiler we would like to use:
+CC = gcc
+
+# In addition to the usual C compilation flags, we also write -I../part1 to tell
+# the C compiler to look in ../part1 for header files.  This is what allows us to
+# #include <mylist.h>.
+CFLAGS = -g -Wall -Wpedantic -std=c17 -I../part1
+
+# We pass the -L../part1 flag to the linker to tell it to look in ../part1 for
+# library archive files.  This is what allows us to use -lmylist.
+LDFLAGS = -L../part1
+
+# We also give the linker the -lmylist flag to tell it to look in libmylist.a
+# for missing symbol definitions.
+LDLIBS = -lmylist
+
+# Note that there are two separate Make variables used to configure the linker:
+# LDFLAGS and LDLIBS.  This is because for historical reasons, LDFLAGS needs to
+# be appear before object files, whereas LDLIBS needs to appear afterwards.
+# The implicit rule for linking looks like this:
+#
+#     $(CC)  $(LDFLAGS)  <objects>  -o <output-name>  $(LDLIBS)
+#
+# So, with the above variables, the linking command that is run will be:
+#
+#     gcc  -L../part1  revecho.o  -o revecho  -lmylist
+#
+revecho: revecho.o
+
+revecho.o: revecho.c
+
+.PHONY: clean
+clean:
+	rm -rf revecho *.o a.out
diff --git a/part2/revecho.c b/part2/revecho.c
new file mode 100644
index 0000000..85ac9d2
--- /dev/null
+++ b/part2/revecho.c
@@ -0,0 +1,162 @@
+#include <stdlib.h> 
+#include <stdio.h>
+#include <string.h>
+#include <mylist.h>
+
+static void print(void * str){
+    printf("%s\n",(char *) str);
+    return;
+}
+
+int main(int argc, char **argv){
+    struct List list;
+    initList(&list);
+    argv++;
+    
+    while(*argv != NULL){
+        addFront(&list, *argv);
+        argv++;
+    }
+    
+    traverseList(&list, &print);
+   
+    if(findNode(&list, "dude", int (*compar)(const void *, const void *)) == NULL){
+        printf("\ndude not found");
+    }else{
+        printf("\ndude found");
+    }
+   
+    return 0;
+}
+
+/*
+
+ * A node in a linked list.
+ 
+struct Node {
+    void *data;
+    struct Node *next;
+};
+
+
+ * A linked list.
+ * 'head' points to the first node in the list, or is NULL if empty.
+
+struct List {
+    struct Node *head;
+};
+
+
+ * Initialize an empty list.
+ 
+static inline void initList(struct List *list)
+{
+    list->head = NULL;
+}
+
+
+ * In all functions below, the 'list' parameter is assumed to point to
+ * a valid struct List.
+
+
+
+ * Create a node that holds the given data pointer,
+ * and add the node to the front of the list.
+ *
+ * Note that this function does not manage the lifetime of the object
+ * pointed to by 'data'.
+ *
+ * It returns the newly created node on success and NULL on failure.
+ 
+struct Node *addFront(struct List *list, void *data);
+
+
+ * Traverse the list, calling f() with each data item.
+ 
+void traverseList(struct List *list, void (*f)(void *));
+
+
+ * Traverse the list, comparing each data item with 'dataSought' using
+ * 'compar' function.  ('compar' returns 0 if the data pointed to by
+ * the two parameters are equal, non-zero value otherwise.)
+ *
+ * Returns the first node containing the matching data,
+ * NULL if not found.
+
+struct Node *findNode(struct List *list, const void *dataSought,
+    int (*compar)(const void *, const void *));
+
+
+ * Flip the sign of the double value pointed to by 'data' by
+ * multiplying -1 to it and putting the result back into the memory
+ * location.
+ 
+void flipSignDouble(void *data);
+
+ * Compare two double values pointed to by the two pointers.
+ * Return 0 if they are the same value, 1 otherwise.
+ 
+int compareDouble(const void *data1, const void *data2);
+
+
+ * Returns 1 if the list is empty, 0 otherwise.
+ 
+static inline int isEmptyList(struct List *list)
+{
+    return (list->head == NULL);
+}
+
+
+ * Remove the first node from the list, deallocate the memory for the
+ * node, and return the 'data' pointer that was stored in the node.
+ * Returns NULL is the list is empty.
+ 
+void *popFront(struct List *list);
+
+
+ * Remove all nodes from the list, deallocating the memory for the
+ * nodes.  You can implement this function using popFront().
+ 
+void removeAllNodes(struct List *list);
+
+
+ * Create a node that holds the given data pointer,
+ * and add the node right after the node passed in as the 'prevNode'
+ * parameter.  If 'prevNode' is NULL, this function is equivalent to
+ * addFront().
+ *
+ * Note that prevNode, if not NULL, is assumed to be one of the nodes
+ * in the given list.  The behavior of this function is undefined if
+ * prevNode does not belong in the given list.
+ *
+ * Note that this function does not manage the lifetime of the object
+ * pointed to by 'data'.
+ *
+ * It returns the newly created node on success and NULL on failure.
+ 
+struct Node *addAfter(struct List *list,
+    struct Node *prevNode, void *data);
+
+
+ * Reverse the list.
+ *
+ * Note that this function reverses the list purely by manipulating
+ * pointers.  It does NOT call malloc() directly or indirectly (which
+ * means that it does not call addFront() or addAfter()).
+ *
+ * Implementation hint: keep track of 3 consecutive nodes (previous,
+ * current, next) and move them along in a while loop.  Your function
+ * should start like this:
+ *
+ *    struct Node *prv = NULL;
+ *    struct Node *cur = list->head;
+ *    struct Node *nxt;
+ *
+ *    while (cur)
+ *        ...
+ *
+ * And at the end, prv will end up pointing to the first element of
+ * the reversed list.  Don't forget to assign it to list->head.
+
+void reverseList(struct List *list);
+ */
-- 
2.34.1


From 209913fc6ca0396b80250825e088c292c838a1a1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 23:52:50 -0400
Subject: [PATCH 09/10] Made minor changes to Makefiles and deleted some of my
 own comments.

---
 README.txt      |   2 +
 part1/Makefile  |  11 ++--
 part2/revecho.c | 142 ++----------------------------------------------
 3 files changed, 14 insertions(+), 141 deletions(-)

diff --git a/README.txt b/README.txt
index d8d50aa..0f11050 100644
--- a/README.txt
+++ b/README.txt
@@ -46,3 +46,5 @@ popped 5.0, and reversed the rest: [ ]
 ==64906== 
 ==64906== For lists of detected and suppressed errors, rerun with: -s
 ==64906== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+valgrind: Unknown option: --leack-check=yes
+valgrind: Use --help for more information or consult the user manual.
diff --git a/part1/Makefile b/part1/Makefile
index 595d308..a8fe598 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -56,9 +56,10 @@ mylist-test.o: mylist-test.c mylist.h
 # any archive files built here.
 .PHONY: clean
 clean:
-	rm -rf mylist-test actualoutput.txt *.o *.a a.out
+	rm -rf mylist-test *.o *.a a.out
 
-.PHONY: compare
-compare: 
-	./mylist-test > actualoutput.txt
-	diff actualoutput.txt mylist-test-output.txt
+
+#.PHONY: compare
+#compare: 
+#	./mylist-test > actualoutput.txt
+#	diff actualoutput.txt mylist-test-output.txt
diff --git a/part2/revecho.c b/part2/revecho.c
index 85ac9d2..fdaba8f 100644
--- a/part2/revecho.c
+++ b/part2/revecho.c
@@ -20,143 +20,13 @@ int main(int argc, char **argv){
     
     traverseList(&list, &print);
    
-    if(findNode(&list, "dude", int (*compar)(const void *, const void *)) == NULL){
-        printf("\ndude not found");
+    if(findNode(&list, "dude",(int (*)(const void *, const void *)) &strcmp) == NULL){
+        printf("\ndude not found\n");
     }else{
-        printf("\ndude found");
+        printf("\ndude found\n");
     }
-   
-    return 0;
-}
-
-/*
-
- * A node in a linked list.
- 
-struct Node {
-    void *data;
-    struct Node *next;
-};
-
-
- * A linked list.
- * 'head' points to the first node in the list, or is NULL if empty.
-
-struct List {
-    struct Node *head;
-};
-
-
- * Initialize an empty list.
- 
-static inline void initList(struct List *list)
-{
-    list->head = NULL;
-}
-
-
- * In all functions below, the 'list' parameter is assumed to point to
- * a valid struct List.
-
-
-
- * Create a node that holds the given data pointer,
- * and add the node to the front of the list.
- *
- * Note that this function does not manage the lifetime of the object
- * pointed to by 'data'.
- *
- * It returns the newly created node on success and NULL on failure.
- 
-struct Node *addFront(struct List *list, void *data);
-
-
- * Traverse the list, calling f() with each data item.
- 
-void traverseList(struct List *list, void (*f)(void *));
-
-
- * Traverse the list, comparing each data item with 'dataSought' using
- * 'compar' function.  ('compar' returns 0 if the data pointed to by
- * the two parameters are equal, non-zero value otherwise.)
- *
- * Returns the first node containing the matching data,
- * NULL if not found.
-
-struct Node *findNode(struct List *list, const void *dataSought,
-    int (*compar)(const void *, const void *));
-
-
- * Flip the sign of the double value pointed to by 'data' by
- * multiplying -1 to it and putting the result back into the memory
- * location.
- 
-void flipSignDouble(void *data);
-
- * Compare two double values pointed to by the two pointers.
- * Return 0 if they are the same value, 1 otherwise.
- 
-int compareDouble(const void *data1, const void *data2);
-
+    
+    removeAllNodes(&list);
 
- * Returns 1 if the list is empty, 0 otherwise.
- 
-static inline int isEmptyList(struct List *list)
-{
-    return (list->head == NULL);
+    return 0;
 }
-
-
- * Remove the first node from the list, deallocate the memory for the
- * node, and return the 'data' pointer that was stored in the node.
- * Returns NULL is the list is empty.
- 
-void *popFront(struct List *list);
-
-
- * Remove all nodes from the list, deallocating the memory for the
- * nodes.  You can implement this function using popFront().
- 
-void removeAllNodes(struct List *list);
-
-
- * Create a node that holds the given data pointer,
- * and add the node right after the node passed in as the 'prevNode'
- * parameter.  If 'prevNode' is NULL, this function is equivalent to
- * addFront().
- *
- * Note that prevNode, if not NULL, is assumed to be one of the nodes
- * in the given list.  The behavior of this function is undefined if
- * prevNode does not belong in the given list.
- *
- * Note that this function does not manage the lifetime of the object
- * pointed to by 'data'.
- *
- * It returns the newly created node on success and NULL on failure.
- 
-struct Node *addAfter(struct List *list,
-    struct Node *prevNode, void *data);
-
-
- * Reverse the list.
- *
- * Note that this function reverses the list purely by manipulating
- * pointers.  It does NOT call malloc() directly or indirectly (which
- * means that it does not call addFront() or addAfter()).
- *
- * Implementation hint: keep track of 3 consecutive nodes (previous,
- * current, next) and move them along in a while loop.  Your function
- * should start like this:
- *
- *    struct Node *prv = NULL;
- *    struct Node *cur = list->head;
- *    struct Node *nxt;
- *
- *    while (cur)
- *        ...
- *
- * And at the end, prv will end up pointing to the first element of
- * the reversed list.  Don't forget to assign it to list->head.
-
-void reverseList(struct List *list);
- */
-- 
2.34.1


From 661ec75e4ad761122754c3a7fa3f27cba191f8f0 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 16 Oct 2022 23:58:28 -0400
Subject: [PATCH 10/10] final commit

---
 README.txt | 24 +++++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)

diff --git a/README.txt b/README.txt
index 0f11050..713b36b 100644
--- a/README.txt
+++ b/README.txt
@@ -3,7 +3,7 @@ This file should contain:
   - Arman Ozcan
   - ao2794
   - lab 3
-  -  
+  - My program should work as it should. 
   
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
@@ -46,5 +46,23 @@ popped 5.0, and reversed the rest: [ ]
 ==64906== 
 ==64906== For lists of detected and suppressed errors, rerun with: -s
 ==64906== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
-valgrind: Unknown option: --leack-check=yes
-valgrind: Use --help for more information or consult the user manual.
+==243798== Memcheck, a memory error detector
+==243798== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==243798== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==243798== Command: ./revecho arman is a dude
+==243798== 
+dude
+a
+is
+arman
+
+dude found
+==243798== 
+==243798== HEAP SUMMARY:
+==243798==     in use at exit: 0 bytes in 0 blocks
+==243798==   total heap usage: 5 allocs, 5 frees, 2,624 bytes allocated
+==243798== 
+==243798== All heap blocks were freed -- no leaks are possible
+==243798== 
+==243798== For lists of detected and suppressed errors, rerun with: -s
+==243798== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
-- 
2.34.1


--5uDsrq7Iv/ojqvOG
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab3.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 5c52afd50c37f1c364f1c5b1c14db8a4d209fa9e Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 15 Oct 2022 17:07:14=
 -0400=0ASubject: [PATCH 01/10] Wrote some in README.txt.=0A=0A---=0A READM=
E.txt | 8 ++++----=0A 1 file changed, 4 insertions(+), 4 deletions(-)=0A=0A=
diff --git a/README.txt b/README.txt=0Aindex 66dfd3e..a61f6c4 100644=0A--- =
a/README.txt=0A+++ b/README.txt=0A@@ -1,9 +1,9 @@=0A This file should conta=
in:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment number=0A-  =
- description for each part=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab 3=
=0A+  -  =0A   =0A The description should indicate whether your solution fo=
r the part is=0A working or not.  You may also want to include anything els=
e you would=0A-- =0A2.34.1=0A=0A=0AFrom 5e4a259ee602df0a378bf67c18e490aafbe=
5b401 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0A=
Date: Sat, 15 Oct 2022 17:53:51 -0400=0ASubject: [PATCH 02/10] Started myli=
st.c.=0A=0A---=0A part1/mylist.c | 133 ++++++++++++++++++++++++++++++++++++=
+++++++++++++=0A 1 file changed, 133 insertions(+)=0A create mode 100644 pa=
rt1/mylist.c=0A=0Adiff --git a/part1/mylist.c b/part1/mylist.c=0Anew file m=
ode 100644=0Aindex 0000000..2aa4c48=0A--- /dev/null=0A+++ b/part1/mylist.c=
=0A@@ -0,0 +1,133 @@=0A+#include <stdlib.h>=0A+#include "mylist.h"=0A+=0A+/=
*=0A+ * A node in a linked list.=0A+ */=0A+struct Node {=0A+    void *data;=
=0A+    struct Node *next;=0A+};=0A+=0A+/*=0A+ * A linked list.=0A+ * 'head=
' points to the first node in the list, or is NULL if empty.=0A+ */=0A+stru=
ct List {=0A+    struct Node *head;=0A+};=0A+=0A+/*=0A+ * Initialize an emp=
ty list.=0A+ */=0A+static inline void initList(struct List *list)=0A+{=0A+ =
   list->head =3D NULL;=0A+}=0A+=0A+/*=0A+ * In all functions below, the 'l=
ist' parameter is assumed to point to=0A+ * a valid struct List.=0A+ */=0A+=
=0A+/*=0A+ * Create a node that holds the given data pointer,=0A+ * and add=
 the node to the front of the list.=0A+ *=0A+ * Note that this function doe=
s not manage the lifetime of the object=0A+ * pointed to by 'data'.=0A+ *=
=0A+ * It returns the newly created node on success and NULL on failure.=0A=
+ */=0A+struct Node *addFront(struct List *list, void *data);=0A+=0A+/*=0A+=
 * Traverse the list, calling f() with each data item.=0A+ */=0A+void trave=
rseList(struct List *list, void (*f)(void *));=0A+=0A+/*=0A+ * Traverse the=
 list, comparing each data item with 'dataSought' using=0A+ * 'compar' func=
tion.  ('compar' returns 0 if the data pointed to by=0A+ * the two paramete=
rs are equal, non-zero value otherwise.)=0A+ *=0A+ * Returns the first node=
 containing the matching data,=0A+ * NULL if not found.=0A+ */=0A+struct No=
de *findNode(struct List *list, const void *dataSought,=0A+    int (*compar=
)(const void *, const void *));=0A+=0A+/*=0A+ * Flip the sign of the double=
 value pointed to by 'data' by=0A+ * multiplying -1 to it and putting the r=
esult back into the memory=0A+ * location.=0A+ */=0A+void flipSignDouble(vo=
id *data);=0A+=0A+/*=0A+ * Compare two double values pointed to by the two =
pointers.=0A+ * Return 0 if they are the same value, 1 otherwise.=0A+ */=0A=
+int compareDouble(const void *data1, const void *data2);=0A+=0A+/*=0A+ * R=
eturns 1 if the list is empty, 0 otherwise.=0A+ */=0A+static inline int isE=
mptyList(struct List *list)=0A+{=0A+    return (list->head =3D=3D NULL);=0A=
+}=0A+=0A+/*=0A+ * Remove the first node from the list, deallocate the memo=
ry for the=0A+ * node, and return the 'data' pointer that was stored in the=
 node.=0A+ * Returns NULL is the list is empty.=0A+ */=0A+void *popFront(st=
ruct List *list);=0A+=0A+/*=0A+ * Remove all nodes from the list, deallocat=
ing the memory for the=0A+ * nodes.  You can implement this function using =
popFront().=0A+ */=0A+void removeAllNodes(struct List *list);=0A+=0A+/*=0A+=
 * Create a node that holds the given data pointer,=0A+ * and add the node =
right after the node passed in as the 'prevNode'=0A+ * parameter.  If 'prev=
Node' is NULL, this function is equivalent to=0A+ * addFront().=0A+ *=0A+ *=
 Note that prevNode, if not NULL, is assumed to be one of the nodes=0A+ * i=
n the given list.  The behavior of this function is undefined if=0A+ * prev=
Node does not belong in the given list.=0A+ *=0A+ * Note that this function=
 does not manage the lifetime of the object=0A+ * pointed to by 'data'.=0A+=
 *=0A+ * It returns the newly created node on success and NULL on failure.=
=0A+ */=0A+struct Node *addAfter(struct List *list,=0A+    struct Node *pre=
vNode, void *data);=0A+=0A+/*=0A+ * Reverse the list.=0A+ *=0A+ * Note that=
 this function reverses the list purely by manipulating=0A+ * pointers.  It=
 does NOT call malloc() directly or indirectly (which=0A+ * means that it d=
oes not call addFront() or addAfter()).=0A+ *=0A+ * Implementation hint: ke=
ep track of 3 consecutive nodes (previous,=0A+ * current, next) and move th=
em along in a while loop.  Your function=0A+ * should start like this:=0A+ =
*=0A+ *    struct Node *prv =3D NULL;=0A+ *    struct Node *cur =3D list->h=
ead;=0A+ *    struct Node *nxt;=0A+ *=0A+ *    while (cur)=0A+ *        ...=
=0A+ *=0A+ * And at the end, prv will end up pointing to the first element =
of=0A+ * the reversed list.  Don't forget to assign it to list->head.=0A+ *=
/=0A+void reverseList(struct List *list);=0A-- =0A2.34.1=0A=0A=0AFrom 9ece4=
4912c9ae2c57575f4ee04703705d7beab42 Mon Sep 17 00:00:00 2001=0AFrom: Arman =
Ozcan <ao2794@columbia.edu>=0ADate: Sat, 15 Oct 2022 18:21:57 -0400=0ASubje=
ct: [PATCH 03/10] Started writing the Makefile.=0A=0A---=0A part1/Makefile =
| 63 ++++++++++++++++++++++++++++++++++++++++++++++++++=0A 1 file changed, =
63 insertions(+)=0A create mode 100644 part1/Makefile=0A=0Adiff --git a/par=
t1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 0000000..cf80b4=
c=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,63 @@=0A+# Same C com=
piler and compiler flags as before:=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -W=
pedantic -std=3Dc17=0A+=0A+# No linker flags, though these will later come =
in handy for the library user.=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+# We wil=
l use the ar utility to create archive files from object files, so it's=0A+=
# good practice to explicitly specify the "ar" command we would like to use=
:=0A+AR =3D ar=0A+=0A+# We can use the ARFLAGS variable to pass flags to th=
e ar program.  For reasons=0A+# beyond our control and beyond the scope of =
this course, we need to add the -U=0A+# flag to ensure that Make doesn't tr=
y to rebuild the library archive when it=0A+# doesn't need to.  You can rea=
d more about why we need the -U flag here:=0A+# https://stackoverflow.com/a=
/73912307/10497710.=0A+ARFLAGS +=3D -U=0A+=0A+# We can link archive files d=
irectly with object files; the linker command=0A+# produced by the Make imp=
licit rule will look something like:=0A+#=0A+#   gcc  numbers-test.o  libnu=
mbers.a  -o numbers-test=0A+#=0A+mylist-test: mylist-test.o libmylist.a=0A+=
=0A+# This is the rule for building the libnumbers.a archive file.  This ru=
le says=0A+# that the libnumbers.a archive file should contain two object f=
iles---prime.o=0A+# and power.o---and should be updated whenever prime.o or=
 power.o are updated.=0A+#=0A+# We rely on Make's implicit rules to update =
libnumbers.a when necessary.  The=0A+# template recipe for the implicit rul=
e looks something like this:=0A+#=0A+#   $(AR)  $(ARFLAGS)  <archive-file.a=
>  <member-object-file.o>=0A+#=0A+# Our archive rule will lead to a recipe =
for each of the member object files,=0A+# which will turn out to be:=0A+#=
=0A+#   ar  rv -U  libnumbers.a  prime.o=0A+#=0A+# And:=0A+#=0A+#   ar  rv =
-U  libnumbers.a  power.o=0A+#=0A+# The "r" flag tells ar to add power.o (o=
r prime.o) to libnumbers.a with=0A+# (r)eplacement (i.e., add it, and repla=
ce it if already present).=0A+#=0A+# The "v" flag tells ar to be verbose, i=
=2Ee., output information about what it's=0A+# doing.=0A+#=0A+# The "-U" fl=
ag tells ar to preseve timestamps for archive members; this is=0A+# necessa=
ry so that Make doesn't try to replace archive members unnecessarily.=0A+li=
bmylist.a: libmylist.a(mylist.o)=0A+=0A+# We use implicit rules to deal wit=
h object files, like before:=0A+mylist.o: mylist.c mylist.h=0A+mylist-test.=
o: mylist-test.c mylist.h=0A+=0A+# The usual .PHONY target for cleaning up =
the build directory; we also delete=0A+# any archive files built here.=0A+.=
PHONY: clean=0A+clean:=0A+	rm -rf mylist-test *.o *.a a.out=0A-- =0A2.34.1=
=0A=0A=0AFrom e1056b273b9bf59110736aafa84f619666095a22 Mon Sep 17 00:00:00 =
2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 16 Oct 2022 18:=
22:38 -0400=0ASubject: [PATCH 04/10] I wrote the methods until findNode.=0A=
=0A---=0A part1/Makefile |  7 ++++-=0A part1/mylist.c | 85 ++++++++++++++++=
++++++++++++++++++++++------------=0A 2 files changed, 71 insertions(+), 21=
 deletions(-)=0A=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex cf8=
0b4c..4541332 100644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -60=
,4 +60,9 @@ mylist-test.o: mylist-test.c mylist.h=0A # any archive files bu=
ilt here.=0A .PHONY: clean=0A clean:=0A-	rm -rf mylist-test *.o *.a a.out=
=0A+	rm -rf mylist-test actualoutput.txt *.o *.a a.out=0A+=0A+.PHONY: compa=
re=0A+compare: =0A+	./mylist-test > actualoutput.txt=0A+	diff actualoutput.=
txt mylist-test-output.txt=0Adiff --git a/part1/mylist.c b/part1/mylist.c=
=0Aindex 2aa4c48..0045ef5 100644=0A--- a/part1/mylist.c=0A+++ b/part1/mylis=
t.c=0A@@ -3,29 +3,28 @@=0A =0A /*=0A  * A node in a linked list.=0A- */=0A+=
=0A struct Node {=0A     void *data;=0A     struct Node *next;=0A };=0A =0A=
-/*=0A+=0A  * A linked list.=0A  * 'head' points to the first node in the l=
ist, or is NULL if empty.=0A- */=0A+=0A struct List {=0A     struct Node *h=
ead;=0A };=0A =0A-/*=0A  * Initialize an empty list.=0A- */=0A+=0A static i=
nline void initList(struct List *list)=0A {=0A     list->head =3D NULL;=0A =
}=0A =0A-/*=0A+=0A  * In all functions below, the 'list' parameter is assum=
ed to point to=0A  * a valid struct List.=0A  */=0A@@ -39,12 +38,28 @@ stat=
ic inline void initList(struct List *list)=0A  *=0A  * It returns the newly=
 created node on success and NULL on failure.=0A  */=0A-struct Node *addFro=
nt(struct List *list, void *data);=0A+struct Node *addFront(struct List *li=
st, void *data){=0A+    struct Node *n =3D malloc(sizeof(struct Node));=0A+=
    if(n =3D=3D NULL){    =0A+        //perror("malloc returned NULL");=0A+=
        return NULL;=0A+    }    =0A+    n->data =3D data;=0A+    n->next =
=3D list->head;=0A+    list->head =3D n;=0A+    return n;=0A+}=0A =0A /*=0A=
  * Traverse the list, calling f() with each data item.=0A  */=0A-void trav=
erseList(struct List *list, void (*f)(void *));=0A+void traverseList(struct=
 List *list, void (*f)(void *)){=0A+    struct Node *n =3D list->head;=0A+ =
   while(n !=3D NULL){=0A+        (*f)(n->data);=0A+        n =3D n->next;=
=0A+    }=0A+}=0A =0A /*=0A  * Traverse the list, comparing each data item =
with 'dataSought' using=0A@@ -54,42 +69,68 @@ void traverseList(struct List=
 *list, void (*f)(void *));=0A  * Returns the first node containing the mat=
ching data,=0A  * NULL if not found.=0A  */=0A-struct Node *findNode(struct=
 List *list, const void *dataSought,=0A-    int (*compar)(const void *, con=
st void *));=0A+struct Node *findNode(struct List *list, const void *dataSo=
ught, int (*compar)(const void *, const void *)){=0A+    struct Node *n =3D=
 list->head;=0A+    while(n !=3D NULL){=0A+        if(!(*compar)(dataSought=
,n->data))=0A+            return n;=0A+        n =3D n->next;=0A+    }=0A+ =
   return NULL;=0A+}=0A =0A /*=0A  * Flip the sign of the double value poin=
ted to by 'data' by=0A  * multiplying -1 to it and putting the result back =
into the memory=0A  * location.=0A  */=0A-void flipSignDouble(void *data);=
=0A-=0A+void flipSignDouble(void *data){=0A+    if(data !=3D NULL){=0A+    =
    double *temp =3D (double *) data;=0A+        *temp *=3D -1;=0A+    }=0A=
+    return;=0A+}=0A /*=0A  * Compare two double values pointed to by the t=
wo pointers.=0A  * Return 0 if they are the same value, 1 otherwise.=0A  */=
=0A-int compareDouble(const void *data1, const void *data2);=0A-=0A+int com=
pareDouble(const void *data1, const void *data2){=0A+    if(data1 !=3D NULL=
 && data2 !=3D NULL){=0A+        double *double1 =3D (double *) data1;=0A+ =
       double *double2 =3D (double *) data2;=0A+        if(*double1 =3D=3D =
*double2)=0A+            return 0;=0A+        return 1;=0A+    }=0A+    ret=
urn 1;=0A+}=0A /*=0A  * Returns 1 if the list is empty, 0 otherwise.=0A- */=
=0A+=0A static inline int isEmptyList(struct List *list)=0A {=0A     return=
 (list->head =3D=3D NULL);=0A }=0A =0A+*/=0A+=0A /*=0A  * Remove the first =
node from the list, deallocate the memory for the=0A  * node, and return th=
e 'data' pointer that was stored in the node.=0A  * Returns NULL is the lis=
t is empty.=0A  */=0A-void *popFront(struct List *list);=0A+void *popFront(=
struct List *list){=0A+    return NULL;=0A+}=0A =0A /*=0A  * Remove all nod=
es from the list, deallocating the memory for the=0A  * nodes.  You can imp=
lement this function using popFront().=0A  */=0A-void removeAllNodes(struct=
 List *list);=0A+void removeAllNodes(struct List *list){=0A+    return;=0A+=
}=0A =0A /*=0A  * Create a node that holds the given data pointer,=0A@@ -10=
6,8 +147,9 @@ void removeAllNodes(struct List *list);=0A  *=0A  * It return=
s the newly created node on success and NULL on failure.=0A  */=0A-struct N=
ode *addAfter(struct List *list,=0A-    struct Node *prevNode, void *data);=
=0A+struct Node *addAfter(struct List *list, struct Node *prevNode, void *d=
ata){=0A+    return NULL;=0A+}=0A =0A /*=0A  * Reverse the list.=0A@@ -130,=
4 +172,7 @@ struct Node *addAfter(struct List *list,=0A  * And at the end, =
prv will end up pointing to the first element of=0A  * the reversed list.  =
Don't forget to assign it to list->head.=0A  */=0A-void reverseList(struct =
List *list);=0A+void reverseList(struct List *list){=0A+    return;=0A+}=0A=
+=0A-- =0A2.34.1=0A=0A=0AFrom e7ab2172be76ce534d492a613bbab1d6d3816c30 Mon =
Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun,=
 16 Oct 2022 19:39:08 -0400=0ASubject: [PATCH 05/10] Completed mylist.c, wi=
ll look for edge cases now.=0A=0A---=0A part1/mylist.c | 50 +++++++++++++++=
+++++++++++++++++++++++++++++++++--=0A 1 file changed, 48 insertions(+), 2 =
deletions(-)=0A=0Adiff --git a/part1/mylist.c b/part1/mylist.c=0Aindex 0045=
ef5..7b3ab44 100644=0A--- a/part1/mylist.c=0A+++ b/part1/mylist.c=0A@@ -121=
,7 +121,18 @@ static inline int isEmptyList(struct List *list)=0A  * Return=
s NULL is the list is empty.=0A  */=0A void *popFront(struct List *list){=
=0A-    return NULL;=0A+    if(isEmptyList(list))=0A+        return NULL;=
=0A+    struct Node *n =3D list->head;=0A+    void *data =3D n->data;=0A+  =
  if(n->next =3D=3D NULL){=0A+        free(n);=0A+        list->head =3D NU=
LL;=0A+    }else{=0A+        list->head =3D n->next;=0A+        free(n);=0A=
+    }=0A+    return data;=0A }=0A =0A /*=0A@@ -129,6 +140,7 @@ void *popFr=
ont(struct List *list){=0A  * nodes.  You can implement this function using=
 popFront().=0A  */=0A void removeAllNodes(struct List *list){=0A+    while=
(popFront(list) !=3D NULL);=0A     return;=0A }=0A =0A@@ -148,7 +160,29 @@ =
void removeAllNodes(struct List *list){=0A  * It returns the newly created =
node on success and NULL on failure.=0A  */=0A struct Node *addAfter(struct=
 List *list, struct Node *prevNode, void *data){=0A-    return NULL;=0A+   =
if(prevNode =3D=3D NULL)=0A+       return addFront(list, data);=0A+   =0A+ =
  if(isEmptyList(list))=0A+       return NULL;=0A+=0A+   struct Node *n =3D=
 malloc(sizeof(struct Node));=0A+       if(n =3D=3D NULL){=0A+           //=
perror("malloc returned NULL");=0A+           return NULL;=0A+       }=0A+ =
  n->data =3D data;=0A+=0A+   struct Node * compNode =3D list->head;=0A+   =
while(compNode !=3D NULL){=0A+       if(compNode =3D=3D prevNode){=0A+     =
      n->next =3D compNode->next;=0A+           compNode->next =3D n;=0A+  =
         return n;=0A+       }=0A+       compNode =3D compNode->next;=0A+  =
 }=0A+   return NULL;=0A }=0A =0A /*=0A@@ -173,6 +207,18 @@ struct Node *ad=
dAfter(struct List *list, struct Node *prevNode, void *data){=0A  * the rev=
ersed list.  Don't forget to assign it to list->head.=0A  */=0A void revers=
eList(struct List *list){=0A+    struct Node *prv =3D NULL;=0A+    struct N=
ode *cur =3D list->head;=0A+    struct Node *nxt;=0A+=0A+    while(cur){=0A=
+        nxt =3D cur->next;=0A+        cur->next =3D prv;=0A+        prv =
=3D cur;=0A+        cur =3D nxt;=0A+    }=0A+=0A+    list->head =3D prv;=0A=
     return;=0A }=0A =0A-- =0A2.34.1=0A=0A=0AFrom 5176d0bc0a49e81f5b57bbfd0=
866dc8ff7335a87 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columb=
ia.edu>=0ADate: Sun, 16 Oct 2022 20:33:49 -0400=0ASubject: [PATCH 06/10] Ma=
de small changes in mylist.c to make it simpler.=0A=0A---=0A part1/mylist.c=
 | 59 ++++++++++++++++++++------------------------------=0A 1 file changed,=
 23 insertions(+), 36 deletions(-)=0A=0Adiff --git a/part1/mylist.c b/part1=
/mylist.c=0Aindex 7b3ab44..b2f0691 100644=0A--- a/part1/mylist.c=0A+++ b/pa=
rt1/mylist.c=0A@@ -40,10 +40,8 @@ static inline void initList(struct List *=
list)=0A  */=0A struct Node *addFront(struct List *list, void *data){=0A   =
  struct Node *n =3D malloc(sizeof(struct Node));=0A-    if(n =3D=3D NULL){=
    =0A-        //perror("malloc returned NULL");=0A+    if(n =3D=3D NULL) =
 =0A         return NULL;=0A-    }    =0A     n->data =3D data;=0A     n->n=
ext =3D list->head;=0A     list->head =3D n;=0A@@ -85,36 +83,32 @@ struct N=
ode *findNode(struct List *list, const void *dataSought, int (*compar)(c=0A=
  * location.=0A  */=0A void flipSignDouble(void *data){=0A-    if(data !=
=3D NULL){=0A-        double *temp =3D (double *) data;=0A-        *temp *=
=3D -1;=0A-    }=0A+    if(data =3D=3D NULL)=0A+        return;=0A+=0A+    =
double *temp =3D (double *) data;=0A+    *temp *=3D -1;   =0A     return;=
=0A }=0A+=0A /*=0A  * Compare two double values pointed to by the two point=
ers.=0A  * Return 0 if they are the same value, 1 otherwise.=0A  */=0A int =
compareDouble(const void *data1, const void *data2){=0A-    if(data1 !=3D N=
ULL && data2 !=3D NULL){=0A-        double *double1 =3D (double *) data1;=
=0A-        double *double2 =3D (double *) data2;=0A-        if(*double1 =
=3D=3D *double2)=0A-            return 0;=0A+    if(data1 =3D=3D NULL || da=
ta2 =3D=3D NULL)=0A         return 1;=0A-    }=0A-    return 1;=0A-}=0A-/*=
=0A- * Returns 1 if the list is empty, 0 otherwise.=0A =0A-static inline in=
t isEmptyList(struct List *list)=0A-{=0A-    return (list->head =3D=3D NULL=
);=0A+    double *double1 =3D (double *) data1; =0A+    double *double2 =3D=
 (double *) data2;=0A+   =0A+    if(*double1 =3D=3D *double2)=0A+        re=
turn 0;=0A+    =0A+    return 1;=0A+    =0A }=0A =0A-*/=0A-=0A /*=0A  * Rem=
ove the first node from the list, deallocate the memory for the=0A  * node,=
 and return the 'data' pointer that was stored in the node.=0A@@ -125,13 +1=
19,9 @@ void *popFront(struct List *list){=0A         return NULL;=0A     s=
truct Node *n =3D list->head;=0A     void *data =3D n->data;=0A-    if(n->n=
ext =3D=3D NULL){=0A-        free(n);=0A-        list->head =3D NULL;=0A-  =
  }else{=0A-        list->head =3D n->next;=0A-        free(n);=0A-    }=0A=
+    list->head =3D n->next;=0A+    free(n);=0A+   =0A     return data;=0A =
}=0A =0A@@ -162,15 +152,11 @@ void removeAllNodes(struct List *list){=0A st=
ruct Node *addAfter(struct List *list, struct Node *prevNode, void *data){=
=0A    if(prevNode =3D=3D NULL)=0A        return addFront(list, data);=0A- =
  =0A-   if(isEmptyList(list))=0A-       return NULL;=0A =0A    struct Node=
 *n =3D malloc(sizeof(struct Node));=0A-       if(n =3D=3D NULL){=0A-      =
     //perror("malloc returned NULL");=0A-           return NULL;=0A-      =
 }=0A+   if(n =3D=3D NULL)=0A+       return NULL;=0A+=0A    n->data =3D dat=
a;=0A =0A    struct Node * compNode =3D list->head;=0A@@ -182,6 +168,7 @@ s=
truct Node *addAfter(struct List *list, struct Node *prevNode, void *data){=
=0A        }=0A        compNode =3D compNode->next;=0A    }=0A+ =0A    retu=
rn NULL;=0A }=0A =0A-- =0A2.34.1=0A=0A=0AFrom 27c0466fc8edcd05f35b9b2018871=
d14428cb52f Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.e=
du>=0ADate: Sun, 16 Oct 2022 20:36:40 -0400=0ASubject: [PATCH 07/10] Insert=
ed the Valgrind output for part1.=0A=0A---=0A README.txt | 37 +++++++++++++=
++++++++++++++++++++++++=0A 1 file changed, 37 insertions(+)=0A=0Adiff --gi=
t a/README.txt b/README.txt=0Aindex a61f6c4..d8d50aa 100644=0A--- a/README.=
txt=0A+++ b/README.txt=0A@@ -9,3 +9,40 @@ The description should indicate w=
hether your solution for the part is=0A working or not.  You may also want =
to include anything else you would=0A like to communicate to the grader suc=
h as extra functionalities you=0A implemented or how you tried to fix your =
non-working code.=0A+=3D=3D64906=3D=3D Memcheck, a memory error detector=0A=
+=3D=3D64906=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward=
 et al.=0A+=3D=3D64906=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -=
h for copyright info=0A+=3D=3D64906=3D=3D Command: ./mylist-test=0A+=3D=3D6=
4906=3D=3D =0A+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 =0A+=
testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0 =0A+=
testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 =0A+tes=
ting findNode(): OK=0A+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2=
=2E0 1.0 ]=0A+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+p=
opped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 6.0, the rest=
 is: [ 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 =
]=0A+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]=0A+popped 3.0, the rest is: [=
 2.0 1.0 ]=0A+popped 2.0, the rest is: [ 1.0 ]=0A+popped 1.0, the rest is: =
[ ]=0A+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 =0A+popped 1=
=2E0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]=0A+popped =
9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]=0A+popped 2.0, =
and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]=0A+popped 8.0, and rever=
sed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]=0A+popped 3.0, and reversed the rest:=
 [ 7.0 6.0 5.0 4.0 ]=0A+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]=
=0A+popped 4.0, and reversed the rest: [ 6.0 5.0 ]=0A+popped 6.0, and rever=
sed the rest: [ 5.0 ]=0A+popped 5.0, and reversed the rest: [ ]=0A+=3D=3D64=
906=3D=3D =0A+=3D=3D64906=3D=3D HEAP SUMMARY:=0A+=3D=3D64906=3D=3D     in u=
se at exit: 0 bytes in 0 blocks=0A+=3D=3D64906=3D=3D   total heap usage: 19=
 allocs, 19 frees, 1,312 bytes allocated=0A+=3D=3D64906=3D=3D =0A+=3D=3D649=
06=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D64906=
=3D=3D =0A+=3D=3D64906=3D=3D For lists of detected and suppressed errors, r=
erun with: -s=0A+=3D=3D64906=3D=3D ERROR SUMMARY: 0 errors from 0 contexts =
(suppressed: 0 from 0)=0A-- =0A2.34.1=0A=0A=0AFrom 28e70b1913240db20e5bb6a6=
2eebc28acea2bfd7 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@colum=
bia.edu>=0ADate: Sun, 16 Oct 2022 22:01:04 -0400=0ASubject: [PATCH 08/10] S=
tarted doing the second part. Wrote Makefile.=0A=0A---=0A part1/Makefile  |=
  18 +++---=0A part2/Makefile  |  34 ++++++++++=0A part2/revecho.c | 162 ++=
++++++++++++++++++++++++++++++++++++++++++++++=0A 3 files changed, 203 inse=
rtions(+), 11 deletions(-)=0A create mode 100644 part2/Makefile=0A create m=
ode 100644 part2/revecho.c=0A=0Adiff --git a/part1/Makefile b/part1/Makefil=
e=0Aindex 4541332..595d308 100644=0A--- a/part1/Makefile=0A+++ b/part1/Make=
file=0A@@ -20,15 +20,15 @@ ARFLAGS +=3D -U=0A # We can link archive files d=
irectly with object files; the linker command=0A # produced by the Make imp=
licit rule will look something like:=0A #=0A-#   gcc  numbers-test.o  libnu=
mbers.a  -o numbers-test=0A+#   gcc  mylist-test.o  libmylist.a  -o mylist-=
test=0A #=0A mylist-test: mylist-test.o libmylist.a=0A =0A-# This is the ru=
le for building the libnumbers.a archive file.  This rule says=0A-# that th=
e libnumbers.a archive file should contain two object files---prime.o=0A-# =
and power.o---and should be updated whenever prime.o or power.o are updated=
=2E=0A+# This is the rule for building the libmylist.a archive file.  This =
rule says=0A+# that the libmylist.a archive file should contain one object =
file---mylist.o=0A+#---and should be updated whenever mylist.o is updated.=
=0A #=0A-# We rely on Make's implicit rules to update libnumbers.a when nec=
essary.  The=0A+# We rely on Make's implicit rules to update libmylist.a wh=
en necessary.  The=0A # template recipe for the implicit rule looks somethi=
ng like this:=0A #=0A #   $(AR)  $(ARFLAGS)  <archive-file.a>  <member-obje=
ct-file.o>=0A@@ -36,13 +36,9 @@ mylist-test: mylist-test.o libmylist.a=0A #=
 Our archive rule will lead to a recipe for each of the member object files=
,=0A # which will turn out to be:=0A #=0A-#   ar  rv -U  libnumbers.a  prim=
e.o=0A+#   ar  rv -U  libmylist.a mylist.o=0A #=0A-# And:=0A-#=0A-#   ar  r=
v -U  libnumbers.a  power.o=0A-#=0A-# The "r" flag tells ar to add power.o =
(or prime.o) to libnumbers.a with=0A+# The "r" flag tells ar to add mylist.=
o to libmylist.a with=0A # (r)eplacement (i.e., add it, and replace it if a=
lready present).=0A #=0A # The "v" flag tells ar to be verbose, i.e., outpu=
t information about what it's=0Adiff --git a/part2/Makefile b/part2/Makefil=
e=0Anew file mode 100644=0Aindex 0000000..9813f63=0A--- /dev/null=0A+++ b/p=
art2/Makefile=0A@@ -0,0 +1,34 @@=0A+# As usual, we define the C compiler we=
 would like to use:=0A+CC =3D gcc=0A+=0A+# In addition to the usual C compi=
lation flags, we also write -I../part1 to tell=0A+# the C compiler to look =
in ../part1 for header files.  This is what allows us to=0A+# #include <myl=
ist.h>.=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17 -I../part1=0A+=0A+# We=
 pass the -L../part1 flag to the linker to tell it to look in ../part1 for=
=0A+# library archive files.  This is what allows us to use -lmylist.=0A+LD=
FLAGS =3D -L../part1=0A+=0A+# We also give the linker the -lmylist flag to =
tell it to look in libmylist.a=0A+# for missing symbol definitions.=0A+LDLI=
BS =3D -lmylist=0A+=0A+# Note that there are two separate Make variables us=
ed to configure the linker:=0A+# LDFLAGS and LDLIBS.  This is because for h=
istorical reasons, LDFLAGS needs to=0A+# be appear before object files, whe=
reas LDLIBS needs to appear afterwards.=0A+# The implicit rule for linking =
looks like this:=0A+#=0A+#     $(CC)  $(LDFLAGS)  <objects>  -o <output-nam=
e>  $(LDLIBS)=0A+#=0A+# So, with the above variables, the linking command t=
hat is run will be:=0A+#=0A+#     gcc  -L../part1  revecho.o  -o revecho  -=
lmylist=0A+#=0A+revecho: revecho.o=0A+=0A+revecho.o: revecho.c=0A+=0A+.PHON=
Y: clean=0A+clean:=0A+	rm -rf revecho *.o a.out=0Adiff --git a/part2/revech=
o.c b/part2/revecho.c=0Anew file mode 100644=0Aindex 0000000..85ac9d2=0A---=
 /dev/null=0A+++ b/part2/revecho.c=0A@@ -0,0 +1,162 @@=0A+#include <stdlib.=
h> =0A+#include <stdio.h>=0A+#include <string.h>=0A+#include <mylist.h>=0A+=
=0A+static void print(void * str){=0A+    printf("%s\n",(char *) str);=0A+ =
   return;=0A+}=0A+=0A+int main(int argc, char **argv){=0A+    struct List =
list;=0A+    initList(&list);=0A+    argv++;=0A+    =0A+    while(*argv !=
=3D NULL){=0A+        addFront(&list, *argv);=0A+        argv++;=0A+    }=
=0A+    =0A+    traverseList(&list, &print);=0A+   =0A+    if(findNode(&lis=
t, "dude", int (*compar)(const void *, const void *)) =3D=3D NULL){=0A+    =
    printf("\ndude not found");=0A+    }else{=0A+        printf("\ndude fou=
nd");=0A+    }=0A+   =0A+    return 0;=0A+}=0A+=0A+/*=0A+=0A+ * A node in a=
 linked list.=0A+ =0A+struct Node {=0A+    void *data;=0A+    struct Node *=
next;=0A+};=0A+=0A+=0A+ * A linked list.=0A+ * 'head' points to the first n=
ode in the list, or is NULL if empty.=0A+=0A+struct List {=0A+    struct No=
de *head;=0A+};=0A+=0A+=0A+ * Initialize an empty list.=0A+ =0A+static inli=
ne void initList(struct List *list)=0A+{=0A+    list->head =3D NULL;=0A+}=
=0A+=0A+=0A+ * In all functions below, the 'list' parameter is assumed to p=
oint to=0A+ * a valid struct List.=0A+=0A+=0A+=0A+ * Create a node that hol=
ds the given data pointer,=0A+ * and add the node to the front of the list.=
=0A+ *=0A+ * Note that this function does not manage the lifetime of the ob=
ject=0A+ * pointed to by 'data'.=0A+ *=0A+ * It returns the newly created n=
ode on success and NULL on failure.=0A+ =0A+struct Node *addFront(struct Li=
st *list, void *data);=0A+=0A+=0A+ * Traverse the list, calling f() with ea=
ch data item.=0A+ =0A+void traverseList(struct List *list, void (*f)(void *=
));=0A+=0A+=0A+ * Traverse the list, comparing each data item with 'dataSou=
ght' using=0A+ * 'compar' function.  ('compar' returns 0 if the data pointe=
d to by=0A+ * the two parameters are equal, non-zero value otherwise.)=0A+ =
*=0A+ * Returns the first node containing the matching data,=0A+ * NULL if =
not found.=0A+=0A+struct Node *findNode(struct List *list, const void *data=
Sought,=0A+    int (*compar)(const void *, const void *));=0A+=0A+=0A+ * Fl=
ip the sign of the double value pointed to by 'data' by=0A+ * multiplying -=
1 to it and putting the result back into the memory=0A+ * location.=0A+ =0A=
+void flipSignDouble(void *data);=0A+=0A+ * Compare two double values point=
ed to by the two pointers.=0A+ * Return 0 if they are the same value, 1 oth=
erwise.=0A+ =0A+int compareDouble(const void *data1, const void *data2);=0A=
+=0A+=0A+ * Returns 1 if the list is empty, 0 otherwise.=0A+ =0A+static inl=
ine int isEmptyList(struct List *list)=0A+{=0A+    return (list->head =3D=
=3D NULL);=0A+}=0A+=0A+=0A+ * Remove the first node from the list, dealloca=
te the memory for the=0A+ * node, and return the 'data' pointer that was st=
ored in the node.=0A+ * Returns NULL is the list is empty.=0A+ =0A+void *po=
pFront(struct List *list);=0A+=0A+=0A+ * Remove all nodes from the list, de=
allocating the memory for the=0A+ * nodes.  You can implement this function=
 using popFront().=0A+ =0A+void removeAllNodes(struct List *list);=0A+=0A+=
=0A+ * Create a node that holds the given data pointer,=0A+ * and add the n=
ode right after the node passed in as the 'prevNode'=0A+ * parameter.  If '=
prevNode' is NULL, this function is equivalent to=0A+ * addFront().=0A+ *=
=0A+ * Note that prevNode, if not NULL, is assumed to be one of the nodes=
=0A+ * in the given list.  The behavior of this function is undefined if=0A=
+ * prevNode does not belong in the given list.=0A+ *=0A+ * Note that this =
function does not manage the lifetime of the object=0A+ * pointed to by 'da=
ta'.=0A+ *=0A+ * It returns the newly created node on success and NULL on f=
ailure.=0A+ =0A+struct Node *addAfter(struct List *list,=0A+    struct Node=
 *prevNode, void *data);=0A+=0A+=0A+ * Reverse the list.=0A+ *=0A+ * Note t=
hat this function reverses the list purely by manipulating=0A+ * pointers. =
 It does NOT call malloc() directly or indirectly (which=0A+ * means that i=
t does not call addFront() or addAfter()).=0A+ *=0A+ * Implementation hint:=
 keep track of 3 consecutive nodes (previous,=0A+ * current, next) and move=
 them along in a while loop.  Your function=0A+ * should start like this:=
=0A+ *=0A+ *    struct Node *prv =3D NULL;=0A+ *    struct Node *cur =3D li=
st->head;=0A+ *    struct Node *nxt;=0A+ *=0A+ *    while (cur)=0A+ *      =
  ...=0A+ *=0A+ * And at the end, prv will end up pointing to the first ele=
ment of=0A+ * the reversed list.  Don't forget to assign it to list->head.=
=0A+=0A+void reverseList(struct List *list);=0A+ */=0A-- =0A2.34.1=0A=0A=0A=
=46rom 209913fc6ca0396b80250825e088c292c838a1a1 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 16 Oct 2022 23:52:50=
 -0400=0ASubject: [PATCH 09/10] Made minor changes to Makefiles and deleted=
 some of my=0A own comments.=0A=0A---=0A README.txt      |   2 +=0A part1/M=
akefile  |  11 ++--=0A part2/revecho.c | 142 ++----------------------------=
------------------=0A 3 files changed, 14 insertions(+), 141 deletions(-)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex d8d50aa..0f11050 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -46,3 +46,5 @@ popped 5.0, and =
reversed the rest: [ ]=0A =3D=3D64906=3D=3D =0A =3D=3D64906=3D=3D For lists=
 of detected and suppressed errors, rerun with: -s=0A =3D=3D64906=3D=3D ERR=
OR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)=0A+valgrind: Un=
known option: --leack-check=3Dyes=0A+valgrind: Use --help for more informat=
ion or consult the user manual.=0Adiff --git a/part1/Makefile b/part1/Makef=
ile=0Aindex 595d308..a8fe598 100644=0A--- a/part1/Makefile=0A+++ b/part1/Ma=
kefile=0A@@ -56,9 +56,10 @@ mylist-test.o: mylist-test.c mylist.h=0A # any =
archive files built here.=0A .PHONY: clean=0A clean:=0A-	rm -rf mylist-test=
 actualoutput.txt *.o *.a a.out=0A+	rm -rf mylist-test *.o *.a a.out=0A =0A=
-.PHONY: compare=0A-compare: =0A-	./mylist-test > actualoutput.txt=0A-	diff=
 actualoutput.txt mylist-test-output.txt=0A+=0A+#.PHONY: compare=0A+#compar=
e: =0A+#	./mylist-test > actualoutput.txt=0A+#	diff actualoutput.txt mylist=
-test-output.txt=0Adiff --git a/part2/revecho.c b/part2/revecho.c=0Aindex 8=
5ac9d2..fdaba8f 100644=0A--- a/part2/revecho.c=0A+++ b/part2/revecho.c=0A@@=
 -20,143 +20,13 @@ int main(int argc, char **argv){=0A     =0A     traverse=
List(&list, &print);=0A    =0A-    if(findNode(&list, "dude", int (*compar)=
(const void *, const void *)) =3D=3D NULL){=0A-        printf("\ndude not f=
ound");=0A+    if(findNode(&list, "dude",(int (*)(const void *, const void =
*)) &strcmp) =3D=3D NULL){=0A+        printf("\ndude not found\n");=0A     =
}else{=0A-        printf("\ndude found");=0A+        printf("\ndude found\n=
");=0A     }=0A-   =0A-    return 0;=0A-}=0A-=0A-/*=0A-=0A- * A node in a l=
inked list.=0A- =0A-struct Node {=0A-    void *data;=0A-    struct Node *ne=
xt;=0A-};=0A-=0A-=0A- * A linked list.=0A- * 'head' points to the first nod=
e in the list, or is NULL if empty.=0A-=0A-struct List {=0A-    struct Node=
 *head;=0A-};=0A-=0A-=0A- * Initialize an empty list.=0A- =0A-static inline=
 void initList(struct List *list)=0A-{=0A-    list->head =3D NULL;=0A-}=0A-=
=0A-=0A- * In all functions below, the 'list' parameter is assumed to point=
 to=0A- * a valid struct List.=0A-=0A-=0A-=0A- * Create a node that holds t=
he given data pointer,=0A- * and add the node to the front of the list.=0A-=
 *=0A- * Note that this function does not manage the lifetime of the object=
=0A- * pointed to by 'data'.=0A- *=0A- * It returns the newly created node =
on success and NULL on failure.=0A- =0A-struct Node *addFront(struct List *=
list, void *data);=0A-=0A-=0A- * Traverse the list, calling f() with each d=
ata item.=0A- =0A-void traverseList(struct List *list, void (*f)(void *));=
=0A-=0A-=0A- * Traverse the list, comparing each data item with 'dataSought=
' using=0A- * 'compar' function.  ('compar' returns 0 if the data pointed t=
o by=0A- * the two parameters are equal, non-zero value otherwise.)=0A- *=
=0A- * Returns the first node containing the matching data,=0A- * NULL if n=
ot found.=0A-=0A-struct Node *findNode(struct List *list, const void *dataS=
ought,=0A-    int (*compar)(const void *, const void *));=0A-=0A-=0A- * Fli=
p the sign of the double value pointed to by 'data' by=0A- * multiplying -1=
 to it and putting the result back into the memory=0A- * location.=0A- =0A-=
void flipSignDouble(void *data);=0A-=0A- * Compare two double values pointe=
d to by the two pointers.=0A- * Return 0 if they are the same value, 1 othe=
rwise.=0A- =0A-int compareDouble(const void *data1, const void *data2);=0A-=
=0A+    =0A+    removeAllNodes(&list);=0A =0A- * Returns 1 if the list is e=
mpty, 0 otherwise.=0A- =0A-static inline int isEmptyList(struct List *list)=
=0A-{=0A-    return (list->head =3D=3D NULL);=0A+    return 0;=0A }=0A-=0A-=
=0A- * Remove the first node from the list, deallocate the memory for the=
=0A- * node, and return the 'data' pointer that was stored in the node.=0A-=
 * Returns NULL is the list is empty.=0A- =0A-void *popFront(struct List *l=
ist);=0A-=0A-=0A- * Remove all nodes from the list, deallocating the memory=
 for the=0A- * nodes.  You can implement this function using popFront().=0A=
- =0A-void removeAllNodes(struct List *list);=0A-=0A-=0A- * Create a node t=
hat holds the given data pointer,=0A- * and add the node right after the no=
de passed in as the 'prevNode'=0A- * parameter.  If 'prevNode' is NULL, thi=
s function is equivalent to=0A- * addFront().=0A- *=0A- * Note that prevNod=
e, if not NULL, is assumed to be one of the nodes=0A- * in the given list. =
 The behavior of this function is undefined if=0A- * prevNode does not belo=
ng in the given list.=0A- *=0A- * Note that this function does not manage t=
he lifetime of the object=0A- * pointed to by 'data'.=0A- *=0A- * It return=
s the newly created node on success and NULL on failure.=0A- =0A-struct Nod=
e *addAfter(struct List *list,=0A-    struct Node *prevNode, void *data);=
=0A-=0A-=0A- * Reverse the list.=0A- *=0A- * Note that this function revers=
es the list purely by manipulating=0A- * pointers.  It does NOT call malloc=
() directly or indirectly (which=0A- * means that it does not call addFront=
() or addAfter()).=0A- *=0A- * Implementation hint: keep track of 3 consecu=
tive nodes (previous,=0A- * current, next) and move them along in a while l=
oop.  Your function=0A- * should start like this:=0A- *=0A- *    struct Nod=
e *prv =3D NULL;=0A- *    struct Node *cur =3D list->head;=0A- *    struct =
Node *nxt;=0A- *=0A- *    while (cur)=0A- *        ...=0A- *=0A- * And at t=
he end, prv will end up pointing to the first element of=0A- * the reversed=
 list.  Don't forget to assign it to list->head.=0A-=0A-void reverseList(st=
ruct List *list);=0A- */=0A-- =0A2.34.1=0A=0A=0AFrom 661ec75e4ad761122754c3=
a7fa3f27cba191f8f0 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@col=
umbia.edu>=0ADate: Sun, 16 Oct 2022 23:58:28 -0400=0ASubject: [PATCH 10/10]=
 final commit=0A=0A---=0A README.txt | 24 +++++++++++++++++++++---=0A 1 fil=
e changed, 21 insertions(+), 3 deletions(-)=0A=0Adiff --git a/README.txt b/=
README.txt=0Aindex 0f11050..713b36b 100644=0A--- a/README.txt=0A+++ b/READM=
E.txt=0A@@ -3,7 +3,7 @@ This file should contain:=0A   - Arman Ozcan=0A   -=
 ao2794=0A   - lab 3=0A-  -  =0A+  - My program should work as it should. =
=0A   =0A The description should indicate whether your solution for the par=
t is=0A working or not.  You may also want to include anything else you wou=
ld=0A@@ -46,5 +46,23 @@ popped 5.0, and reversed the rest: [ ]=0A =3D=3D649=
06=3D=3D =0A =3D=3D64906=3D=3D For lists of detected and suppressed errors,=
 rerun with: -s=0A =3D=3D64906=3D=3D ERROR SUMMARY: 0 errors from 0 context=
s (suppressed: 0 from 0)=0A-valgrind: Unknown option: --leack-check=3Dyes=
=0A-valgrind: Use --help for more information or consult the user manual.=
=0A+=3D=3D243798=3D=3D Memcheck, a memory error detector=0A+=3D=3D243798=3D=
=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=
=3D243798=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyrig=
ht info=0A+=3D=3D243798=3D=3D Command: ./revecho arman is a dude=0A+=3D=3D2=
43798=3D=3D =0A+dude=0A+a=0A+is=0A+arman=0A+=0A+dude found=0A+=3D=3D243798=
=3D=3D =0A+=3D=3D243798=3D=3D HEAP SUMMARY:=0A+=3D=3D243798=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D243798=3D=3D   total heap usage: 5 =
allocs, 5 frees, 2,624 bytes allocated=0A+=3D=3D243798=3D=3D =0A+=3D=3D2437=
98=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D24379=
8=3D=3D =0A+=3D=3D243798=3D=3D For lists of detected and suppressed errors,=
 rerun with: -s=0A+=3D=3D243798=3D=3D ERROR SUMMARY: 0 errors from 0 contex=
ts (suppressed: 0 from 0)=0A-- =0A2.34.1=0A=0A
--5uDsrq7Iv/ojqvOG--

From do.not.reply@cloud.cs.columbia.edu Sun Oct 30 14:40:45 2022
Date: Sun, 30 Oct 2022 14:40:45 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab4.mbox
Message-ID: <Y17FLG5fRFUj3T4U@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="QawcFD8xKR5FIQzb"
Content-Disposition: inline
Status: RO
Content-Length: 112759
Lines: 2395


--QawcFD8xKR5FIQzb
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From b17121dde3b7fc8d739d268096e2b08834e5a834 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Thu, 27 Oct 2022 21:38:28 -0400
Subject: [PATCH 1/7] Committed README.txt for the first time

---
 README.txt | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..d342eb7 100644
--- a/README.txt
+++ b/README.txt
@@ -1,8 +1,8 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
+  - Arman Ozcan
+  - ao2794
+  - lab4
   - description for each part
 
 The description should indicate whether your solution for the part is
-- 
2.34.1


From 76ad4ca0ffc83feb4f43cfaf039328636273383e Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 29 Oct 2022 00:26:32 -0400
Subject: [PATCH 2/7] Started writing three files, haven't started the lookup
 loop yet.

---
 part1/Makefile     | 15 +++++++++
 part1/mdb-lookup.c | 80 ++++++++++++++++++++++++++++++++++++++++++++++
 part1/mdb.h        |  5 +++
 3 files changed, 100 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/mdb-lookup.c
 create mode 100644 part1/mdb.h

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..5352fcf
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,15 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17 -I/home/j-hui/cs3157-pub/include
+
+LDFLAGS = -L/home/j-hui/cs3157-pub/lib
+LDLIBS = -lmylist
+
+mdb-lookup: mdb-lookup.o
+mdb-lookup.o: mdb-lookup.c mdb.h
+
+.PHONY: clean
+clean:
+	rm -f *.o *~ a.out core mdb-lookup
+
+.PHONY: all
+all: clean mdb-lookup
diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
new file mode 100644
index 0000000..6a64712
--- /dev/null
+++ b/part1/mdb-lookup.c
@@ -0,0 +1,80 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <mylist.h>
+#include "mdb.h"
+#include <string.h>
+
+    void printRec(void *rec){
+        struct MdbRec *record = (struct MdbRec *) rec;
+        printf("This is the name: %s\n",(const char *)record->name);
+        printf("This is the message: %s\n",(const char *)record->msg);        
+    }
+
+int main(int argc, char **argv) {
+    /*
+     * Open file whose name is given by argv[1].
+     */
+
+    if (argc != 2) {
+        fprintf(stderr, "%s\n", "usage: mdb-lookup <database-file-name>");
+        exit(1);
+    }
+
+    char *filename = argv[1];
+    FILE *fp = fopen(filename, "r");
+    if (fp == NULL) {
+        perror(filename);
+        exit(1);
+    }
+
+    struct List list;
+    initList(&list);
+
+    /*
+     * Read the file line-by-line, printing out line numbers as we go.
+     */
+
+    // Define a buffer we will read each line into.
+   
+    
+    size_t size = sizeof(struct MdbRec);
+    char buf[size];   
+    
+    struct Node *prev = NULL;  
+    while(fread(buf, 1, size, fp) > 0) {
+       // char name[16];
+       // char msg[24];
+       // memcpy(name, buf, 16 );
+       // memcpy(msg, (buf + 16), 24);
+        
+        struct MdbRec *record = malloc(size);
+        memcpy(record->name,  buf, 16);
+        memcpy(record->msg, buf + 16, 24);
+       
+      
+        
+        prev = addAfter(&list, prev, record);
+       
+    }
+
+    /*
+     * Did we terminate the fgets() loop because of an error?
+     * If so, report the error.
+     */
+
+    if (ferror(fp)) {
+        perror(filename);
+        exit(1);
+    }
+
+    traverseList(&list, &printRec);
+    traverseList(&list, &free);
+    removeAllNodes(&list);
+    /*
+     * Close our file pointer, and quit.
+     */
+
+    fclose(fp);
+    return 0;
+}
+
diff --git a/part1/mdb.h b/part1/mdb.h
new file mode 100644
index 0000000..ab23bf3
--- /dev/null
+++ b/part1/mdb.h
@@ -0,0 +1,5 @@
+struct MdbRec {
+            char name[16];
+            char  msg[24];
+};
+
-- 
2.34.1


From 74106f310e5820b4bb13172dac75bfdbbaa5b28f Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 29 Oct 2022 04:33:49 -0400
Subject: [PATCH 3/7] Started the user input part of the part1. Wrote the fgets
 while loop and key detection.

---
 part1/mdb-lookup.c | 71 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 67 insertions(+), 4 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index 6a64712..a42ed64 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -39,22 +39,35 @@ int main(int argc, char **argv) {
     
     size_t size = sizeof(struct MdbRec);
     char buf[size];   
-    
+    int len;
     struct Node *prev = NULL;  
-    while(fread(buf, 1, size, fp) > 0) {
+    while((len = fread(buf, 1, size, fp)) > 0) {
+         
+       if(len != (int) size ){
+           perror("Didn't read enough bytes!");
+           exit(1);
+       }
        // char name[16];
        // char msg[24];
        // memcpy(name, buf, 16 );
        // memcpy(msg, (buf + 16), 24);
         
         struct MdbRec *record = malloc(size);
+        if(record == NULL){
+            perror("malloc returned NULL");
+            exit(1);
+        }
+           
         memcpy(record->name,  buf, 16);
         memcpy(record->msg, buf + 16, 24);
        
       
         
-        prev = addAfter(&list, prev, record);
-       
+        prev = addAfter(&list, prev, record); 
+        if(prev == NULL){
+            perror("Couldn't add after!");
+            exit(1);
+        } 
     }
 
     /*
@@ -68,6 +81,56 @@ int main(int argc, char **argv) {
     }
 
     traverseList(&list, &printRec);
+    
+    
+   // printf("%s\n", buf);
+    printf("lookup: ");
+    
+
+    char buf2[500];
+   
+    while(fgets(buf2, sizeof(buf2), stdin)){
+        int sizeOfString;
+
+        if(strlen(buf2)<6){
+            sizeOfString = strlen(buf2);
+        }else{
+            sizeOfString = 6;
+        }
+        char string[sizeOfString];
+          
+        strncpy(string, buf2, sizeOfString-1);
+        string[sizeOfString-1] = '\0';
+        
+        printf("The key is: %s\n",string);
+        
+            
+            struct Node *curr = (struct Node*) (&list)->head;
+            
+            struct MdbRec *record;
+            while(curr != NULL){
+                record = (struct MdbRec *) curr->data;
+                printf("The name: %s\n",record->name);  
+                printf("The msg: %s\n",record->msg);
+
+                if(strstr(record->name,string) != NULL){
+                    printf("The common part is: %s\n",strstr(record->name,string));
+                }
+
+                if(strstr(record->msg,string) != NULL){
+                     printf("The common part is: %s\n",strstr(record->msg,string));
+                }
+                curr = curr->next;
+        }
+
+
+       
+    }
+
+    
+
+
+
     traverseList(&list, &free);
     removeAllNodes(&list);
     /*
-- 
2.34.1


From bacbc162e88a8cf3a4538f2efe25eabf9cef1558 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 29 Oct 2022 18:16:04 -0400
Subject: [PATCH 4/7] Still working on input-taking. Have to correct the issue
 that happens when the buffer size is exceeded.

---
 part1/mdb-lookup.c | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index a42ed64..077b890 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -86,9 +86,9 @@ int main(int argc, char **argv) {
    // printf("%s\n", buf);
     printf("lookup: ");
     
-
-    char buf2[500];
-   
+    
+    char buf2[50];
+     
     while(fgets(buf2, sizeof(buf2), stdin)){
         int sizeOfString;
 
@@ -106,25 +106,31 @@ int main(int argc, char **argv) {
         
             
             struct Node *curr = (struct Node*) (&list)->head;
-            
+            int lineno = 1;
             struct MdbRec *record;
             while(curr != NULL){
                 record = (struct MdbRec *) curr->data;
-                printf("The name: %s\n",record->name);  
-                printf("The msg: %s\n",record->msg);
+               // printf("The name: %s\n",record->name);  
+               // printf("The msg: %s\n",record->msg);
 
                 if(strstr(record->name,string) != NULL){
-                    printf("The common part is: %s\n",strstr(record->name,string));
-                }
-
-                if(strstr(record->msg,string) != NULL){
-                     printf("The common part is: %s\n",strstr(record->msg,string));
+                    printf("%4d: {%s} said {%s}\n",lineno, record->name, record->msg);
+                }else if(strstr(record->msg,string) != NULL){
+                    printf("%4d: {%s} said  {%s}\n",lineno, record->name, record->msg);
                 }
+                 
+                lineno++;
                 curr = curr->next;
         }
+            printf("\n");
 
+    printf("This is what buffer looks like: %s\n", buf2);
+   
+    printf("lookup: ");
+    
+    
+    //fseek(stdin, 0, SEEK_SET);   
 
-       
     }
 
     
-- 
2.34.1


From c4a0a52c7d130a8303b52aa0f044c04ff1f6f44a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 29 Oct 2022 19:09:52 -0400
Subject: [PATCH 5/7] I think I finally can receive arbitrarily long input.

---
 part1/mdb-lookup.c | 24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index 077b890..3fc64e2 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -86,13 +86,15 @@ int main(int argc, char **argv) {
    // printf("%s\n", buf);
     printf("lookup: ");
     
-    
-    char buf2[50];
+    int n = 10; 
+    char buf2[n];
      
     while(fgets(buf2, sizeof(buf2), stdin)){
         int sizeOfString;
-
-        if(strlen(buf2)<6){
+        
+        printf("This the buffer before: %s\n", buf2);
+        
+        if(strlen(buf2)<=5){
             sizeOfString = strlen(buf2);
         }else{
             sizeOfString = 6;
@@ -103,7 +105,14 @@ int main(int argc, char **argv) {
         string[sizeOfString-1] = '\0';
         
         printf("The key is: %s\n",string);
+  
         
+        while(buf2[strlen(buf2)-1] != '\n' ){
+            fgets(buf2, sizeof(buf2),stdin);
+        }
+
+       
+        printf("This is the buffer after: %s\n", buf2);
             
             struct Node *curr = (struct Node*) (&list)->head;
             int lineno = 1;
@@ -124,7 +133,7 @@ int main(int argc, char **argv) {
         }
             printf("\n");
 
-    printf("This is what buffer looks like: %s\n", buf2);
+  
    
     printf("lookup: ");
     
@@ -135,7 +144,10 @@ int main(int argc, char **argv) {
 
     
 
-
+    if (ferror(stdin)) {
+        perror("There was an error in stdin");
+        exit(1);
+    }
 
     traverseList(&list, &free);
     removeAllNodes(&list);
-- 
2.34.1


From 2c3da16fa400b5e56f33b1e45460a00a7d05a7cd Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 29 Oct 2022 22:44:36 -0400
Subject: [PATCH 6/7] Part 1 seems to be working, but I will make some little
 adds to account for the edge cases and early exits.

---
 part1/mdb-lookup.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index 3fc64e2..fa5bf71 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -80,21 +80,21 @@ int main(int argc, char **argv) {
         exit(1);
     }
 
-    traverseList(&list, &printRec);
+    // traverseList(&list, &printRec);
     
     
    // printf("%s\n", buf);
     printf("lookup: ");
     
-    int n = 10; 
+    int n = 7; 
     char buf2[n];
      
     while(fgets(buf2, sizeof(buf2), stdin)){
         int sizeOfString;
         
-        printf("This the buffer before: %s\n", buf2);
+       // printf("This the buffer before: %s\n", buf2);
         
-        if(strlen(buf2)<=5){
+        if(strlen(buf2)<=6){
             sizeOfString = strlen(buf2);
         }else{
             sizeOfString = 6;
@@ -104,7 +104,7 @@ int main(int argc, char **argv) {
         strncpy(string, buf2, sizeOfString-1);
         string[sizeOfString-1] = '\0';
         
-        printf("The key is: %s\n",string);
+        //printf("The key is: %s\n",string);
   
         
         while(buf2[strlen(buf2)-1] != '\n' ){
@@ -112,7 +112,7 @@ int main(int argc, char **argv) {
         }
 
        
-        printf("This is the buffer after: %s\n", buf2);
+        //printf("This is the buffer after: %s\n", buf2);
             
             struct Node *curr = (struct Node*) (&list)->head;
             int lineno = 1;
@@ -138,7 +138,7 @@ int main(int argc, char **argv) {
     printf("lookup: ");
     
     
-    //fseek(stdin, 0, SEEK_SET);   
+   // fseek(stdin, 0, SEEK_END);   
 
     }
 
@@ -158,4 +158,3 @@ int main(int argc, char **argv) {
     fclose(fp);
     return 0;
 }
-
-- 
2.34.1


From 4379c077bf68fc44c476258ef8742edf7018f82a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 30 Oct 2022 14:39:36 -0400
Subject: [PATCH 7/7] I inserted the Valgrind output. This should be the final
 commit.

---
 README.txt         | 927 ++++++++++++++++++++++++++++++++++++++++++++-
 part1/mdb-lookup.c |  74 ++--
 2 files changed, 962 insertions(+), 39 deletions(-)

diff --git a/README.txt b/README.txt
index d342eb7..74089f0 100644
--- a/README.txt
+++ b/README.txt
@@ -3,9 +3,934 @@ This file should contain:
   - Arman Ozcan
   - ao2794
   - lab4
-  - description for each part
+  - My program is seemingly working.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==201254== Memcheck, a memory error detector
+==201254== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==201254== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==201254== Command: ./mdb-lookup /home/j-hui/cs3157-pub/bin/mdb-cs3157
+==201254== 
+lookup:  768: {Arman} said {I procrastinated this s}
+
+lookup:    1: {John} said {Welcome to AP!}
+   2: {ryan} said {hi mom}
+   3: {some student} said {file pointers are hard!}
+   4: {some student} said {Prezbos fun run changed}
+   5: {John} said {Read the man pages!}
+   6: {Griffin N} said {finding a job is hard}
+   7: {Griffin N} said {Welcome to the US}
+   8: {garfield} said {i love lasagna}
+   9: {Camerie} said {Good luck on lab4 :)}
+  10: {anya} said {i love peanuts}
+  11: {camerie} said {^^}
+  12: {nobody} said {the weather is nice!}
+  13: {Rishabh} said {I watched the lecture}
+  14: {John} said {slay}
+  15: {Feiyang} said {hello}
+  16: {so then I} said {horse walked into a bar}
+  17: {bartender} said {"why the long face"}
+  18: {Martin} said {oops i might've done sm}
+  19: {Martin (again)} said {nvm}
+  20: {}{} said {caught a leaf yestrday}
+  21: {}{}{}\{}{}{} said {heeh this is fun}
+  22: {Marie} said {Can't wait for spring!}
+  23: {DROP TABLE name} said {just kidding}
+  24: {Kendall Roy} said {good memeage}
+  25: {Logan Roy} said {I don't read my emails}
+  26: {Connor Roy} said {Conheads unite!}
+  27: {Shiv Roy} said {no comment}
+  28: {cate} said {everything is great!}
+  29: {cate} said {just kidding}
+  30: {John} said {November is coming...}
+  31: {maiya} said {wello horld}
+  32: {raccoon} said {eats hamburger}
+  33: {harry} said {didn't do homework}
+  34: {YeongWoo} said {has a midterm tomorrow}
+  35: {ayalyakobe} said {i think i figured it ou}
+  36: {Chukwuma Orji} said {No late days this time}
+  37: {ciaran } said {hi ciaran }
+  38: {Jorge} said {git add README.txt}
+  39: {Jorge} said {starting labs early is }
+  40: {Jorge } said {good practice}
+  41: {tommy w} said {oh hi mark}
+  42: {after all is} said {and done, more is said }
+  43: {frog} said {it's wednesday, my dude}
+  44: {Gyuseok} said {Hi guys}
+  45: {Claudia} said {hi Kaitlyn}
+  46: {KY} said {good afternoon}
+  47: {Cianna} said {im eating reese's piece}
+  48: {Brendan} said {hello}
+  49: {Brendan} said {hello again}
+  50: {Kevin Li} said {This is cool!!}
+  51: {Kevin Li} said {This is super cool!!}
+  52: {EDunlop} said {Hello Everyone}
+  53: {Heejong Han} said {I am so hungry right no}
+  54: {zaka } said {pizza time!}
+  55: {zaka} said {never gonna give u up}
+  56: {zaka} said {never gonna let u down}
+  57: {zaka} said {never gonna run around}
+  58: {zaka} said {n desert u <3}
+  59: {} said {}
+  60: {John} said {beware identity theft}
+  61: {luca} said {nothing}
+  62: {-_-} said {0_0}
+  63: {0_0} said {-_-}
+  64: {Dallas} said {Pointers on pointers}
+  65: {Dallas} said {Can you C me?}
+  66: {Tommy} said {Halleluyah}
+  67: {Ly} said {Hakuna Matata}
+  68: {Jacob} said {suh dude}
+  69: {ben} said {freshwater fishes of th}
+  70: {Mike} said {I <3 AP}
+  71: {Zi} said {this is actually c     }
+  72: {zi} said {good luck guyss}
+  73: {mayachka} said {i love maya}
+  74: {vitamin} said {water}
+  75: {Some Student} said {Trying to survive midte}
+  76: {Segmentation} said {Fault Core Dumped}
+  77: {Lw eana } said {Hey  , I'm doin     [C }
+  78: {Leana} said {I'm ready}
+  79: {Logan} said {I dont know what to say}
+  80: {ayalyakobe} said {testing}
+  81: {Maitar} said {Are we ready for midter}
+  82: {Maitar} said {r we ready for MD2 XD?}
+  83: {yizhen} said {iHere for lab4}
+  84: {Carl} said {Hello there}
+  85: {Morty} said {Oh Jeez Rick}
+  86: {Harry Potter} said {Expelliarmus}
+  87: {marcusfong12345} said {hes the best TA}
+  88: {CCG} said {Hello}
+  89: {CCG} said {World}
+  90: {Mike} said {chocolate croissant}
+  91: {Mike} said {almond croissant}
+  92: {Mike} said {nutella cornetto}
+  93: {Melissa Moran} said {Lab4-OK!}
+  94: {Karla Zuniga} said {Keep going! }
+  95: {Siwanta Thapa} said {There is hope}
+  96: {Alex J.K. XU} said {Hello MDB, how are you?}
+  97: {Alex J.K. XU} said {MDB: Great Great!}
+  98: {Nathan Raghavan} said {Hey guys whats up!}
+  99: {joel} said {mmmm im mr frundles}
+ 100: {Rimas} said {I love AP!}
+ 101: {hohn jui} said {uh}
+ 102: {jenny} said {Hi, how are you today?}
+ 103: {steph curry} said {im better than lebron}
+ 104: {mom} said {hi}
+ 105: {cs major} said {i love hygiene}
+ 106: {aiden} said {i <3 eris}
+ 107: {eris} said {i <3 aiden}
+ 108: {ap student} said {lab 4 is hard :'(}
+ 109: {EitanF} said {Hello mdb}
+ 110: {daenerys} said {dracarys}
+ 111: {ned stark} said {winter is coming}
+ 112: {Kent } said {}
+ 113: {Kent} said {Lab 4}
+ 114: {nobody} said {they like AP}
+ 115: {            } said {Hello}
+ 116: {BRS} said {Hello World!}
+ 117: {Tomas} said {hey !!}
+ 118: {H3} said {It's Friday!}
+ 119: {said} said {said}
+ 120: {Tanvir Hossain } said {Hello mates, wish you a}
+ 121: {joey} said {how you doin}
+ 122: {phoebe} said {ello there mate}
+ 123: {ross} said {you think??}
+ 124: {henry} said {hiiiiiiiiiiiiiiiiiiiiii}
+ 125: {l  [C Luci} said {Coding is              }
+ 126: {Darth Vader} said {I'm       [C [C [C [C [}
+ 127: {Britney Spears} said {Oops i did it again...}
+ 128: {Steven Urq} said {I don't know.}
+ 129: {Steven U.} said {This is data!}
+ 130: {Monique} said {Testing database}
+ 131: {d{}s} said {said{said}said}
+ 132: {h  i} said {wow     }
+ 133: {Joseph Kaplan} said {B"H it's the weekend}
+ 134: {} said {} said {}{}
+ 135: {wwwwwwwwwwwwwww} said {wwwwwwwwwwwwwwwwwwwwwww}
+ 136: {} said {}
+ 137: {123456789012345} said {12345678901234567890123}
+ 138: {I} said {the truncation works!}
+ 139: {I} said {crtfd freak 7days/week}
+ 140: {John} said {nz2368 deserves an A}
+ 141: {Charis Yoon} said {hi}
+ 142: {Lets play chess} said {1. e4}
+ 143: {Jessica} said {hi melina}
+ 144: {Jessica} said {hi jacklyn}
+ 145: {Jessica} said {hi kaylee}
+ 146: {Embyr} said {howdy}
+ 147: {world} said {hello}
+ 148: {devon} said {since when does roaree }
+ 149: {fread} said {i rhyme with bread}
+ 150: {Gill Bartels} said {finally starting this a}
+ 151: {Logan} said {LGM}
+ 152: {John Cena} said {U cant see me}
+ 153: {ben} said {dro-tang-leski}
+ 154: {aryana} said {hi}
+ 155: {Erica} said {waz here!!!!}
+ 156: {Lexi} said {It's spooky szn!}
+ 157: {enrico pucci} said {hallelujah, dio!}
+ 158: {Homer} said {d'oh!}
+ 159: {Will Hoppin} said {help I'm trapped in C!}
+ 160: {DJ Khaled} said {Another one}
+ 161: {    } said {                       }
+ 162: {Mom}     {Dad} said {We're getting divorced}
+ 163: {Stanley} said {hello 315      [C [C [C}
+ 164: {Stanley} said {it's Saturday}
+ 165: {Linda} said {hellohello}
+ 166: {Linda} said {hihihi}
+ 167: {Pru Yontrarak} said {I love AP}
+ 168: {Danielzzzz} said {Hate midterms}
+ 169: {Danielzzzz} said {Love midterms}
+ 170: {another one} said {bites the dust}
+ 171: {mariam} said {i am working on lab4}
+ 172: {David} said {naur}
+ 173: {Liam} said {42}
+ 174: {carrie :)} said {_ _ _ _ _ _ _}
+ 175: {Liam A} said {My contribution}
+ 176: {david} said {a}
+ 177: {carrie} said {_ _ _ _ _ _ _ (head)}
+ 178: {david} said {e}
+ 179: {carrie} said {_ _ _ _ _ _ _ (head) (b}
+ 180: {carrie} said {you are bad at this}
+ 181: {david} said {i}
+ 182: {carrie} said {_ _ _ _ _ I _}
+ 183: {david} said {r}
+ 184: {carrie} said {buddy no, that's an arm}
+ 185: {tired} said {s}
+ 186: {Dad} said {Hi tired, I'm}
+ 187: {carrie} said {also wrong}
+ 188: {hint} said {112}
+ 189: {d} said {p}
+ 190: {carrie} said {P _ _ P _ I _}
+ 191: {d} said {pumpkin}
+ 192: {carrie} said {PUMPKIN ! ! !}
+ 193: {hel} said {}
+ 194: {aslfj;l} said {as;ldkfja;lsfkdjas;lfjk}
+ 195: {Claudia} said {happy saturday everyone}
+ 196: {claudia} said {its cold out}
+ 197: {cs} said {do u like me? (y/n)}
+ 198: {MR4217} said {LettuceTacoBoutIt}
+ 199: {henry} said {hiiiiii}
+ 200: {henry} said {hii}
+ 201: {hii} said {henry}
+ 202: {hiiiiiii} said {henry}
+ 203: {hiiiiii} said {hiiiiiiiii}
+ 204: {hii} said {hii}
+ 205: {Pork Chop} said {Hey there}
+ 206: {Student} said {labs are hard}
+ 207: {hello } said {goodbye}
+ 208: {Leana} said {Big brains}
+ 209: {Freddy C     [C} said {Hello!  }
+ 210: {Ahmed Mahmud} said {Ho  Hope everyoin  ne i}
+ 211: {Ahmed Mahmud} said {AP is fun!}
+ 212: {Lucy} said {sup}
+ 213: {Keyi} said {twinkle twinkle}
+ 214: {Keyi} said {little star}
+ 215: {Gabriel Trigo} said {database test}
+ 216: {tomatoboi} said {i am so swag}
+ 217: {I} said {so}
+ 218: {God} said {Let there be light}
+ 219: {0} said {0}
+ 220: {Jas} said {World Cup is soon!}
+ 221: {Doublelift} said {NA<EU}
+ 222: {William Wang} said {Wait what happened to t}
+ 223: {Lucas} said {Excited to work on this}
+ 224: {Lucas} said {Tried popeyes}
+ 225: {Shimon} said {Why are computers not g}
+ 226: {Shimon} said {ood boxers at all?}
+ 227: {Shimon} said {Forget it}
+ 228: {Shimon} said {This joke is too long}
+ 229: {Ethan T} said {Twenty seventy-five}
+ 230: {smf2240} said {Oh hi Mark}
+ 231: {dang} said {^someone beat me to tha}
+ 232: {DJ Khalid} said {anotha one}
+ 233: {Edward Kim} said {hello!}
+ 234: {Edward Kim} said {hello again!}
+ 235: {satan} said {let there be darkness}
+ 236: {john hui} said {trust me guys the exams}
+ 237: {john hui} said {are totally fair}
+ 238: {Dr. Dre} said {Slim Shady you a base-h}
+ 239: {Dr. Dre} said { nothing, you idiots}
+ 240: {orange} said {i'm blue}
+ 241: {Cole} said {hello cruld}
+ 242: {Cole} said {*cruel world}
+ 243: {jeff} said {my name is jeff}
+ 244: {Walt} said {I am the one who knocks}
+ 245: {kapybara} said {no thoughts head empty}
+ 246: {Camko} said {Happy Sunday}
+ 247: {nga2120} said {Go Blue!}
+ 248: {Mst Nayma} said {CS is great! :)}
+ 249: {Anagha Ram} said {Pumpkin spice szn}
+ 250: {Anagha Ram} said {halloween next week!}
+ 251: {Mike D} said {Testy test}
+ 252: {jessica} said {i need to go home}
+ 253: {jessica} said {it's sunday}
+ 254: {Roey} said {The struggle is real!}
+ 255: {blake} said {i use arch btw}
+ 256: {blake} said {what's a cornell?}
+ 257: {Natalie} said {AP + JHUI = FUN}
+ 258: {Luiza Serson} said {I am currently working }
+ 259: {Luiza Serson} said {Hello!}
+ 260: {Natalie} said {What Blake Said}
+ 261: {blake} said {i simp 4 john hui}
+ 262: {Alia} said {meow}
+ 263: {Hellooo} said {World}
+ 264: {Columbia} said {lost homecoming}
+ 265: {Preach} said {Hi! I love AP}
+ 266: {Preach} said {This is so cool}
+ 267: {hana m} said {andy is helping me toda}
+ 268: {Luciana } said {hi :) }
+ 269: {Luciana } said {testing testing }
+ 270: {Kylie} said {Good luck y'all}
+ 271: {Tehreem} said {The earth <3}
+ 272: {john} said {hey}
+ 273: {sohyb} said {hi lol}
+ 274: {amina} said {lmao kinda cool}
+ 275: {I wish lab4 was} said {as fun as adding info h}
+ 276: {test} said {test}
+ 277: {Eleanor} said {Learning C is fun}
+ 278: {el3079} said {Hello!}
+ 279: {Zachary Zusin} said {I'm going baby on baby}
+ 280: {Jinoo} said {bruh}
+ 281: {Ismail} said {what do i say?}
+ 282: {matt} said {rip wisco }
+ 283: {matt} said {so sad :/ }
+ 284: {Andrew} said {roar}
+ 285: {wakefield} said {hello guys}
+ 286: {Aidan Eichman} said {hopefully this works :)}
+ 287: {Aidan Eichman} said {go blue!!!}
+ 288: {Aidan Eichman} said {yay this works!}
+ 289: {The TAs} said {  \_(   )_/  }
+ 290: {} said {}
+ 291: { }{} said {}{}
+ 292: {CharlesY} said {Awesome program.}
+ 293: {CharlesY} said {damn this is difficult}
+ 294: {Ma Yun} said {I am not intersted in m}
+ 295: {Ma Yun} said {I am not interested in }
+ 296: {Ma Yun} said {I have no interest in $}
+ 297: {Sa Beining} said {0-0 trying not to laugh}
+ 298: {Sa Beining} said {0-0}
+ 299: {jkim} said {1st message}
+ 300: {jkim} said {2nd message}
+ 301: {Jonathan} said {fundies isn't fun}
+ 302: {Jonno} said {Short for jonathan}
+ 303: {Saitama} said {}
+ 304: {Saitama} said {                       }
+ 305: {Saitama} said {                       }
+ 306: {} said {}
+ 307: {     } said {______________________}
+ 308: {     } said {|                    |}
+ 309: {     } said {|       hello!       |}
+ 310: {     } said {|____________________|}
+ 311: {     } said {()  ()    ||}
+ 312: {     } said {( o w o)  ||          }
+ 313: {bunny} said { (    ) ==0           }
+ 314: {dr livesey} said {the word rum and the wo}
+ 315: {dr livesey} said {rd death mean the same }
+ 316: {dr livesey} said {thing to you}
+ 317: {Yoni} said {New CS listserv???}
+ 318: {Unicorn Friend} said {Something is magical ar}
+ 319: {yissachar yehud} said {you misspelled your own}
+ 320: {yissachar yehud} said {you spelled your name c}
+ 321: {What is love?} said {Baby don't hurt me}
+ 322: {Dorothy} said {hello everyone}
+ 323: {Pawit} said {Hello World}
+ 324: {ps3201} said {Sawadee Krub}
+ 325: {Heisenberg} said {Tread lightly...}
+ 326: {CS student} said {I love social interacti}
+ 327: {          } said {                 }
+ 328: {aja} said {initials}
+ 329: {npr} said {national public radio}
+ 330: {avita} said {hi yall :))}
+ 331: {taylor swift} said {'Cause there we are aga}
+ 332: {gema} said {m de motomami}
+ 333: {Greg Ou} said {Hi my name Greg}
+ 334: {Muscle Man} said {MY MOM}
+ 335: {Kanye West} said {I guess we'll never kno}
+ 336: {Danelle Tuchman} said {drinking coffee rn :)}
+ 337: {Will Smith} said {KEEP MY WIFES NAME OUT }
+ 338: {Julius Caesar} said {Veni, vidi, vici.}
+ 339: {EDunlop} said {just checking}
+ 340: {crister ronaldo} said {sewi}
+ 341: {Matt} said {Connecting...}
+ 342: {testing} said {this is the test }
+ 343: {Nira} said {Avocadoes are the best}
+ 344: {Merry Mayers} said {hydrate or dydrate}
+ 345: {Will} said {likes boba!}
+ 346: {Smith} said {does not like boba}
+ 347: {Akshay} said {This is kinda cool}
+ 348: {some other guy} said {How many of these do I }
+ 349: {Bean Team} said {Birds don't have arms}
+ 350: {ranger} said {chain swanging}
+ 351: {Someone} said {How do i add to the dat}
+ 352: {elise} said {cling clang}
+ 353: {ranger} said {and it costs alot}
+ 354: {elise} said {i'm always after guala}
+ 355: {ranger} said {yeah and you are not}
+ 356: {Ferris Booth} said {pepperoni pizza}
+ 357: {You} said {You would buy me coffee}
+ 358: {class} said {we miss John}
+ 359: {zz2927} said {zz2927_hello}
+ 360: {Melina} said {your mom}
+ 361: {Melina} said {hi Jessica}
+ 362: {foo\n} said {hi\n}
+ 363: {Keisha} said {Are you happy?}
+ 364: {Keisha} said {Its above me}
+ 365: {amina} said {knsnd}
+ 366: {Pawit} said {Please Work}
+ 367: {ryan's dad} said {what about me?}
+ 368: {Tanvir} said {Good Luck!}
+ 369: {Danelle Tuchman} said {hi, good morning!}
+ 370: {Pawit} said {Does this work?}
+ 371: {John} said {My Queen}
+ 372: {hi} said {hello what's up}
+ 373: {KeunWoo} said {Life is too hard.}
+ 374: {Kaitlyn} said {Hi Claudia !!}
+ 375: {Alexa} said {}
+ 376: {Alexa} said {hi}
+ 377: {karla zuniga} said {forgot my pfirst commen}
+ 378: {Charlie} said {Who hates this class}
+ 379: {Charlie } said {Couldn't be me }
+ 380: {megan} said {i landed on my zipper}
+ 381: {claire} said {hi embyr}
+ 382: {claire} said {i am so short boohoo}
+ 383: {Myst} said {Short Gang Unite}
+ 384: {your mom} said {my mom is hotter then y}
+ 385: {Gil} said {AP is hard}
+ 386: {Gil} said {AP is fun!}
+ 387: {Tajh} said {Hiiiii}
+ 388: {Gil} said {wake me up when}
+ 389: {Gil} said {December ends}
+ 390: {Kelvin} said {hello}
+ 391: {Neev Mistry} said {good neevening}
+ 392: {jimmy} said {i like turtles}
+ 393: {kowala} said {hi}
+ 394: {Matthew Weng} said {This computer thing is }
+ 395: {Matthew Weng} said {not computing.}
+ 396: {Ash} said {Who's that Pok  mon?}
+ 397: {Ash} said {It's Crobat!}
+ 398: {Kent} said {Part 1 (a) is easy.}
+ 399: {monica} said {good luck everyone! :) }
+ 400: {Kavika Krishnan} said {hi everyone}
+ 401: {patrick} said {is mayo an instrument}
+ 402: {kate} said {helloooo}
+ 403: {kate} said {always behind schedule}
+ 404: {Jeannie} said {hi}
+ 405: {Lauren} said {hellooooo}
+ 406: {Gregg} said {Try shellcheck for Bash}
+ 407: {Jessica} said {Melina, whatcha doing}
+ 408: {dantheman} said {i am great}
+ 409: {ADRIANA} said {preachhhhhhhhhh my love}
+ 410: {Jessica} said {hi Preach}
+ 411: {} said {}
+ 412: {ash} said {yo}
+ 413: {Ducky Quackers} said {Ducks rule the world}
+ 414: {korin} said {  \\//// }
+ 415: {korin} said {   |.)(.|  }
+ 416: {korin} said {   | || |  }
+ 417: {korin} said {   \(__)/  }
+ 418: {korin} said {   |-..-|  }
+ 419: {korin} said {   |o\/o|  }
+ 420: {korin} said {   \    /  }
+ 421: {korin} said {   |~~~~|  }
+ 422: {korin} said {   |::::|  }
+ 423: {korin} said {   |::::|  }
+ 424: {korin} said {  (((^^))) }
+ 425: {korin} said {   >>><<<  }
+ 426: {korin} said {   ||||||  }
+ 427: {korin} said {   (o)(o)  }
+ 428: {korin} said {   | /\ |  }
+ 429: {korin} said {   (====)  }
+ 430: {korin} said {   |_/\_|  }
+ 431: {korin} said {   (_/\_)  }
+ 432: {korin} said {  _|_,__|_ }
+ 433: {korin} said { (___\____)}
+ 434: {korin} said {  \\//// }
+ 435: {korin} said {   |.)(.|  }
+ 436: {korin} said {   | || |  }
+ 437: {korin} said {   \(__)/  }
+ 438: {korin} said {   |-..-|  }
+ 439: {korin} said {   |o\/o|  }
+ 440: {korin} said {   \    /  }
+ 441: {korin} said {   |~~~~|  }
+ 442: {korin} said {   |::::|  }
+ 443: {korin} said {   |::::|  }
+ 444: {korin} said {  (((^^))) }
+ 445: {korin} said {   >>><<<  }
+ 446: {korin} said {   ||||||  }
+ 447: {korin} said {   (o)(o)  }
+ 448: {korin} said {   | /\ |  }
+ 449: {korin} said {   (====)  }
+ 450: {korin} said {   |_/\_|  }
+ 451: {korin} said {   (_/\_)  }
+ 452: {korin} said {  _|_,__|_ }
+ 453: {korin} said { (___\____)}
+ 454: {korin} said {  \\//// }
+ 455: {korin} said {   |.)(.|  }
+ 456: {korin} said {   | || |  }
+ 457: {korin} said {   \(__)/  }
+ 458: {korin} said {   |-..-|  }
+ 459: {korin} said {   |o\/o|  }
+ 460: {korin} said {   \    /  }
+ 461: {korin} said {   |~~~~|  }
+ 462: {korin} said {   |::::|  }
+ 463: {korin} said {   |::::|  }
+ 464: {korin} said {  (((^^))) }
+ 465: {korin} said {   >>><<<  }
+ 466: {korin} said {   ||||||  }
+ 467: {korin} said {   (o)(o)  }
+ 468: {korin} said {   | /\ |  }
+ 469: {korin} said {   (====)  }
+ 470: {korin} said {   |_/\_|  }
+ 471: {korin} said {   (_/\_)  }
+ 472: {korin} said {  _|_,__|_ }
+ 473: {korin} said { (___\____)}
+ 474: {frog} said {it's wednesday, my dude}
+ 475: {korin} said {  \\\\//// }
+ 476: {korin} said {   |.)(.|  }
+ 477: {korin} said {   | || |  }
+ 478: {korin} said {   \(__)/  }
+ 479: {korin} said {   |-..-|  }
+ 480: {korin} said {   |o\/o|  }
+ 481: {korin} said {   \    /  }
+ 482: {korin} said {   |~~~~|  }
+ 483: {korin} said {   |::::|  }
+ 484: {korin} said {   |::::|  }
+ 485: {korin} said {  (((^^))) }
+ 486: {korin} said {   >>><<<  }
+ 487: {korin} said {   ||||||  }
+ 488: {korin} said {   (o)(o)  }
+ 489: {korin} said {   | /\ |  }
+ 490: {korin} said {   (====)  }
+ 491: {korin} said {   |_/\_|  }
+ 492: {korin} said {   (_/\_)  }
+ 493: {korin} said {  _|_,__|_ }
+ 494: {korin} said { (___\____)}
+ 495: {korin} said {  \\\\//// }
+ 496: {korin} said {   |.)(.|  }
+ 497: {korin} said {   | || |  }
+ 498: {korin} said {   \(__)/  }
+ 499: {korin} said {   |-..-|  }
+ 500: {korin} said {   |o\/o|  }
+ 501: {korin} said {   \    /  }
+ 502: {korin} said {   |~~~~|  }
+ 503: {korin} said {   |::::|  }
+ 504: {korin} said {   |::::|  }
+ 505: {korin} said {  (((^^))) }
+ 506: {korin} said {   >>><<<  }
+ 507: {korin} said {   ||||||  }
+ 508: {korin} said {   (o)(o)  }
+ 509: {korin} said {   | /\ |  }
+ 510: {korin} said {   (====)  }
+ 511: {korin} said {   |_/\_|  }
+ 512: {korin} said {   (_/\_)  }
+ 513: {korin} said {  _|_,__|_ }
+ 514: {korin} said { (___\____)}
+ 515: {korin} said {  \\\\//// }
+ 516: {korin} said {   |.)(.|  }
+ 517: {korin} said {   | || |  }
+ 518: {korin} said {   \(__)/  }
+ 519: {korin} said {   |-..-|  }
+ 520: {korin} said {   |o\/o|  }
+ 521: {korin} said {   \    /  }
+ 522: {korin} said {   |~~~~|  }
+ 523: {korin} said {   |::::|  }
+ 524: {korin} said {   |::::|  }
+ 525: {korin} said {  (((^^))) }
+ 526: {korin} said {   >>><<<  }
+ 527: {korin} said {   ||||||  }
+ 528: {korin} said {   (o)(o)  }
+ 529: {korin} said {   | /\ |  }
+ 530: {korin} said {   (====)  }
+ 531: {korin} said {   |_/\_|  }
+ 532: {korin} said {   (_/\_)  }
+ 533: {korin} said {  _|_,__|_ }
+ 534: {korin} said { (___\____)}
+ 535: {danield} said {hi hiii omg hii        }
+ 536: {Melina} said {Jessica, your dad}
+ 537: {Suwei} said {Hello}
+ 538: {karla } said {helooloooooo}
+ 539: {will} said {will rocks}
+ 540: {James} said {Hiiiiiiiiiiiii!}
+ 541: {lexa} said {i took the wock to pola}
+ 542: {lexa} said {i took the woooooooock}
+ 543: {lexa} said {to poland}
+ 544: {abenezer} said {who took the wock to po}
+ 545: {abenezer} said {what's good?}
+ 546: {abenzer   ezer} said {my beautiful people!}
+ 547: {kid named finge} said {waltuhhhh}
+ 548: {Hezzy} said {Midterm in 3 weeks :)}
+ 549: {   } said {   }
+ 550: {you} said {me}
+ 551: {Allen} said {This is interesting}
+ 552: {Peter} said {im hungry}
+ 553: {123456789012345} said {test}
+ 554: {valentino} said {-2 late days}
+ 555: {William} said {Lab4 is so hard!!}
+ 556: {billybool} said {#1 dj in the whole plan}
+ 557: {haunted mound} said {hauntoholics... real ha}
+ 558: {Lola} said {something}
+ 559: {Lola} said {559}
+ 560: {soundcloud.com/} said {pwittyboyclub}
+ 561: {Emily} said {I want to sleep}
+ 562: {nobody} said {odysseus}
+ 563: {some student} said {}
+ 564: {Chris} said {Can we all survive?}
+ 565: {Charis} said {goodnight}
+ 566: {cs tutor} said {we are going to dadada}
+ 567: {Cecilia} said {Fighting!}
+ 568: {Conan} said {Habara is cute}
+ 569: {Qazi} said {well i hope i can pass}
+ 570: {Doga} said {Hello}
+ 571: {Doga} said {Goodnight}
+ 572: {Qazi} said {hello}
+ 573: {Qazi} said {how is it going}
+ 574: {Rengoku} said {set your heat ablaze}
+ 575: {Ahmad} said {Learning is great!}
+ 576: {Ahmad} said {Columbia University is }
+ 577: {Anran} said {great class}
+ 578: {Eowyn} said {I am no man}
+ 579: {Nguyen Tran} said {something cool}
+ 580: {Demon time} said {shawty wyd, u up ?}
+ 581: {Rene Sultan} said {Hi}
+ 582: {Joe} said {this thing works}
+ 583: {Joe} said {hmm}
+ 584: {humanity} said {Can Kanye please stop?}
+ 585: {every teenager} said {Sisyphus is happy}
+ 586: {whale} said {hello}
+ 587: {dolphin} said {goodbye}
+ 588: { harry potter} said { i can't be a wizard, i}
+ 589: {draco malfoy} said {the forest? i thought t}
+ 590: {Nandini} said {Jae Woo Bee Buzz Buzz}
+ 591: {Boris} said {Dogs are better}
+ 592: {Boris} said {than people}
+ 593: {Boris} said {I finally figured out}
+ 594: {Boris} said {How to use this}
+ 595: {Boris} said {Coding is hard}
+ 596: {Logan } said {you go glenn coco}
+ 597: {Bob the Builder} said {Can he fix my grades?}
+ 598: {Shivam S.} said {columbia dining is good}
+ 599: {andreas} said {hey guys this is andrea}
+ 600: {Jessica} said {noooooooooooooooo}
+ 601: {Jessica} said {Melina, how could you}
+ 602: {Fatoumata Camar} said {**I hope you have an am}
+ 603: {Theo} said {Friends, Romans, Countr}
+ 604: {Google} said {You Got This}
+ 605: {Erick} said {TestTestTest}
+ 606: {Evelyn} said {everything will be grea}
+ 607: {Evelyn} said {cheesepizza}
+ 608: {Rene} said {Hi}
+ 609: {Lana} said {hey friends how are you}
+ 610: {Lana} said {wow i love cs the TAs a}
+ 611: {Lana} said {Wow aren't the TAs so c}
+ 612: {Lana} said {Stop truncating me}
+ 613: {haha} said {i hate you}
+ 614: {Mr. Pink} said {Am I the only professio}
+ 615: {teehee} said {i love you}
+ 616: {heart} said {power}
+ 617: {No thank you} said {Can I get a '\n' ?}
+ 618: {Isaiah} said {When will I catch up?}
+ 619: {siggi} said {hi}
+ 620: {Nova} said {Amogus    }
+ 621: {girlboss} said {servec*ntordie}
+ 622: {suba} said {yayyy :)}
+ 623: {SLAYYYY} said {HALLOWEEKEN}
+ 624: {cx} said {hello cs3157!}
+ 625: {suba} said {\(*^ ^*)/}
+ 626: {helpme} said {sosad}
+ 627: {hfauwf} said {dfghjk}
+ 628: {kjhg} said {jhgffghjhgffgh}
+ 629: {heisenberg} said {knock knock}
+ 630: {katie} said {hi gracee}
+ 631: {Kyle} said {Hello I'm Kyle}
+ 632: {Kyle} said {Hello This is Part a}
+ 633: {test} said {hello world}
+ 634: {Lauren} said {thank u TAs!}
+ 635: {Han} said {hi this is han}
+ 636: {Han Choi} said {this is a very very lon}
+ 637: {Omar Kammourieh} said {i need a cowboy hat b4 }
+ 638: {Omar Kammourieh} said {tomorrow}
+ 639: {hannah h} said {time to start lab 4!}
+ 640: {fdisfijdfiopjsa} said {fdnsuihfudsahfiuhdasufh}
+ 641: {fjdiosajfiodasj} said {fdnasfnidsjhfiodashfiod}
+ 642: {123451234512345} said {12345123451234512345123}
+ 643: {12345} said {12345}
+ 644: {Kaan E.} said {Hello Theree!}
+ 645: {superkaanmessi} said {hi ap}
+ 646: {Jeff} said {this is neat}
+ 647: {Jeff again} said {man 23 chars is not eno}
+ 648: {Lets play chess} said {1... e5}
+ 649: {everyone} said {anya solos}
+ 650: {anya} said {waku waku}
+ 651: {Karem} said {Late as usual to this.}
+ 652: {Karem} said {Thank God I wasn't the }
+ 653: {Karem} said {- the 666 entry :) }
+ 654: {Inigo Motoya} said {you killed my father}
+ 655: {Karem} said {no, I'm not a murderer}
+ 656: {mariam} said {hello}
+ 657: {} said {}
+ 658: {Rohan} said {Loves C/C++ programming}
+ 659: {Barry} said {Ya like jazz?}
+ 660: {Barry} said {Ya like jazz?}
+ 661: {Barry} said {Ya like jazz?}
+ 662: {Barry} said {Ya like jazzzz?}
+ 663: {Kynnedy Simone} said {spooky scary skeletons}
+ 664: {Willi Brandt} said {I probably started too }
+ 665: {Dave Matthews} said {Rock on brother}
+ 666: {who} said {who said ur not perfect}
+ 667: {the world} said {thanks miley}
+ 668: {asdf movie} said {here, hold this}
+ 669: {} said {}
+ 670: {Seyoung} said {idk}
+ 671: {Seyoung} said {this is so cool!}
+ 672: {alicia yang} said {hello!}
+ 673: {Heidi} said {Welcome to AP!!}
+ 674: {Test Name} said {Test Message}
+ 675: {testtestname} said {testtestmessage}
+ 676: {jonno} said {rosen }
+ 677: {alexkoletsos} said {wesley the weissel, hi.}
+ 678: {alex krylov} said {bryce wold series mvp}
+ 679: {alex krylov} said {josh nam is the man}
+ 680: {katie} said {heyyyy}
+ 681: {Katherine} said {hello everyone!!}
+ 682: {Katherine} said {hmmmmm....}
+ 683: {will} said {go columbia!}
+ 684: {annika} said {hi!!}
+ 685: {keir} said {dogs are cool}
+ 686: {keir} said {happy halloween}
+ 687: {Rene} said {John's OH}
+ 688: {Bereket } said {experimental}
+ 689: {jax_king} said {hello cs3157}
+ 690: {minh} said {coding in Bostoon}
+ 691: {Woojin Son} said {Can I survive?}
+ 692: {Woojin Son} said {I just wanna pass this }
+ 693: {Woojin Son} said {class}
+ 694: {Roey} said {John's OH signup}
+ 695: {123456789012345} said {12345678901234567890123}
+ 696: {Woojin} said {test!!}
+ 697: {Woojin Son} said {Oct 28th, 2022 Hello!}
+ 698: {Da Hoon Oh} said {Hello!}
+ 699: {Byeolah} said {john's oh}
+ 700: {hari bhimaraju} said {i love dear mama}
+ 701: {elaine } said {it is good weather toda}
+ 702: {Chris} said {why only lookup once?}
+ 703: {elaine} said {halloween}
+ 704: {Alana Greenaway} said {I have a dog named Stan}
+ 705: {Alana Greenaway} said {I love programming!}
+ 706: {Alana Greenaway} said {I'm from Boston}
+ 707: {1234} said {1234}
+ 708: {PoTing Chen} said {live is arduous}
+ 709: {Fatoumata Camar} said {Hello :)))}
+ 710: {Sreya} said {What is your costume?}
+ 711: {Fatoumata Camar} said {It worked slayy!}
+ 712: {Sreya} said {AP is so fun!}
+ 713: {Emily Ye} said {dugtrio has beautiful h}
+ 714: {Emily Ye} said {veggies scream}
+ 715: {vincentr  [C   } said {hello}
+ 716: {kulkarni} said {hello mdb!}
+ 717: {kulkarni} said {iamacademicallyhonest}
+ 718: {kulkarni} said {theworldisending}
+ 719: {kulkarni} said {iliketrains}
+ 720: {Sreya} said {Hello Hi Hody}
+ 721: {kate} said {hi}
+ 722: {Josh Nam} said {Yale ML}
+ 723: {Josh Nam} said {I like books}
+ 724: {Alicia} said {hello}
+ 725: {Alex Michelon} said {:)}
+ 726: {nicole} said {anti-ti-ti-ti fragile}
+ 727: {Johnny C} said {if you love something}
+ 728: {Johnny C} said {set it free}
+ 729: {Johnny C} said {If it comes back}
+ 730: {Johnny C} said {You've failed valgrind}
+ 731: {Johnny C} said {Friends don't let frien}
+ 732: {Johnny C} said {reference pointers}
+ 733: {Riley} said {is the funniest}
+ 734: {Riley} said {catch me outside}
+ 735: {piers} said {im prob using a late da}
+ 736: {LILAH} said {LILAH was here}
+ 737: {LILAH} said {i am very hungry}
+ 738: {Johhny C} said {They have no seg faults}
+ 739: {Johnny C} said {but they don't know}
+ 740: {Johnny C} said {how to exit a loop?}
+ 741: {testtt} said {testing database}
+ 742: {studenttt} said {ap is fun}
+ 743: {bobert} said {I am bobert}
+ 744: {Eric Kim} said {Hi this is my message f}
+ 745: {f} said {f}
+ 746: {potato} said {I am a potato}
+ 747: {Jlam} said {Happy halloween!}
+ 748: {Jake} said {This is Ken}
+ 749: {Hodor} said {Hold the door!}
+ 750: {Matt} said {Good Luck Everyone!}
+ 751: {Mike} said {Waltuh }
+ 752: {Jimmy} said {Better Call Saul!}
+ 753: {kate} said {test}
+ 754: {Avery} said {(pp   [C [C [D [C [C [C}
+ 755: {Ac very} said {(T^T)}
+ 756: {Avery} said {failing fundies exam}
+ 757: {} said {}
+ 758: {Gordon Freeman} said {...............}
+ 759: {Bad friend} said {a can of beer will be o}
+ 760: {Guillermo} said {Hello}
+ 761: {Obi Wan} said {Hello there!}
+ 762: {Yuya} said {Happy Halloween!}
+ 763: {Yuya} said {hewwo :)}
+ 764: {Grievous} said {General Kenobi!}
+ 765: {Steven Wang} said {i <3 you}
+ 766: {Steven Wang} said {-^_^-}
+ 767: {Kristine Pham} said {I want pork buns}
+ 768: {Arman} said {I procrastinated this s}
+ 769: {kuchbenarman} said {hail the king}
+ 770: {ohh} said {gonna use late days...}
+ 771: {markus tran} said {oh no oh no oh no}
+ 772: {Shrek} said {Get out of my swamp!}
+ 773: {brian} said {hello wordle}
+ 774: {gaston} said {pushups are easy}
+ 775: {binarytree} said {inverse me please}
+ 776: {Aaron} said {On law, morality, and p}
+ 777: {Andrew} said {My name is AC}
+ 778: {hank azaria} said {i am homer from simpson}
+ 779: {I knew it was 1} said {I knew it was 1216. One}
+ 780: {} said {} said {} said {}
+ 781: {he} said {she} said {}
+ 782: {testinngggggggg} said {tetstetestetetettetetes}
+ 783: {darth vader} said {i aint got no son}
+ 784: {friday night} said {tgid f}
+ 785: {xiaolaohu} said {I will eat the cs3157 s}
+ 786: {Song} said {Hello! Goodbye and Hell}
+ 787: {} said {}
+ 788: {vincent} said {yo}
+ 789: {vincent     } said {hello}
+ 790: {Naomi} said {hello}
+ 791: {Cat} said {bye}
+ 792: {most fun} said {class -AP <3}
+ 793: {Class } said {Cameria for TA}
+ 794: {^^} said {^_^ <3}
+ 795: {who is} said {Johnny C}
+ 796: {Wonkers} said {Hi Zoe}
+ 797: {JP Morggy} said {mmm finance}
+ 798: {Yonseung Choi} said {Lab Workflow}
+ 799: {catarina coelho} said {oieee}
+ 800: {catarina coelho} said {22 days for the world c}
+ 801: {catarina coelho} said {vai brasil uhu}
+ 802: {king} said {K}
+ 803: {erica} said {testing 123}
+ 804: {Erica} said {10:39 on a Saturday in }
+ 805: {Dale Yu} said {Should've started this }
+ 806: {Dale Yu} said {Nguyen Tran Brawlstars }
+ 807: {I love John Hui} said {I love John Hui <3}
+ 808: {Dale Yu} said {I love John Hui <3}
+ 809: {Justin Bieber} said {Baaayby}
+ 810: {Shifu } said {Dragon Warrior!!!}
+ 811: {She said} said {That's what}
+ 812: {Dhwani} said {Happy Halloween!}
+ 813: {Joseph Han} said {Explaining the undexpla}
+ 814: {kyz2005} said {hi}
+ 815: {Merry} said {I love your island <3}
+ 816: {Blissey} said {My eggs are going bad..}
+ 817: {} said {      }
+ 818: {yassuo} said {alreadylate!!}
+ 819: {Joseph Han} said {IS the size always mult}
+ 820: {Khadija} said {using add database}
+ 821: {Jacklyn} said {Hi Jessica <3}
+ 822: {Jacklyn} said {Hi Preach <3}
+ 823: {Jacklyn} said {Hi Melina <3}
+ 824: {Jacklyn} said {Hi Annika <3}
+ 825: {Jane} said {Hi!}
+ 826: {Jacklyn } said {Hello Dhwani <3}
+ 827: {Mr. Brown} said {Mr. Brown says like Mr.}
+ 828: {Annika} said {Hi Jacklyn!}
+ 829: {Bailey} said {I walked UWS w/ bat win}
+ 830: {Wilbur } said {Grrr}
+ 831: {Khadija} said {still working}
+ 832: {Yongcen Zhou} said {let's start lab4}
+ 833: {} said {}
+ 834: {Heon Kim} said {hello world}
+ 835: {Heon} said {hihihihihihihi}
+ 836: {Kristine Pham} said {I want ice cream}
+ 837: {Chase} said {NFTs}
+ 838: {rick} said {never gonna give you up}
+ 839: {rick} said {never gonna let you dow}
+ 840: {rick} said {never gonna run around }
+ 841: {ava} said {messagetesting}
+ 842: {jean} said {uhedjhabs}
+ 843: {Carlos} said {Dr. Strange}
+ 844: {kynnedy} said {yay AP!}
+ 845: {Iron Man} said {I'm the best.}
+ 846: {test} said {12345678901234567890123}
+ 847: {Soomin Kim} said {have a nice day}
+ 848: {The Joker} said {We live in a society}
+ 849: {I} said {We really do live in a }
+ 850: {Art Vandelay} said {Importer/Exporter}
+ 851: {George C.} said {I'm shifting into soup }
+ 852: {I} said {society}
+ 853: {Newman} said {To the Newmanium!}
+ 854: {Cosmo Kramer} said {To the Kramanium!}
+ 855: {avighna} said {helloooo <3}
+ 856: {Frank C.} said {I wear sneakers in the }
+ 857: {avighna} said {hello kitty}
+ 858: {Theo} said {is cool}
+ 859: {pru} said {hello there :)}
+ 860: {grunt} said {nap time}
+ 861: {Sophia} said {hello}
+ 862: {K} said {K}
+ 863: {Kanavi} said {Loveya}
+ 864: {Nobody} said {e   [C [C    [Ccoding  }
+ 865: {jas} said {it is not a happy satur}
+ 866: {john hui} said {-john}
+ 867: {Paul} said {2 Late Days Gone sigh.}
+ 868: {Luigi} said {Truly, it is worse.}
+ 869: {Dan} said {Interesting}
+ 870: {Nick} said {I start too late}
+ 871: {Amin} said {WAZZZUUUPPP}
+ 872: {Jennifer Huang} said {Waddup shawty}
+ 873: {Jennifer Huang} said {if ur bald, where does }
+ 874: {Jennifer Huang} said {ur forehead end ?}
+ 875: {Luke Xue} said {I'm eating dinner}
+ 876: {john} said {welcome to sp}
+ 877: {Erica} said {8:54 on Sat still here}
+ 878: {ur mom} said {hello son}
+ 879: {brianna} said {i want ice cream}
+ 880: {jtrf} said {London}
+ 881: {Guy} said {trick or treat!}
+ 882: {Germ} said {hello}
+ 883: {Bereket} said {Hi everyone!}
+ 884: {Shahana} said {Hi!}
+ 885: {Shahana} said {Cats are superior being}
+ 886: {Rohan} said {I love you}
+ 887: {Rohan } said {It is a hard assignment}
+ 888: {Crobat} said {Nasty Plot set is best}
+ 889: {kaylee} said {happy halloween}
+ 890: {everyone} said {i love sleep}
+ 891: {Hae Myung Yim} said {Good Life}
+ 892: {Khadija} said {checking}
+ 893: {Isayama} said {za worldou}
+ 894: {nira} said {:) <3}
+ 895: {Chase} said {NFTs are cool}
+ 896: {eevee} said {i was very sick}
+ 897: {he he} said {yoyoyo}
+ 898: {evan} said {I want brunch}
+ 899: {User 1} said {Automated message.}
+ 900: {Melody} said {Happy Halloween}
+ 901: {Gillian} said {Finished Lab4!}
+ 902: {} said {}
+ 903: {\n} said {\0}
+ 904: {'\n'} said {'\0'}
+ 905: {null} said {NULL}
+ 906: {Lexis} said {Happy Halloweekenddd}
+
+lookup:  863: {Kanavi} said {Loveya}
+
+lookup: ==201254== 
+==201254== HEAP SUMMARY:
+==201254==     in use at exit: 0 bytes in 0 blocks
+==201254==   total heap usage: 1,816 allocs, 1,816 frees, 60,936 bytes allocated
+==201254== 
+==201254== All heap blocks were freed -- no leaks are possible
+==201254== 
+==201254== For lists of detected and suppressed errors, rerun with: -s
+==201254== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index fa5bf71..9d9d420 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -4,11 +4,11 @@
 #include "mdb.h"
 #include <string.h>
 
-    void printRec(void *rec){
-        struct MdbRec *record = (struct MdbRec *) rec;
-        printf("This is the name: %s\n",(const char *)record->name);
-        printf("This is the message: %s\n",(const char *)record->msg);        
-    }
+void printRec(void *rec){
+    struct MdbRec *record = (struct MdbRec *) rec;
+    printf("This is the name: %s\n",(const char *)record->name);
+    printf("This is the message: %s\n",(const char *)record->msg);        
+}
 
 int main(int argc, char **argv) {
     /*
@@ -28,15 +28,15 @@ int main(int argc, char **argv) {
     }
 
     struct List list;
+  
     initList(&list);
 
     /*
-     * Read the file line-by-line, printing out line numbers as we go.
+     * Read the file line-by-line, copying line numbers into a list as we go.
      */
 
     // Define a buffer we will read each line into.
-   
-    
+     
     size_t size = sizeof(struct MdbRec);
     char buf[size];   
     int len;
@@ -44,7 +44,9 @@ int main(int argc, char **argv) {
     while((len = fread(buf, 1, size, fp)) > 0) {
          
        if(len != (int) size ){
-           perror("Didn't read enough bytes!");
+           perror("The size of this database file is not a multiple of 40!");
+           traverseList(&list, &free);
+           removeAllNodes(&list);
            exit(1);
        }
        // char name[16];
@@ -55,23 +57,26 @@ int main(int argc, char **argv) {
         struct MdbRec *record = malloc(size);
         if(record == NULL){
             perror("malloc returned NULL");
+            traverseList(&list, &free);
+            removeAllNodes(&list);
             exit(1);
         }
            
         memcpy(record->name,  buf, 16);
         memcpy(record->msg, buf + 16, 24);
-       
-      
+        
         
         prev = addAfter(&list, prev, record); 
         if(prev == NULL){
-            perror("Couldn't add after!");
+            perror("Couldn't add the next data in!");
+            traverseList(&list, &free);
+            removeAllNodes(&list);
             exit(1);
         } 
     }
 
     /*
-     * Did we terminate the fgets() loop because of an error?
+     * Did we terminate the fread() loop because of an error?
      * If so, report the error.
      */
 
@@ -80,18 +85,21 @@ int main(int argc, char **argv) {
         exit(1);
     }
 
+    fclose(fp);
+
     // traverseList(&list, &printRec);
     
+    // printf("%s\n", buf);
+    
     
-   // printf("%s\n", buf);
-    printf("lookup: ");
     
-    int n = 7; 
-    char buf2[n];
+    char buf2[500];
      
+    printf("lookup: ");
+
     while(fgets(buf2, sizeof(buf2), stdin)){
-        int sizeOfString;
-        
+       
+        int sizeOfString; 
        // printf("This the buffer before: %s\n", buf2);
         
         if(strlen(buf2)<=6){
@@ -119,42 +127,32 @@ int main(int argc, char **argv) {
             struct MdbRec *record;
             while(curr != NULL){
                 record = (struct MdbRec *) curr->data;
-               // printf("The name: %s\n",record->name);  
-               // printf("The msg: %s\n",record->msg);
+                // printf("The name: %s\n",record->name);  
+                // printf("The msg: %s\n",record->msg);
 
                 if(strstr(record->name,string) != NULL){
                     printf("%4d: {%s} said {%s}\n",lineno, record->name, record->msg);
                 }else if(strstr(record->msg,string) != NULL){
-                    printf("%4d: {%s} said  {%s}\n",lineno, record->name, record->msg);
+                    printf("%4d: {%s} said {%s}\n",lineno, record->name, record->msg);
                 }
                  
                 lineno++;
                 curr = curr->next;
         }
-            printf("\n");
 
-  
+    printf("\nlookup: ");
+   
+    // fseek(stdin, 0, SEEK_END);   
    
-    printf("lookup: ");
-    
-    
-   // fseek(stdin, 0, SEEK_END);   
-
     }
-
     
+    traverseList(&list, &free);
+    removeAllNodes(&list);   
 
     if (ferror(stdin)) {
-        perror("There was an error in stdin");
+        perror("There was an error in stdin.");
         exit(1);
     }
 
-    traverseList(&list, &free);
-    removeAllNodes(&list);
-    /*
-     * Close our file pointer, and quit.
-     */
-
-    fclose(fp);
     return 0;
 }
-- 
2.34.1


--QawcFD8xKR5FIQzb
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab4.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom b17121dde3b7fc8d739d268096e2b08834e5a834 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Thu, 27 Oct 2022 21:38:28=
 -0400=0ASubject: [PATCH 1/7] Committed README.txt for the first time=0A=0A=
---=0A README.txt | 6 +++---=0A 1 file changed, 3 insertions(+), 3 deletion=
s(-)=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 49c4472..d342eb7 100=
644=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -1,8 +1,8 @@=0A This file sh=
ould contain:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment nu=
mber=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab4=0A   - description for ea=
ch part=0A =0A The description should indicate whether your solution for th=
e part is=0A-- =0A2.34.1=0A=0A=0AFrom 76ad4ca0ffc83feb4f43cfaf0393286362733=
83e Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADa=
te: Sat, 29 Oct 2022 00:26:32 -0400=0ASubject: [PATCH 2/7] Started writing =
three files, haven't started the lookup=0A loop yet.=0A=0A---=0A part1/Make=
file     | 15 +++++++++=0A part1/mdb-lookup.c | 80 ++++++++++++++++++++++++=
++++++++++++++++++++++=0A part1/mdb.h        |  5 +++=0A 3 files changed, 1=
00 insertions(+)=0A create mode 100644 part1/Makefile=0A create mode 100644=
 part1/mdb-lookup.c=0A create mode 100644 part1/mdb.h=0A=0Adiff --git a/par=
t1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 0000000..5352fc=
f=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,15 @@=0A+CC =3D gcc=
=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17 -I/home/j-hui/cs3157-pub/incl=
ude=0A+=0A+LDFLAGS =3D -L/home/j-hui/cs3157-pub/lib=0A+LDLIBS =3D -lmylist=
=0A+=0A+mdb-lookup: mdb-lookup.o=0A+mdb-lookup.o: mdb-lookup.c mdb.h=0A+=0A=
+.PHONY: clean=0A+clean:=0A+	rm -f *.o *~ a.out core mdb-lookup=0A+=0A+.PHO=
NY: all=0A+all: clean mdb-lookup=0Adiff --git a/part1/mdb-lookup.c b/part1/=
mdb-lookup.c=0Anew file mode 100644=0Aindex 0000000..6a64712=0A--- /dev/nul=
l=0A+++ b/part1/mdb-lookup.c=0A@@ -0,0 +1,80 @@=0A+#include <stdio.h>=0A+#i=
nclude <stdlib.h>=0A+#include <mylist.h>=0A+#include "mdb.h"=0A+#include <s=
tring.h>=0A+=0A+    void printRec(void *rec){=0A+        struct MdbRec *rec=
ord =3D (struct MdbRec *) rec;=0A+        printf("This is the name: %s\n",(=
const char *)record->name);=0A+        printf("This is the message: %s\n",(=
const char *)record->msg);        =0A+    }=0A+=0A+int main(int argc, char =
**argv) {=0A+    /*=0A+     * Open file whose name is given by argv[1].=0A+=
     */=0A+=0A+    if (argc !=3D 2) {=0A+        fprintf(stderr, "%s\n", "u=
sage: mdb-lookup <database-file-name>");=0A+        exit(1);=0A+    }=0A+=
=0A+    char *filename =3D argv[1];=0A+    FILE *fp =3D fopen(filename, "r"=
);=0A+    if (fp =3D=3D NULL) {=0A+        perror(filename);=0A+        exi=
t(1);=0A+    }=0A+=0A+    struct List list;=0A+    initList(&list);=0A+=0A+=
    /*=0A+     * Read the file line-by-line, printing out line numbers as w=
e go.=0A+     */=0A+=0A+    // Define a buffer we will read each line into.=
=0A+   =0A+    =0A+    size_t size =3D sizeof(struct MdbRec);=0A+    char b=
uf[size];   =0A+    =0A+    struct Node *prev =3D NULL;  =0A+    while(frea=
d(buf, 1, size, fp) > 0) {=0A+       // char name[16];=0A+       // char ms=
g[24];=0A+       // memcpy(name, buf, 16 );=0A+       // memcpy(msg, (buf +=
 16), 24);=0A+        =0A+        struct MdbRec *record =3D malloc(size);=
=0A+        memcpy(record->name,  buf, 16);=0A+        memcpy(record->msg, =
buf + 16, 24);=0A+       =0A+      =0A+        =0A+        prev =3D addAfte=
r(&list, prev, record);=0A+       =0A+    }=0A+=0A+    /*=0A+     * Did we =
terminate the fgets() loop because of an error?=0A+     * If so, report the=
 error.=0A+     */=0A+=0A+    if (ferror(fp)) {=0A+        perror(filename)=
;=0A+        exit(1);=0A+    }=0A+=0A+    traverseList(&list, &printRec);=
=0A+    traverseList(&list, &free);=0A+    removeAllNodes(&list);=0A+    /*=
=0A+     * Close our file pointer, and quit.=0A+     */=0A+=0A+    fclose(f=
p);=0A+    return 0;=0A+}=0A+=0Adiff --git a/part1/mdb.h b/part1/mdb.h=0Ane=
w file mode 100644=0Aindex 0000000..ab23bf3=0A--- /dev/null=0A+++ b/part1/m=
db.h=0A@@ -0,0 +1,5 @@=0A+struct MdbRec {=0A+            char name[16];=0A+=
            char  msg[24];=0A+};=0A+=0A-- =0A2.34.1=0A=0A=0AFrom 74106f310e=
5820b4bb13172dac75bfdbbaa5b28f Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan=
 <ao2794@columbia.edu>=0ADate: Sat, 29 Oct 2022 04:33:49 -0400=0ASubject: [=
PATCH 3/7] Started the user input part of the part1. Wrote the fgets=0A whi=
le loop and key detection.=0A=0A---=0A part1/mdb-lookup.c | 71 ++++++++++++=
+++++++++++++++++++++++++++++++---=0A 1 file changed, 67 insertions(+), 4 d=
eletions(-)=0A=0Adiff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Aind=
ex 6a64712..a42ed64 100644=0A--- a/part1/mdb-lookup.c=0A+++ b/part1/mdb-loo=
kup.c=0A@@ -39,22 +39,35 @@ int main(int argc, char **argv) {=0A     =0A   =
  size_t size =3D sizeof(struct MdbRec);=0A     char buf[size];   =0A-    =
=0A+    int len;=0A     struct Node *prev =3D NULL;  =0A-    while(fread(bu=
f, 1, size, fp) > 0) {=0A+    while((len =3D fread(buf, 1, size, fp)) > 0) =
{=0A+         =0A+       if(len !=3D (int) size ){=0A+           perror("Di=
dn't read enough bytes!");=0A+           exit(1);=0A+       }=0A        // =
char name[16];=0A        // char msg[24];=0A        // memcpy(name, buf, 16=
 );=0A        // memcpy(msg, (buf + 16), 24);=0A         =0A         struct=
 MdbRec *record =3D malloc(size);=0A+        if(record =3D=3D NULL){=0A+   =
         perror("malloc returned NULL");=0A+            exit(1);=0A+       =
 }=0A+           =0A         memcpy(record->name,  buf, 16);=0A         mem=
cpy(record->msg, buf + 16, 24);=0A        =0A       =0A         =0A-       =
 prev =3D addAfter(&list, prev, record);=0A-       =0A+        prev =3D add=
After(&list, prev, record); =0A+        if(prev =3D=3D NULL){=0A+          =
  perror("Couldn't add after!");=0A+            exit(1);=0A+        } =0A  =
   }=0A =0A     /*=0A@@ -68,6 +81,56 @@ int main(int argc, char **argv) {=
=0A     }=0A =0A     traverseList(&list, &printRec);=0A+    =0A+    =0A+   =
// printf("%s\n", buf);=0A+    printf("lookup: ");=0A+    =0A+=0A+    char =
buf2[500];=0A+   =0A+    while(fgets(buf2, sizeof(buf2), stdin)){=0A+      =
  int sizeOfString;=0A+=0A+        if(strlen(buf2)<6){=0A+            sizeO=
fString =3D strlen(buf2);=0A+        }else{=0A+            sizeOfString =3D=
 6;=0A+        }=0A+        char string[sizeOfString];=0A+          =0A+   =
     strncpy(string, buf2, sizeOfString-1);=0A+        string[sizeOfString-=
1] =3D '\0';=0A+        =0A+        printf("The key is: %s\n",string);=0A+ =
       =0A+            =0A+            struct Node *curr =3D (struct Node*)=
 (&list)->head;=0A+            =0A+            struct MdbRec *record;=0A+  =
          while(curr !=3D NULL){=0A+                record =3D (struct MdbR=
ec *) curr->data;=0A+                printf("The name: %s\n",record->name);=
  =0A+                printf("The msg: %s\n",record->msg);=0A+=0A+         =
       if(strstr(record->name,string) !=3D NULL){=0A+                    pr=
intf("The common part is: %s\n",strstr(record->name,string));=0A+          =
      }=0A+=0A+                if(strstr(record->msg,string) !=3D NULL){=0A=
+                     printf("The common part is: %s\n",strstr(record->msg,=
string));=0A+                }=0A+                curr =3D curr->next;=0A+ =
       }=0A+=0A+=0A+       =0A+    }=0A+=0A+    =0A+=0A+=0A+=0A     travers=
eList(&list, &free);=0A     removeAllNodes(&list);=0A     /*=0A-- =0A2.34.1=
=0A=0A=0AFrom bacbc162e88a8cf3a4538f2efe25eabf9cef1558 Mon Sep 17 00:00:00 =
2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 29 Oct 2022 18:=
16:04 -0400=0ASubject: [PATCH 4/7] Still working on input-taking. Have to c=
orrect the issue=0A that happens when the buffer size is exceeded.=0A=0A---=
=0A part1/mdb-lookup.c | 30 ++++++++++++++++++------------=0A 1 file change=
d, 18 insertions(+), 12 deletions(-)=0A=0Adiff --git a/part1/mdb-lookup.c b=
/part1/mdb-lookup.c=0Aindex a42ed64..077b890 100644=0A--- a/part1/mdb-looku=
p.c=0A+++ b/part1/mdb-lookup.c=0A@@ -86,9 +86,9 @@ int main(int argc, char =
**argv) {=0A    // printf("%s\n", buf);=0A     printf("lookup: ");=0A     =
=0A-=0A-    char buf2[500];=0A-   =0A+    =0A+    char buf2[50];=0A+     =
=0A     while(fgets(buf2, sizeof(buf2), stdin)){=0A         int sizeOfStrin=
g;=0A =0A@@ -106,25 +106,31 @@ int main(int argc, char **argv) {=0A        =
 =0A             =0A             struct Node *curr =3D (struct Node*) (&lis=
t)->head;=0A-            =0A+            int lineno =3D 1;=0A             s=
truct MdbRec *record;=0A             while(curr !=3D NULL){=0A             =
    record =3D (struct MdbRec *) curr->data;=0A-                printf("The=
 name: %s\n",record->name);  =0A-                printf("The msg: %s\n",rec=
ord->msg);=0A+               // printf("The name: %s\n",record->name);  =0A=
+               // printf("The msg: %s\n",record->msg);=0A =0A             =
    if(strstr(record->name,string) !=3D NULL){=0A-                    print=
f("The common part is: %s\n",strstr(record->name,string));=0A-             =
   }=0A-=0A-                if(strstr(record->msg,string) !=3D NULL){=0A-  =
                   printf("The common part is: %s\n",strstr(record->msg,str=
ing));=0A+                    printf("%4d: {%s} said {%s}\n",lineno, record=
->name, record->msg);=0A+                }else if(strstr(record->msg,string=
) !=3D NULL){=0A+                    printf("%4d: {%s} said  {%s}\n",lineno=
, record->name, record->msg);=0A                 }=0A+                 =0A+=
                lineno++;=0A                 curr =3D curr->next;=0A       =
  }=0A+            printf("\n");=0A =0A+    printf("This is what buffer loo=
ks like: %s\n", buf2);=0A+   =0A+    printf("lookup: ");=0A+    =0A+    =0A=
+    //fseek(stdin, 0, SEEK_SET);   =0A =0A-       =0A     }=0A =0A     =0A=
-- =0A2.34.1=0A=0A=0AFrom c4a0a52c7d130a8303b52aa0f044c04ff1f6f44a Mon Sep =
17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 29 =
Oct 2022 19:09:52 -0400=0ASubject: [PATCH 5/7] I think I finally can receiv=
e arbitrarily long input.=0A=0A---=0A part1/mdb-lookup.c | 24 +++++++++++++=
+++++------=0A 1 file changed, 18 insertions(+), 6 deletions(-)=0A=0Adiff -=
-git a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Aindex 077b890..3fc64e2 100=
644=0A--- a/part1/mdb-lookup.c=0A+++ b/part1/mdb-lookup.c=0A@@ -86,13 +86,1=
5 @@ int main(int argc, char **argv) {=0A    // printf("%s\n", buf);=0A    =
 printf("lookup: ");=0A     =0A-    =0A-    char buf2[50];=0A+    int n =3D=
 10; =0A+    char buf2[n];=0A      =0A     while(fgets(buf2, sizeof(buf2), =
stdin)){=0A         int sizeOfString;=0A-=0A-        if(strlen(buf2)<6){=0A=
+        =0A+        printf("This the buffer before: %s\n", buf2);=0A+     =
   =0A+        if(strlen(buf2)<=3D5){=0A             sizeOfString =3D strle=
n(buf2);=0A         }else{=0A             sizeOfString =3D 6;=0A@@ -103,7 +=
105,14 @@ int main(int argc, char **argv) {=0A         string[sizeOfString-=
1] =3D '\0';=0A         =0A         printf("The key is: %s\n",string);=0A+ =
 =0A         =0A+        while(buf2[strlen(buf2)-1] !=3D '\n' ){=0A+       =
     fgets(buf2, sizeof(buf2),stdin);=0A+        }=0A+=0A+       =0A+      =
  printf("This is the buffer after: %s\n", buf2);=0A             =0A       =
      struct Node *curr =3D (struct Node*) (&list)->head;=0A             in=
t lineno =3D 1;=0A@@ -124,7 +133,7 @@ int main(int argc, char **argv) {=0A =
        }=0A             printf("\n");=0A =0A-    printf("This is what buff=
er looks like: %s\n", buf2);=0A+  =0A    =0A     printf("lookup: ");=0A    =
 =0A@@ -135,7 +144,10 @@ int main(int argc, char **argv) {=0A =0A     =0A =
=0A-=0A+    if (ferror(stdin)) {=0A+        perror("There was an error in s=
tdin");=0A+        exit(1);=0A+    }=0A =0A     traverseList(&list, &free);=
=0A     removeAllNodes(&list);=0A-- =0A2.34.1=0A=0A=0AFrom 2c3da16fa400b5e5=
6f33b1e45460a00a7d05a7cd Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao27=
94@columbia.edu>=0ADate: Sat, 29 Oct 2022 22:44:36 -0400=0ASubject: [PATCH =
6/7] Part 1 seems to be working, but I will make some little=0A adds to acc=
ount for the edge cases and early exits.=0A=0A---=0A part1/mdb-lookup.c | 1=
5 +++++++--------=0A 1 file changed, 7 insertions(+), 8 deletions(-)=0A=0Ad=
iff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Aindex 3fc64e2..fa5bf7=
1 100644=0A--- a/part1/mdb-lookup.c=0A+++ b/part1/mdb-lookup.c=0A@@ -80,21 =
+80,21 @@ int main(int argc, char **argv) {=0A         exit(1);=0A     }=0A=
 =0A-    traverseList(&list, &printRec);=0A+    // traverseList(&list, &pri=
ntRec);=0A     =0A     =0A    // printf("%s\n", buf);=0A     printf("lookup=
: ");=0A     =0A-    int n =3D 10; =0A+    int n =3D 7; =0A     char buf2[n=
];=0A      =0A     while(fgets(buf2, sizeof(buf2), stdin)){=0A         int =
sizeOfString;=0A         =0A-        printf("This the buffer before: %s\n",=
 buf2);=0A+       // printf("This the buffer before: %s\n", buf2);=0A      =
   =0A-        if(strlen(buf2)<=3D5){=0A+        if(strlen(buf2)<=3D6){=0A =
            sizeOfString =3D strlen(buf2);=0A         }else{=0A            =
 sizeOfString =3D 6;=0A@@ -104,7 +104,7 @@ int main(int argc, char **argv) =
{=0A         strncpy(string, buf2, sizeOfString-1);=0A         string[sizeO=
fString-1] =3D '\0';=0A         =0A-        printf("The key is: %s\n",strin=
g);=0A+        //printf("The key is: %s\n",string);=0A   =0A         =0A   =
      while(buf2[strlen(buf2)-1] !=3D '\n' ){=0A@@ -112,7 +112,7 @@ int mai=
n(int argc, char **argv) {=0A         }=0A =0A        =0A-        printf("T=
his is the buffer after: %s\n", buf2);=0A+        //printf("This is the buf=
fer after: %s\n", buf2);=0A             =0A             struct Node *curr =
=3D (struct Node*) (&list)->head;=0A             int lineno =3D 1;=0A@@ -13=
8,7 +138,7 @@ int main(int argc, char **argv) {=0A     printf("lookup: ");=
=0A     =0A     =0A-    //fseek(stdin, 0, SEEK_SET);   =0A+   // fseek(stdi=
n, 0, SEEK_END);   =0A =0A     }=0A =0A@@ -158,4 +158,3 @@ int main(int arg=
c, char **argv) {=0A     fclose(fp);=0A     return 0;=0A }=0A-=0A-- =0A2.34=
=2E1=0A=0A=0AFrom 4379c077bf68fc44c476258ef8742edf7018f82a Mon Sep 17 00:00=
:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 30 Oct 2022=
 14:39:36 -0400=0ASubject: [PATCH 7/7] I inserted the Valgrind output. This=
 should be the final=0A commit.=0A=0A---=0A README.txt         | 927 ++++++=
++++++++++++++++++++++++++++++++++++++-=0A part1/mdb-lookup.c |  74 ++--=0A=
 2 files changed, 962 insertions(+), 39 deletions(-)=0A=0Adiff --git a/READ=
ME.txt b/README.txt=0Aindex d342eb7..74089f0 100644=0A--- a/README.txt=0A++=
+ b/README.txt=0A@@ -3,9 +3,934 @@ This file should contain:=0A   - Arman O=
zcan=0A   - ao2794=0A   - lab4=0A-  - description for each part=0A+  - My p=
rogram is seemingly working.=0A =0A The description should indicate whether=
 your solution for the part is=0A working or not.  You may also want to inc=
lude anything else you would=0A like to communicate to the grader such as e=
xtra functionalities you=0A implemented or how you tried to fix your non-wo=
rking code.=0A+=3D=3D201254=3D=3D Memcheck, a memory error detector=0A+=3D=
=3D201254=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et=
 al.=0A+=3D=3D201254=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h =
for copyright info=0A+=3D=3D201254=3D=3D Command: ./mdb-lookup /home/j-hui/=
cs3157-pub/bin/mdb-cs3157=0A+=3D=3D201254=3D=3D =0A+lookup:  768: {Arman} s=
aid {I procrastinated this s}=0A+=0A+lookup:    1: {John} said {Welcome to =
AP!}=0A+   2: {ryan} said {hi mom}=0A+   3: {some student} said {file point=
ers are hard!}=0A+   4: {some student} said {Prezbos fun run changed}=0A+  =
 5: {John} said {Read the man pages!}=0A+   6: {Griffin N} said {finding a =
job is hard}=0A+   7: {Griffin N} said {Welcome to the US}=0A+   8: {garfie=
ld} said {i love lasagna}=0A+   9: {Camerie} said {Good luck on lab4 :)}=0A=
+  10: {anya} said {i love peanuts}=0A+  11: {camerie} said {^^}=0A+  12: {=
nobody} said {the weather is nice!}=0A+  13: {Rishabh} said {I watched the =
lecture}=0A+  14: {John} said {slay}=0A+  15: {Feiyang} said {hello}=0A+  1=
6: {so then I} said {horse walked into a bar}=0A+  17: {bartender} said {"w=
hy the long face"}=0A+  18: {Martin} said {oops i might've done sm}=0A+  19=
: {Martin (again)} said {nvm}=0A+  20: {}{} said {caught a leaf yestrday}=
=0A+  21: {}{}{}\{}{}{} said {heeh this is fun}=0A+  22: {Marie} said {Can'=
t wait for spring!}=0A+  23: {DROP TABLE name} said {just kidding}=0A+  24:=
 {Kendall Roy} said {good memeage}=0A+  25: {Logan Roy} said {I don't read =
my emails}=0A+  26: {Connor Roy} said {Conheads unite!}=0A+  27: {Shiv Roy}=
 said {no comment}=0A+  28: {cate} said {everything is great!}=0A+  29: {ca=
te} said {just kidding}=0A+  30: {John} said {November is coming...}=0A+  3=
1: {maiya} said {wello horld}=0A+  32: {raccoon} said {eats hamburger}=0A+ =
 33: {harry} said {didn't do homework}=0A+  34: {YeongWoo} said {has a midt=
erm tomorrow}=0A+  35: {ayalyakobe} said {i think i figured it ou}=0A+  36:=
 {Chukwuma Orji} said {No late days this time}=0A+  37: {ciaran } said {hi =
ciaran }=0A+  38: {Jorge} said {git add README.txt}=0A+  39: {Jorge} said {=
starting labs early is }=0A+  40: {Jorge } said {good practice}=0A+  41: {t=
ommy w} said {oh hi mark}=0A+  42: {after all is} said {and done, more is s=
aid }=0A+  43: {frog} said {it's wednesday, my dude}=0A+  44: {Gyuseok} sai=
d {Hi guys}=0A+  45: {Claudia} said {hi Kaitlyn}=0A+  46: {KY} said {good a=
fternoon}=0A+  47: {Cianna} said {im eating reese's piece}=0A+  48: {Brenda=
n} said {hello}=0A+  49: {Brendan} said {hello again}=0A+  50: {Kevin Li} s=
aid {This is cool!!}=0A+  51: {Kevin Li} said {This is super cool!!}=0A+  5=
2: {EDunlop} said {Hello Everyone}=0A+  53: {Heejong Han} said {I am so hun=
gry right no}=0A+  54: {zaka } said {pizza time!}=0A+  55: {zaka} said {nev=
er gonna give u up}=0A+  56: {zaka} said {never gonna let u down}=0A+  57: =
{zaka} said {never gonna run around}=0A+  58: {zaka} said {n desert u <3}=
=0A+  59: {} said {}=0A+  60: {John} said {beware identity theft}=0A+  61: =
{luca} said {nothing}=0A+  62: {-_-} said {0_0}=0A+  63: {0_0} said {-_-}=
=0A+  64: {Dallas} said {Pointers on pointers}=0A+  65: {Dallas} said {Can =
you C me?}=0A+  66: {Tommy} said {Halleluyah}=0A+  67: {Ly} said {Hakuna Ma=
tata}=0A+  68: {Jacob} said {suh dude}=0A+  69: {ben} said {freshwater fish=
es of th}=0A+  70: {Mike} said {I <3 AP}=0A+  71: {Zi} said {this is actual=
ly c     }=0A+  72: {zi} said {good luck guyss}=0A+  73: {mayachka} said {i=
 love maya}=0A+  74: {vitamin} said {water}=0A+  75: {Some Student} said {T=
rying to survive midte}=0A+  76: {Segmentation} said {Fault Core Dumped}=0A=
+  77: {Lw eana } said {Hey  , I'm doin     [C }=0A+  78: {Leana} said {I'm=
 ready}=0A+  79: {Logan} said {I dont know what to say}=0A+  80: {ayalyakob=
e} said {testing}=0A+  81: {Maitar} said {Are we ready for midter}=0A+  82:=
 {Maitar} said {r we ready for MD2 XD?}=0A+  83: {yizhen} said {iHere for l=
ab4}=0A+  84: {Carl} said {Hello there}=0A+  85: {Morty} said {Oh Jeez Rick=
}=0A+  86: {Harry Potter} said {Expelliarmus}=0A+  87: {marcusfong12345} sa=
id {hes the best TA}=0A+  88: {CCG} said {Hello}=0A+  89: {CCG} said {World=
}=0A+  90: {Mike} said {chocolate croissant}=0A+  91: {Mike} said {almond c=
roissant}=0A+  92: {Mike} said {nutella cornetto}=0A+  93: {Melissa Moran} =
said {Lab4-OK!}=0A+  94: {Karla Zuniga} said {Keep going! }=0A+  95: {Siwan=
ta Thapa} said {There is hope}=0A+  96: {Alex J.K. XU} said {Hello MDB, how=
 are you?}=0A+  97: {Alex J.K. XU} said {MDB: Great Great!}=0A+  98: {Natha=
n Raghavan} said {Hey guys whats up!}=0A+  99: {joel} said {mmmm im mr frun=
dles}=0A+ 100: {Rimas} said {I love AP!}=0A+ 101: {hohn jui} said {uh}=0A+ =
102: {jenny} said {Hi, how are you today?}=0A+ 103: {steph curry} said {im =
better than lebron}=0A+ 104: {mom} said {hi}=0A+ 105: {cs major} said {i lo=
ve hygiene}=0A+ 106: {aiden} said {i <3 eris}=0A+ 107: {eris} said {i <3 ai=
den}=0A+ 108: {ap student} said {lab 4 is hard :'(}=0A+ 109: {EitanF} said =
{Hello mdb}=0A+ 110: {daenerys} said {dracarys}=0A+ 111: {ned stark} said {=
winter is coming}=0A+ 112: {Kent } said {}=0A+ 113: {Kent} said {Lab 4}=0A+=
 114: {nobody} said {they like AP}=0A+ 115: {            } said {Hello}=0A+=
 116: {BRS} said {Hello World!}=0A+ 117: {Tomas} said {hey !!}=0A+ 118: {H3=
} said {It's Friday!}=0A+ 119: {said} said {said}=0A+ 120: {Tanvir Hossain =
} said {Hello mates, wish you a}=0A+ 121: {joey} said {how you doin}=0A+ 12=
2: {phoebe} said {ello there mate}=0A+ 123: {ross} said {you think??}=0A+ 1=
24: {henry} said {hiiiiiiiiiiiiiiiiiiiiii}=0A+ 125: {l  [C Luci} said {Codi=
ng is              }=0A+ 126: {Darth Vader} said {I'm       [C [C [C [C [}=
=0A+ 127: {Britney Spears} said {Oops i did it again...}=0A+ 128: {Steven U=
rq} said {I don't know.}=0A+ 129: {Steven U.} said {This is data!}=0A+ 130:=
 {Monique} said {Testing database}=0A+ 131: {d{}s} said {said{said}said}=0A=
+ 132: {h  i} said {wow     }=0A+ 133: {Joseph Kaplan} said {B"H it's the w=
eekend}=0A+ 134: {} said {} said {}{}=0A+ 135: {wwwwwwwwwwwwwww} said {wwww=
wwwwwwwwwwwwwwwwwww}=0A+ 136: {} said {}=0A+ 137: {123456789012345} said {1=
2345678901234567890123}=0A+ 138: {I} said {the truncation works!}=0A+ 139: =
{I} said {crtfd freak 7days/week}=0A+ 140: {John} said {nz2368 deserves an =
A}=0A+ 141: {Charis Yoon} said {hi}=0A+ 142: {Lets play chess} said {1. e4}=
=0A+ 143: {Jessica} said {hi melina}=0A+ 144: {Jessica} said {hi jacklyn}=
=0A+ 145: {Jessica} said {hi kaylee}=0A+ 146: {Embyr} said {howdy}=0A+ 147:=
 {world} said {hello}=0A+ 148: {devon} said {since when does roaree }=0A+ 1=
49: {fread} said {i rhyme with bread}=0A+ 150: {Gill Bartels} said {finally=
 starting this a}=0A+ 151: {Logan} said {LGM}=0A+ 152: {John Cena} said {U =
cant see me}=0A+ 153: {ben} said {dro-tang-leski}=0A+ 154: {aryana} said {h=
i}=0A+ 155: {Erica} said {waz here!!!!}=0A+ 156: {Lexi} said {It's spooky s=
zn!}=0A+ 157: {enrico pucci} said {hallelujah, dio!}=0A+ 158: {Homer} said =
{d'oh!}=0A+ 159: {Will Hoppin} said {help I'm trapped in C!}=0A+ 160: {DJ K=
haled} said {Another one}=0A+ 161: {    } said {                       }=0A=
+ 162: {Mom}     {Dad} said {We're getting divorced}=0A+ 163: {Stanley} sai=
d {hello 315      [C [C [C}=0A+ 164: {Stanley} said {it's Saturday}=0A+ 165=
: {Linda} said {hellohello}=0A+ 166: {Linda} said {hihihi}=0A+ 167: {Pru Yo=
ntrarak} said {I love AP}=0A+ 168: {Danielzzzz} said {Hate midterms}=0A+ 16=
9: {Danielzzzz} said {Love midterms}=0A+ 170: {another one} said {bites the=
 dust}=0A+ 171: {mariam} said {i am working on lab4}=0A+ 172: {David} said =
{naur}=0A+ 173: {Liam} said {42}=0A+ 174: {carrie :)} said {_ _ _ _ _ _ _}=
=0A+ 175: {Liam A} said {My contribution}=0A+ 176: {david} said {a}=0A+ 177=
: {carrie} said {_ _ _ _ _ _ _ (head)}=0A+ 178: {david} said {e}=0A+ 179: {=
carrie} said {_ _ _ _ _ _ _ (head) (b}=0A+ 180: {carrie} said {you are bad =
at this}=0A+ 181: {david} said {i}=0A+ 182: {carrie} said {_ _ _ _ _ I _}=
=0A+ 183: {david} said {r}=0A+ 184: {carrie} said {buddy no, that's an arm}=
=0A+ 185: {tired} said {s}=0A+ 186: {Dad} said {Hi tired, I'm}=0A+ 187: {ca=
rrie} said {also wrong}=0A+ 188: {hint} said {112}=0A+ 189: {d} said {p}=0A=
+ 190: {carrie} said {P _ _ P _ I _}=0A+ 191: {d} said {pumpkin}=0A+ 192: {=
carrie} said {PUMPKIN ! ! !}=0A+ 193: {hel} said {}=0A+ 194: {aslfj;l} said=
 {as;ldkfja;lsfkdjas;lfjk}=0A+ 195: {Claudia} said {happy saturday everyone=
}=0A+ 196: {claudia} said {its cold out}=0A+ 197: {cs} said {do u like me? =
(y/n)}=0A+ 198: {MR4217} said {LettuceTacoBoutIt}=0A+ 199: {henry} said {hi=
iiiii}=0A+ 200: {henry} said {hii}=0A+ 201: {hii} said {henry}=0A+ 202: {hi=
iiiiii} said {henry}=0A+ 203: {hiiiiii} said {hiiiiiiiii}=0A+ 204: {hii} sa=
id {hii}=0A+ 205: {Pork Chop} said {Hey there}=0A+ 206: {Student} said {lab=
s are hard}=0A+ 207: {hello } said {goodbye}=0A+ 208: {Leana} said {Big bra=
ins}=0A+ 209: {Freddy C     [C} said {Hello!  }=0A+ 210: {Ahmed Mahmud} sai=
d {Ho  Hope everyoin  ne i}=0A+ 211: {Ahmed Mahmud} said {AP is fun!}=0A+ 2=
12: {Lucy} said {sup}=0A+ 213: {Keyi} said {twinkle twinkle}=0A+ 214: {Keyi=
} said {little star}=0A+ 215: {Gabriel Trigo} said {database test}=0A+ 216:=
 {tomatoboi} said {i am so swag}=0A+ 217: {I} said {so}=0A+ 218: {God} said=
 {Let there be light}=0A+ 219: {0} said {0}=0A+ 220: {Jas} said {World Cup =
is soon!}=0A+ 221: {Doublelift} said {NA<EU}=0A+ 222: {William Wang} said {=
Wait what happened to t}=0A+ 223: {Lucas} said {Excited to work on this}=0A=
+ 224: {Lucas} said {Tried popeyes}=0A+ 225: {Shimon} said {Why are compute=
rs not g}=0A+ 226: {Shimon} said {ood boxers at all?}=0A+ 227: {Shimon} sai=
d {Forget it}=0A+ 228: {Shimon} said {This joke is too long}=0A+ 229: {Etha=
n T} said {Twenty seventy-five}=0A+ 230: {smf2240} said {Oh hi Mark}=0A+ 23=
1: {dang} said {^someone beat me to tha}=0A+ 232: {DJ Khalid} said {anotha =
one}=0A+ 233: {Edward Kim} said {hello!}=0A+ 234: {Edward Kim} said {hello =
again!}=0A+ 235: {satan} said {let there be darkness}=0A+ 236: {john hui} s=
aid {trust me guys the exams}=0A+ 237: {john hui} said {are totally fair}=
=0A+ 238: {Dr. Dre} said {Slim Shady you a base-h}=0A+ 239: {Dr. Dre} said =
{ nothing, you idiots}=0A+ 240: {orange} said {i'm blue}=0A+ 241: {Cole} sa=
id {hello cruld}=0A+ 242: {Cole} said {*cruel world}=0A+ 243: {jeff} said {=
my name is jeff}=0A+ 244: {Walt} said {I am the one who knocks}=0A+ 245: {k=
apybara} said {no thoughts head empty}=0A+ 246: {Camko} said {Happy Sunday}=
=0A+ 247: {nga2120} said {Go Blue!}=0A+ 248: {Mst Nayma} said {CS is great!=
 :)}=0A+ 249: {Anagha Ram} said {Pumpkin spice szn}=0A+ 250: {Anagha Ram} s=
aid {halloween next week!}=0A+ 251: {Mike D} said {Testy test}=0A+ 252: {je=
ssica} said {i need to go home}=0A+ 253: {jessica} said {it's sunday}=0A+ 2=
54: {Roey} said {The struggle is real!}=0A+ 255: {blake} said {i use arch b=
tw}=0A+ 256: {blake} said {what's a cornell?}=0A+ 257: {Natalie} said {AP +=
 JHUI =3D FUN}=0A+ 258: {Luiza Serson} said {I am currently working }=0A+ 2=
59: {Luiza Serson} said {Hello!}=0A+ 260: {Natalie} said {What Blake Said}=
=0A+ 261: {blake} said {i simp 4 john hui}=0A+ 262: {Alia} said {meow}=0A+ =
263: {Hellooo} said {World}=0A+ 264: {Columbia} said {lost homecoming}=0A+ =
265: {Preach} said {Hi! I love AP}=0A+ 266: {Preach} said {This is so cool}=
=0A+ 267: {hana m} said {andy is helping me toda}=0A+ 268: {Luciana } said =
{hi :) }=0A+ 269: {Luciana } said {testing testing }=0A+ 270: {Kylie} said =
{Good luck y'all}=0A+ 271: {Tehreem} said {The earth <3}=0A+ 272: {john} sa=
id {hey}=0A+ 273: {sohyb} said {hi lol}=0A+ 274: {amina} said {lmao kinda c=
ool}=0A+ 275: {I wish lab4 was} said {as fun as adding info h}=0A+ 276: {te=
st} said {test}=0A+ 277: {Eleanor} said {Learning C is fun}=0A+ 278: {el307=
9} said {Hello!}=0A+ 279: {Zachary Zusin} said {I'm going baby on baby}=0A+=
 280: {Jinoo} said {bruh}=0A+ 281: {Ismail} said {what do i say?}=0A+ 282: =
{matt} said {rip wisco }=0A+ 283: {matt} said {so sad :/ }=0A+ 284: {Andrew=
} said {roar}=0A+ 285: {wakefield} said {hello guys}=0A+ 286: {Aidan Eichma=
n} said {hopefully this works :)}=0A+ 287: {Aidan Eichman} said {go blue!!!=
}=0A+ 288: {Aidan Eichman} said {yay this works!}=0A+ 289: {The TAs} said {=
  \_(   )_/  }=0A+ 290: {} said {}=0A+ 291: { }{} said {}{}=0A+ 292: {Charl=
esY} said {Awesome program.}=0A+ 293: {CharlesY} said {damn this is difficu=
lt}=0A+ 294: {Ma Yun} said {I am not intersted in m}=0A+ 295: {Ma Yun} said=
 {I am not interested in }=0A+ 296: {Ma Yun} said {I have no interest in $}=
=0A+ 297: {Sa Beining} said {0-0 trying not to laugh}=0A+ 298: {Sa Beining}=
 said {0-0}=0A+ 299: {jkim} said {1st message}=0A+ 300: {jkim} said {2nd me=
ssage}=0A+ 301: {Jonathan} said {fundies isn't fun}=0A+ 302: {Jonno} said {=
Short for jonathan}=0A+ 303: {Saitama} said {}=0A+ 304: {Saitama} said {   =
                    }=0A+ 305: {Saitama} said {                       }=0A+=
 306: {} said {}=0A+ 307: {     } said {______________________}=0A+ 308: { =
    } said {|                    |}=0A+ 309: {     } said {|       hello!  =
     |}=0A+ 310: {     } said {|____________________|}=0A+ 311: {     } sai=
d {()  ()    ||}=0A+ 312: {     } said {( o w o)  ||          }=0A+ 313: {b=
unny} said { (    ) =3D=3D0           }=0A+ 314: {dr livesey} said {the wor=
d rum and the wo}=0A+ 315: {dr livesey} said {rd death mean the same }=0A+ =
316: {dr livesey} said {thing to you}=0A+ 317: {Yoni} said {New CS listserv=
???}=0A+ 318: {Unicorn Friend} said {Something is magical ar}=0A+ 319: {yis=
sachar yehud} said {you misspelled your own}=0A+ 320: {yissachar yehud} sai=
d {you spelled your name c}=0A+ 321: {What is love?} said {Baby don't hurt =
me}=0A+ 322: {Dorothy} said {hello everyone}=0A+ 323: {Pawit} said {Hello W=
orld}=0A+ 324: {ps3201} said {Sawadee Krub}=0A+ 325: {Heisenberg} said {Tre=
ad lightly...}=0A+ 326: {CS student} said {I love social interacti}=0A+ 327=
: {          } said {                 }=0A+ 328: {aja} said {initials}=0A+ =
329: {npr} said {national public radio}=0A+ 330: {avita} said {hi yall :))}=
=0A+ 331: {taylor swift} said {'Cause there we are aga}=0A+ 332: {gema} sai=
d {m de motomami}=0A+ 333: {Greg Ou} said {Hi my name Greg}=0A+ 334: {Muscl=
e Man} said {MY MOM}=0A+ 335: {Kanye West} said {I guess we'll never kno}=
=0A+ 336: {Danelle Tuchman} said {drinking coffee rn :)}=0A+ 337: {Will Smi=
th} said {KEEP MY WIFES NAME OUT }=0A+ 338: {Julius Caesar} said {Veni, vid=
i, vici.}=0A+ 339: {EDunlop} said {just checking}=0A+ 340: {crister ronaldo=
} said {sewi}=0A+ 341: {Matt} said {Connecting...}=0A+ 342: {testing} said =
{this is the test }=0A+ 343: {Nira} said {Avocadoes are the best}=0A+ 344: =
{Merry Mayers} said {hydrate or dydrate}=0A+ 345: {Will} said {likes boba!}=
=0A+ 346: {Smith} said {does not like boba}=0A+ 347: {Akshay} said {This is=
 kinda cool}=0A+ 348: {some other guy} said {How many of these do I }=0A+ 3=
49: {Bean Team} said {Birds don't have arms}=0A+ 350: {ranger} said {chain =
swanging}=0A+ 351: {Someone} said {How do i add to the dat}=0A+ 352: {elise=
} said {cling clang}=0A+ 353: {ranger} said {and it costs alot}=0A+ 354: {e=
lise} said {i'm always after guala}=0A+ 355: {ranger} said {yeah and you ar=
e not}=0A+ 356: {Ferris Booth} said {pepperoni pizza}=0A+ 357: {You} said {=
You would buy me coffee}=0A+ 358: {class} said {we miss John}=0A+ 359: {zz2=
927} said {zz2927_hello}=0A+ 360: {Melina} said {your mom}=0A+ 361: {Melina=
} said {hi Jessica}=0A+ 362: {foo\n} said {hi\n}=0A+ 363: {Keisha} said {Ar=
e you happy?}=0A+ 364: {Keisha} said {Its above me}=0A+ 365: {amina} said {=
knsnd}=0A+ 366: {Pawit} said {Please Work}=0A+ 367: {ryan's dad} said {what=
 about me?}=0A+ 368: {Tanvir} said {Good Luck!}=0A+ 369: {Danelle Tuchman} =
said {hi, good morning!}=0A+ 370: {Pawit} said {Does this work?}=0A+ 371: {=
John} said {My Queen}=0A+ 372: {hi} said {hello what's up}=0A+ 373: {KeunWo=
o} said {Life is too hard.}=0A+ 374: {Kaitlyn} said {Hi Claudia !!}=0A+ 375=
: {Alexa} said {}=0A+ 376: {Alexa} said {hi}=0A+ 377: {karla zuniga} said {=
forgot my pfirst commen}=0A+ 378: {Charlie} said {Who hates this class}=0A+=
 379: {Charlie } said {Couldn't be me }=0A+ 380: {megan} said {i landed on =
my zipper}=0A+ 381: {claire} said {hi embyr}=0A+ 382: {claire} said {i am s=
o short boohoo}=0A+ 383: {Myst} said {Short Gang Unite}=0A+ 384: {your mom}=
 said {my mom is hotter then y}=0A+ 385: {Gil} said {AP is hard}=0A+ 386: {=
Gil} said {AP is fun!}=0A+ 387: {Tajh} said {Hiiiii}=0A+ 388: {Gil} said {w=
ake me up when}=0A+ 389: {Gil} said {December ends}=0A+ 390: {Kelvin} said =
{hello}=0A+ 391: {Neev Mistry} said {good neevening}=0A+ 392: {jimmy} said =
{i like turtles}=0A+ 393: {kowala} said {hi}=0A+ 394: {Matthew Weng} said {=
This computer thing is }=0A+ 395: {Matthew Weng} said {not computing.}=0A+ =
396: {Ash} said {Who's that Pok  mon?}=0A+ 397: {Ash} said {It's Crobat!}=
=0A+ 398: {Kent} said {Part 1 (a) is easy.}=0A+ 399: {monica} said {good lu=
ck everyone! :) }=0A+ 400: {Kavika Krishnan} said {hi everyone}=0A+ 401: {p=
atrick} said {is mayo an instrument}=0A+ 402: {kate} said {helloooo}=0A+ 40=
3: {kate} said {always behind schedule}=0A+ 404: {Jeannie} said {hi}=0A+ 40=
5: {Lauren} said {hellooooo}=0A+ 406: {Gregg} said {Try shellcheck for Bash=
}=0A+ 407: {Jessica} said {Melina, whatcha doing}=0A+ 408: {dantheman} said=
 {i am great}=0A+ 409: {ADRIANA} said {preachhhhhhhhhh my love}=0A+ 410: {J=
essica} said {hi Preach}=0A+ 411: {} said {}=0A+ 412: {ash} said {yo}=0A+ 4=
13: {Ducky Quackers} said {Ducks rule the world}=0A+ 414: {korin} said {  \=
\//// }=0A+ 415: {korin} said {   |.)(.|  }=0A+ 416: {korin} said {   | || =
|  }=0A+ 417: {korin} said {   \(__)/  }=0A+ 418: {korin} said {   |-..-|  =
}=0A+ 419: {korin} said {   |o\/o|  }=0A+ 420: {korin} said {   \    /  }=
=0A+ 421: {korin} said {   |~~~~|  }=0A+ 422: {korin} said {   |::::|  }=0A=
+ 423: {korin} said {   |::::|  }=0A+ 424: {korin} said {  (((^^))) }=0A+ 4=
25: {korin} said {   >>><<<  }=0A+ 426: {korin} said {   ||||||  }=0A+ 427:=
 {korin} said {   (o)(o)  }=0A+ 428: {korin} said {   | /\ |  }=0A+ 429: {k=
orin} said {   (=3D=3D=3D=3D)  }=0A+ 430: {korin} said {   |_/\_|  }=0A+ 43=
1: {korin} said {   (_/\_)  }=0A+ 432: {korin} said {  _|_,__|_ }=0A+ 433: =
{korin} said { (___\____)}=0A+ 434: {korin} said {  \\//// }=0A+ 435: {kori=
n} said {   |.)(.|  }=0A+ 436: {korin} said {   | || |  }=0A+ 437: {korin} =
said {   \(__)/  }=0A+ 438: {korin} said {   |-..-|  }=0A+ 439: {korin} sai=
d {   |o\/o|  }=0A+ 440: {korin} said {   \    /  }=0A+ 441: {korin} said {=
   |~~~~|  }=0A+ 442: {korin} said {   |::::|  }=0A+ 443: {korin} said {   =
|::::|  }=0A+ 444: {korin} said {  (((^^))) }=0A+ 445: {korin} said {   >>>=
<<<  }=0A+ 446: {korin} said {   ||||||  }=0A+ 447: {korin} said {   (o)(o)=
  }=0A+ 448: {korin} said {   | /\ |  }=0A+ 449: {korin} said {   (=3D=3D=
=3D=3D)  }=0A+ 450: {korin} said {   |_/\_|  }=0A+ 451: {korin} said {   (_=
/\_)  }=0A+ 452: {korin} said {  _|_,__|_ }=0A+ 453: {korin} said { (___\__=
__)}=0A+ 454: {korin} said {  \\//// }=0A+ 455: {korin} said {   |.)(.|  }=
=0A+ 456: {korin} said {   | || |  }=0A+ 457: {korin} said {   \(__)/  }=0A=
+ 458: {korin} said {   |-..-|  }=0A+ 459: {korin} said {   |o\/o|  }=0A+ 4=
60: {korin} said {   \    /  }=0A+ 461: {korin} said {   |~~~~|  }=0A+ 462:=
 {korin} said {   |::::|  }=0A+ 463: {korin} said {   |::::|  }=0A+ 464: {k=
orin} said {  (((^^))) }=0A+ 465: {korin} said {   >>><<<  }=0A+ 466: {kori=
n} said {   ||||||  }=0A+ 467: {korin} said {   (o)(o)  }=0A+ 468: {korin} =
said {   | /\ |  }=0A+ 469: {korin} said {   (=3D=3D=3D=3D)  }=0A+ 470: {ko=
rin} said {   |_/\_|  }=0A+ 471: {korin} said {   (_/\_)  }=0A+ 472: {korin=
} said {  _|_,__|_ }=0A+ 473: {korin} said { (___\____)}=0A+ 474: {frog} sa=
id {it's wednesday, my dude}=0A+ 475: {korin} said {  \\\\//// }=0A+ 476: {=
korin} said {   |.)(.|  }=0A+ 477: {korin} said {   | || |  }=0A+ 478: {kor=
in} said {   \(__)/  }=0A+ 479: {korin} said {   |-..-|  }=0A+ 480: {korin}=
 said {   |o\/o|  }=0A+ 481: {korin} said {   \    /  }=0A+ 482: {korin} sa=
id {   |~~~~|  }=0A+ 483: {korin} said {   |::::|  }=0A+ 484: {korin} said =
{   |::::|  }=0A+ 485: {korin} said {  (((^^))) }=0A+ 486: {korin} said {  =
 >>><<<  }=0A+ 487: {korin} said {   ||||||  }=0A+ 488: {korin} said {   (o=
)(o)  }=0A+ 489: {korin} said {   | /\ |  }=0A+ 490: {korin} said {   (=3D=
=3D=3D=3D)  }=0A+ 491: {korin} said {   |_/\_|  }=0A+ 492: {korin} said {  =
 (_/\_)  }=0A+ 493: {korin} said {  _|_,__|_ }=0A+ 494: {korin} said { (___=
\____)}=0A+ 495: {korin} said {  \\\\//// }=0A+ 496: {korin} said {   |.)(.=
|  }=0A+ 497: {korin} said {   | || |  }=0A+ 498: {korin} said {   \(__)/  =
}=0A+ 499: {korin} said {   |-..-|  }=0A+ 500: {korin} said {   |o\/o|  }=
=0A+ 501: {korin} said {   \    /  }=0A+ 502: {korin} said {   |~~~~|  }=0A=
+ 503: {korin} said {   |::::|  }=0A+ 504: {korin} said {   |::::|  }=0A+ 5=
05: {korin} said {  (((^^))) }=0A+ 506: {korin} said {   >>><<<  }=0A+ 507:=
 {korin} said {   ||||||  }=0A+ 508: {korin} said {   (o)(o)  }=0A+ 509: {k=
orin} said {   | /\ |  }=0A+ 510: {korin} said {   (=3D=3D=3D=3D)  }=0A+ 51=
1: {korin} said {   |_/\_|  }=0A+ 512: {korin} said {   (_/\_)  }=0A+ 513: =
{korin} said {  _|_,__|_ }=0A+ 514: {korin} said { (___\____)}=0A+ 515: {ko=
rin} said {  \\\\//// }=0A+ 516: {korin} said {   |.)(.|  }=0A+ 517: {korin=
} said {   | || |  }=0A+ 518: {korin} said {   \(__)/  }=0A+ 519: {korin} s=
aid {   |-..-|  }=0A+ 520: {korin} said {   |o\/o|  }=0A+ 521: {korin} said=
 {   \    /  }=0A+ 522: {korin} said {   |~~~~|  }=0A+ 523: {korin} said { =
  |::::|  }=0A+ 524: {korin} said {   |::::|  }=0A+ 525: {korin} said {  ((=
(^^))) }=0A+ 526: {korin} said {   >>><<<  }=0A+ 527: {korin} said {   ||||=
||  }=0A+ 528: {korin} said {   (o)(o)  }=0A+ 529: {korin} said {   | /\ | =
 }=0A+ 530: {korin} said {   (=3D=3D=3D=3D)  }=0A+ 531: {korin} said {   |_=
/\_|  }=0A+ 532: {korin} said {   (_/\_)  }=0A+ 533: {korin} said {  _|_,__=
|_ }=0A+ 534: {korin} said { (___\____)}=0A+ 535: {danield} said {hi hiii o=
mg hii        }=0A+ 536: {Melina} said {Jessica, your dad}=0A+ 537: {Suwei}=
 said {Hello}=0A+ 538: {karla } said {helooloooooo}=0A+ 539: {will} said {w=
ill rocks}=0A+ 540: {James} said {Hiiiiiiiiiiiii!}=0A+ 541: {lexa} said {i =
took the wock to pola}=0A+ 542: {lexa} said {i took the woooooooock}=0A+ 54=
3: {lexa} said {to poland}=0A+ 544: {abenezer} said {who took the wock to p=
o}=0A+ 545: {abenezer} said {what's good?}=0A+ 546: {abenzer   ezer} said {=
my beautiful people!}=0A+ 547: {kid named finge} said {waltuhhhh}=0A+ 548: =
{Hezzy} said {Midterm in 3 weeks :)}=0A+ 549: {   } said {   }=0A+ 550: {yo=
u} said {me}=0A+ 551: {Allen} said {This is interesting}=0A+ 552: {Peter} s=
aid {im hungry}=0A+ 553: {123456789012345} said {test}=0A+ 554: {valentino}=
 said {-2 late days}=0A+ 555: {William} said {Lab4 is so hard!!}=0A+ 556: {=
billybool} said {#1 dj in the whole plan}=0A+ 557: {haunted mound} said {ha=
untoholics... real ha}=0A+ 558: {Lola} said {something}=0A+ 559: {Lola} sai=
d {559}=0A+ 560: {soundcloud.com/} said {pwittyboyclub}=0A+ 561: {Emily} sa=
id {I want to sleep}=0A+ 562: {nobody} said {odysseus}=0A+ 563: {some stude=
nt} said {}=0A+ 564: {Chris} said {Can we all survive?}=0A+ 565: {Charis} s=
aid {goodnight}=0A+ 566: {cs tutor} said {we are going to dadada}=0A+ 567: =
{Cecilia} said {Fighting!}=0A+ 568: {Conan} said {Habara is cute}=0A+ 569: =
{Qazi} said {well i hope i can pass}=0A+ 570: {Doga} said {Hello}=0A+ 571: =
{Doga} said {Goodnight}=0A+ 572: {Qazi} said {hello}=0A+ 573: {Qazi} said {=
how is it going}=0A+ 574: {Rengoku} said {set your heat ablaze}=0A+ 575: {A=
hmad} said {Learning is great!}=0A+ 576: {Ahmad} said {Columbia University =
is }=0A+ 577: {Anran} said {great class}=0A+ 578: {Eowyn} said {I am no man=
}=0A+ 579: {Nguyen Tran} said {something cool}=0A+ 580: {Demon time} said {=
shawty wyd, u up ?}=0A+ 581: {Rene Sultan} said {Hi}=0A+ 582: {Joe} said {t=
his thing works}=0A+ 583: {Joe} said {hmm}=0A+ 584: {humanity} said {Can Ka=
nye please stop?}=0A+ 585: {every teenager} said {Sisyphus is happy}=0A+ 58=
6: {whale} said {hello}=0A+ 587: {dolphin} said {goodbye}=0A+ 588: { harry =
potter} said { i can't be a wizard, i}=0A+ 589: {draco malfoy} said {the fo=
rest? i thought t}=0A+ 590: {Nandini} said {Jae Woo Bee Buzz Buzz}=0A+ 591:=
 {Boris} said {Dogs are better}=0A+ 592: {Boris} said {than people}=0A+ 593=
: {Boris} said {I finally figured out}=0A+ 594: {Boris} said {How to use th=
is}=0A+ 595: {Boris} said {Coding is hard}=0A+ 596: {Logan } said {you go g=
lenn coco}=0A+ 597: {Bob the Builder} said {Can he fix my grades?}=0A+ 598:=
 {Shivam S.} said {columbia dining is good}=0A+ 599: {andreas} said {hey gu=
ys this is andrea}=0A+ 600: {Jessica} said {noooooooooooooooo}=0A+ 601: {Je=
ssica} said {Melina, how could you}=0A+ 602: {Fatoumata Camar} said {**I ho=
pe you have an am}=0A+ 603: {Theo} said {Friends, Romans, Countr}=0A+ 604: =
{Google} said {You Got This}=0A+ 605: {Erick} said {TestTestTest}=0A+ 606: =
{Evelyn} said {everything will be grea}=0A+ 607: {Evelyn} said {cheesepizza=
}=0A+ 608: {Rene} said {Hi}=0A+ 609: {Lana} said {hey friends how are you}=
=0A+ 610: {Lana} said {wow i love cs the TAs a}=0A+ 611: {Lana} said {Wow a=
ren't the TAs so c}=0A+ 612: {Lana} said {Stop truncating me}=0A+ 613: {hah=
a} said {i hate you}=0A+ 614: {Mr. Pink} said {Am I the only professio}=0A+=
 615: {teehee} said {i love you}=0A+ 616: {heart} said {power}=0A+ 617: {No=
 thank you} said {Can I get a '\n' ?}=0A+ 618: {Isaiah} said {When will I c=
atch up?}=0A+ 619: {siggi} said {hi}=0A+ 620: {Nova} said {Amogus    }=0A+ =
621: {girlboss} said {servec*ntordie}=0A+ 622: {suba} said {yayyy :)}=0A+ 6=
23: {SLAYYYY} said {HALLOWEEKEN}=0A+ 624: {cx} said {hello cs3157!}=0A+ 625=
: {suba} said {\(*^ ^*)/}=0A+ 626: {helpme} said {sosad}=0A+ 627: {hfauwf} =
said {dfghjk}=0A+ 628: {kjhg} said {jhgffghjhgffgh}=0A+ 629: {heisenberg} s=
aid {knock knock}=0A+ 630: {katie} said {hi gracee}=0A+ 631: {Kyle} said {H=
ello I'm Kyle}=0A+ 632: {Kyle} said {Hello This is Part a}=0A+ 633: {test} =
said {hello world}=0A+ 634: {Lauren} said {thank u TAs!}=0A+ 635: {Han} sai=
d {hi this is han}=0A+ 636: {Han Choi} said {this is a very very lon}=0A+ 6=
37: {Omar Kammourieh} said {i need a cowboy hat b4 }=0A+ 638: {Omar Kammour=
ieh} said {tomorrow}=0A+ 639: {hannah h} said {time to start lab 4!}=0A+ 64=
0: {fdisfijdfiopjsa} said {fdnsuihfudsahfiuhdasufh}=0A+ 641: {fjdiosajfioda=
sj} said {fdnasfnidsjhfiodashfiod}=0A+ 642: {123451234512345} said {1234512=
3451234512345123}=0A+ 643: {12345} said {12345}=0A+ 644: {Kaan E.} said {He=
llo Theree!}=0A+ 645: {superkaanmessi} said {hi ap}=0A+ 646: {Jeff} said {t=
his is neat}=0A+ 647: {Jeff again} said {man 23 chars is not eno}=0A+ 648: =
{Lets play chess} said {1... e5}=0A+ 649: {everyone} said {anya solos}=0A+ =
650: {anya} said {waku waku}=0A+ 651: {Karem} said {Late as usual to this.}=
=0A+ 652: {Karem} said {Thank God I wasn't the }=0A+ 653: {Karem} said {- t=
he 666 entry :) }=0A+ 654: {Inigo Motoya} said {you killed my father}=0A+ 6=
55: {Karem} said {no, I'm not a murderer}=0A+ 656: {mariam} said {hello}=0A=
+ 657: {} said {}=0A+ 658: {Rohan} said {Loves C/C++ programming}=0A+ 659: =
{Barry} said {Ya like jazz?}=0A+ 660: {Barry} said {Ya like jazz?}=0A+ 661:=
 {Barry} said {Ya like jazz?}=0A+ 662: {Barry} said {Ya like jazzzz?}=0A+ 6=
63: {Kynnedy Simone} said {spooky scary skeletons}=0A+ 664: {Willi Brandt} =
said {I probably started too }=0A+ 665: {Dave Matthews} said {Rock on broth=
er}=0A+ 666: {who} said {who said ur not perfect}=0A+ 667: {the world} said=
 {thanks miley}=0A+ 668: {asdf movie} said {here, hold this}=0A+ 669: {} sa=
id {}=0A+ 670: {Seyoung} said {idk}=0A+ 671: {Seyoung} said {this is so coo=
l!}=0A+ 672: {alicia yang} said {hello!}=0A+ 673: {Heidi} said {Welcome to =
AP!!}=0A+ 674: {Test Name} said {Test Message}=0A+ 675: {testtestname} said=
 {testtestmessage}=0A+ 676: {jonno} said {rosen }=0A+ 677: {alexkoletsos} s=
aid {wesley the weissel, hi.}=0A+ 678: {alex krylov} said {bryce wold serie=
s mvp}=0A+ 679: {alex krylov} said {josh nam is the man}=0A+ 680: {katie} s=
aid {heyyyy}=0A+ 681: {Katherine} said {hello everyone!!}=0A+ 682: {Katheri=
ne} said {hmmmmm....}=0A+ 683: {will} said {go columbia!}=0A+ 684: {annika}=
 said {hi!!}=0A+ 685: {keir} said {dogs are cool}=0A+ 686: {keir} said {hap=
py halloween}=0A+ 687: {Rene} said {John's OH}=0A+ 688: {Bereket } said {ex=
perimental}=0A+ 689: {jax_king} said {hello cs3157}=0A+ 690: {minh} said {c=
oding in Bostoon}=0A+ 691: {Woojin Son} said {Can I survive?}=0A+ 692: {Woo=
jin Son} said {I just wanna pass this }=0A+ 693: {Woojin Son} said {class}=
=0A+ 694: {Roey} said {John's OH signup}=0A+ 695: {123456789012345} said {1=
2345678901234567890123}=0A+ 696: {Woojin} said {test!!}=0A+ 697: {Woojin So=
n} said {Oct 28th, 2022 Hello!}=0A+ 698: {Da Hoon Oh} said {Hello!}=0A+ 699=
: {Byeolah} said {john's oh}=0A+ 700: {hari bhimaraju} said {i love dear ma=
ma}=0A+ 701: {elaine } said {it is good weather toda}=0A+ 702: {Chris} said=
 {why only lookup once?}=0A+ 703: {elaine} said {halloween}=0A+ 704: {Alana=
 Greenaway} said {I have a dog named Stan}=0A+ 705: {Alana Greenaway} said =
{I love programming!}=0A+ 706: {Alana Greenaway} said {I'm from Boston}=0A+=
 707: {1234} said {1234}=0A+ 708: {PoTing Chen} said {live is arduous}=0A+ =
709: {Fatoumata Camar} said {Hello :)))}=0A+ 710: {Sreya} said {What is you=
r costume?}=0A+ 711: {Fatoumata Camar} said {It worked slayy!}=0A+ 712: {Sr=
eya} said {AP is so fun!}=0A+ 713: {Emily Ye} said {dugtrio has beautiful h=
}=0A+ 714: {Emily Ye} said {veggies scream}=0A+ 715: {vincentr  [C   } said=
 {hello}=0A+ 716: {kulkarni} said {hello mdb!}=0A+ 717: {kulkarni} said {ia=
macademicallyhonest}=0A+ 718: {kulkarni} said {theworldisending}=0A+ 719: {=
kulkarni} said {iliketrains}=0A+ 720: {Sreya} said {Hello Hi Hody}=0A+ 721:=
 {kate} said {hi}=0A+ 722: {Josh Nam} said {Yale ML}=0A+ 723: {Josh Nam} sa=
id {I like books}=0A+ 724: {Alicia} said {hello}=0A+ 725: {Alex Michelon} s=
aid {:)}=0A+ 726: {nicole} said {anti-ti-ti-ti fragile}=0A+ 727: {Johnny C}=
 said {if you love something}=0A+ 728: {Johnny C} said {set it free}=0A+ 72=
9: {Johnny C} said {If it comes back}=0A+ 730: {Johnny C} said {You've fail=
ed valgrind}=0A+ 731: {Johnny C} said {Friends don't let frien}=0A+ 732: {J=
ohnny C} said {reference pointers}=0A+ 733: {Riley} said {is the funniest}=
=0A+ 734: {Riley} said {catch me outside}=0A+ 735: {piers} said {im prob us=
ing a late da}=0A+ 736: {LILAH} said {LILAH was here}=0A+ 737: {LILAH} said=
 {i am very hungry}=0A+ 738: {Johhny C} said {They have no seg faults}=0A+ =
739: {Johnny C} said {but they don't know}=0A+ 740: {Johnny C} said {how to=
 exit a loop?}=0A+ 741: {testtt} said {testing database}=0A+ 742: {studentt=
t} said {ap is fun}=0A+ 743: {bobert} said {I am bobert}=0A+ 744: {Eric Kim=
} said {Hi this is my message f}=0A+ 745: {f} said {f}=0A+ 746: {potato} sa=
id {I am a potato}=0A+ 747: {Jlam} said {Happy halloween!}=0A+ 748: {Jake} =
said {This is Ken}=0A+ 749: {Hodor} said {Hold the door!}=0A+ 750: {Matt} s=
aid {Good Luck Everyone!}=0A+ 751: {Mike} said {Waltuh }=0A+ 752: {Jimmy} s=
aid {Better Call Saul!}=0A+ 753: {kate} said {test}=0A+ 754: {Avery} said {=
(pp   [C [C [D [C [C [C}=0A+ 755: {Ac very} said {(T^T)}=0A+ 756: {Avery} s=
aid {failing fundies exam}=0A+ 757: {} said {}=0A+ 758: {Gordon Freeman} sa=
id {...............}=0A+ 759: {Bad friend} said {a can of beer will be o}=
=0A+ 760: {Guillermo} said {Hello}=0A+ 761: {Obi Wan} said {Hello there!}=
=0A+ 762: {Yuya} said {Happy Halloween!}=0A+ 763: {Yuya} said {hewwo :)}=0A=
+ 764: {Grievous} said {General Kenobi!}=0A+ 765: {Steven Wang} said {i <3 =
you}=0A+ 766: {Steven Wang} said {-^_^-}=0A+ 767: {Kristine Pham} said {I w=
ant pork buns}=0A+ 768: {Arman} said {I procrastinated this s}=0A+ 769: {ku=
chbenarman} said {hail the king}=0A+ 770: {ohh} said {gonna use late days..=
=2E}=0A+ 771: {markus tran} said {oh no oh no oh no}=0A+ 772: {Shrek} said =
{Get out of my swamp!}=0A+ 773: {brian} said {hello wordle}=0A+ 774: {gasto=
n} said {pushups are easy}=0A+ 775: {binarytree} said {inverse me please}=
=0A+ 776: {Aaron} said {On law, morality, and p}=0A+ 777: {Andrew} said {My=
 name is AC}=0A+ 778: {hank azaria} said {i am homer from simpson}=0A+ 779:=
 {I knew it was 1} said {I knew it was 1216. One}=0A+ 780: {} said {} said =
{} said {}=0A+ 781: {he} said {she} said {}=0A+ 782: {testinngggggggg} said=
 {tetstetestetetettetetes}=0A+ 783: {darth vader} said {i aint got no son}=
=0A+ 784: {friday night} said {tgid f}=0A+ 785: {xiaolaohu} said {I will ea=
t the cs3157 s}=0A+ 786: {Song} said {Hello! Goodbye and Hell}=0A+ 787: {} =
said {}=0A+ 788: {vincent} said {yo}=0A+ 789: {vincent     } said {hello}=
=0A+ 790: {Naomi} said {hello}=0A+ 791: {Cat} said {bye}=0A+ 792: {most fun=
} said {class -AP <3}=0A+ 793: {Class } said {Cameria for TA}=0A+ 794: {^^}=
 said {^_^ <3}=0A+ 795: {who is} said {Johnny C}=0A+ 796: {Wonkers} said {H=
i Zoe}=0A+ 797: {JP Morggy} said {mmm finance}=0A+ 798: {Yonseung Choi} sai=
d {Lab Workflow}=0A+ 799: {catarina coelho} said {oieee}=0A+ 800: {catarina=
 coelho} said {22 days for the world c}=0A+ 801: {catarina coelho} said {va=
i brasil uhu}=0A+ 802: {king} said {K}=0A+ 803: {erica} said {testing 123}=
=0A+ 804: {Erica} said {10:39 on a Saturday in }=0A+ 805: {Dale Yu} said {S=
hould've started this }=0A+ 806: {Dale Yu} said {Nguyen Tran Brawlstars }=
=0A+ 807: {I love John Hui} said {I love John Hui <3}=0A+ 808: {Dale Yu} sa=
id {I love John Hui <3}=0A+ 809: {Justin Bieber} said {Baaayby}=0A+ 810: {S=
hifu } said {Dragon Warrior!!!}=0A+ 811: {She said} said {That's what}=0A+ =
812: {Dhwani} said {Happy Halloween!}=0A+ 813: {Joseph Han} said {Explainin=
g the undexpla}=0A+ 814: {kyz2005} said {hi}=0A+ 815: {Merry} said {I love =
your island <3}=0A+ 816: {Blissey} said {My eggs are going bad..}=0A+ 817: =
{} said {      }=0A+ 818: {yassuo} said {alreadylate!!}=0A+ 819: {Joseph Ha=
n} said {IS the size always mult}=0A+ 820: {Khadija} said {using add databa=
se}=0A+ 821: {Jacklyn} said {Hi Jessica <3}=0A+ 822: {Jacklyn} said {Hi Pre=
ach <3}=0A+ 823: {Jacklyn} said {Hi Melina <3}=0A+ 824: {Jacklyn} said {Hi =
Annika <3}=0A+ 825: {Jane} said {Hi!}=0A+ 826: {Jacklyn } said {Hello Dhwan=
i <3}=0A+ 827: {Mr. Brown} said {Mr. Brown says like Mr.}=0A+ 828: {Annika}=
 said {Hi Jacklyn!}=0A+ 829: {Bailey} said {I walked UWS w/ bat win}=0A+ 83=
0: {Wilbur } said {Grrr}=0A+ 831: {Khadija} said {still working}=0A+ 832: {=
Yongcen Zhou} said {let's start lab4}=0A+ 833: {} said {}=0A+ 834: {Heon Ki=
m} said {hello world}=0A+ 835: {Heon} said {hihihihihihihi}=0A+ 836: {Krist=
ine Pham} said {I want ice cream}=0A+ 837: {Chase} said {NFTs}=0A+ 838: {ri=
ck} said {never gonna give you up}=0A+ 839: {rick} said {never gonna let yo=
u dow}=0A+ 840: {rick} said {never gonna run around }=0A+ 841: {ava} said {=
messagetesting}=0A+ 842: {jean} said {uhedjhabs}=0A+ 843: {Carlos} said {Dr=
=2E Strange}=0A+ 844: {kynnedy} said {yay AP!}=0A+ 845: {Iron Man} said {I'=
m the best.}=0A+ 846: {test} said {12345678901234567890123}=0A+ 847: {Soomi=
n Kim} said {have a nice day}=0A+ 848: {The Joker} said {We live in a socie=
ty}=0A+ 849: {I} said {We really do live in a }=0A+ 850: {Art Vandelay} sai=
d {Importer/Exporter}=0A+ 851: {George C.} said {I'm shifting into soup }=
=0A+ 852: {I} said {society}=0A+ 853: {Newman} said {To the Newmanium!}=0A+=
 854: {Cosmo Kramer} said {To the Kramanium!}=0A+ 855: {avighna} said {hell=
oooo <3}=0A+ 856: {Frank C.} said {I wear sneakers in the }=0A+ 857: {avigh=
na} said {hello kitty}=0A+ 858: {Theo} said {is cool}=0A+ 859: {pru} said {=
hello there :)}=0A+ 860: {grunt} said {nap time}=0A+ 861: {Sophia} said {he=
llo}=0A+ 862: {K} said {K}=0A+ 863: {Kanavi} said {Loveya}=0A+ 864: {Nobody=
} said {e   [C [C    [Ccoding  }=0A+ 865: {jas} said {it is not a happy sat=
ur}=0A+ 866: {john hui} said {-john}=0A+ 867: {Paul} said {2 Late Days Gone=
 sigh.}=0A+ 868: {Luigi} said {Truly, it is worse.}=0A+ 869: {Dan} said {In=
teresting}=0A+ 870: {Nick} said {I start too late}=0A+ 871: {Amin} said {WA=
ZZZUUUPPP}=0A+ 872: {Jennifer Huang} said {Waddup shawty}=0A+ 873: {Jennife=
r Huang} said {if ur bald, where does }=0A+ 874: {Jennifer Huang} said {ur =
forehead end ?}=0A+ 875: {Luke Xue} said {I'm eating dinner}=0A+ 876: {john=
} said {welcome to sp}=0A+ 877: {Erica} said {8:54 on Sat still here}=0A+ 8=
78: {ur mom} said {hello son}=0A+ 879: {brianna} said {i want ice cream}=0A=
+ 880: {jtrf} said {London}=0A+ 881: {Guy} said {trick or treat!}=0A+ 882: =
{Germ} said {hello}=0A+ 883: {Bereket} said {Hi everyone!}=0A+ 884: {Shahan=
a} said {Hi!}=0A+ 885: {Shahana} said {Cats are superior being}=0A+ 886: {R=
ohan} said {I love you}=0A+ 887: {Rohan } said {It is a hard assignment}=0A=
+ 888: {Crobat} said {Nasty Plot set is best}=0A+ 889: {kaylee} said {happy=
 halloween}=0A+ 890: {everyone} said {i love sleep}=0A+ 891: {Hae Myung Yim=
} said {Good Life}=0A+ 892: {Khadija} said {checking}=0A+ 893: {Isayama} sa=
id {za worldou}=0A+ 894: {nira} said {:) <3}=0A+ 895: {Chase} said {NFTs ar=
e cool}=0A+ 896: {eevee} said {i was very sick}=0A+ 897: {he he} said {yoyo=
yo}=0A+ 898: {evan} said {I want brunch}=0A+ 899: {User 1} said {Automated =
message.}=0A+ 900: {Melody} said {Happy Halloween}=0A+ 901: {Gillian} said =
{Finished Lab4!}=0A+ 902: {} said {}=0A+ 903: {\n} said {\0}=0A+ 904: {'\n'=
} said {'\0'}=0A+ 905: {null} said {NULL}=0A+ 906: {Lexis} said {Happy Hall=
oweekenddd}=0A+=0A+lookup:  863: {Kanavi} said {Loveya}=0A+=0A+lookup: =3D=
=3D201254=3D=3D =0A+=3D=3D201254=3D=3D HEAP SUMMARY:=0A+=3D=3D201254=3D=3D =
    in use at exit: 0 bytes in 0 blocks=0A+=3D=3D201254=3D=3D   total heap =
usage: 1,816 allocs, 1,816 frees, 60,936 bytes allocated=0A+=3D=3D201254=3D=
=3D =0A+=3D=3D201254=3D=3D All heap blocks were freed -- no leaks are possi=
ble=0A+=3D=3D201254=3D=3D =0A+=3D=3D201254=3D=3D For lists of detected and =
suppressed errors, rerun with: -s=0A+=3D=3D201254=3D=3D ERROR SUMMARY: 0 er=
rors from 0 contexts (suppressed: 0 from 0)=0Adiff --git a/part1/mdb-lookup=
=2Ec b/part1/mdb-lookup.c=0Aindex fa5bf71..9d9d420 100644=0A--- a/part1/mdb=
-lookup.c=0A+++ b/part1/mdb-lookup.c=0A@@ -4,11 +4,11 @@=0A #include "mdb.h=
"=0A #include <string.h>=0A =0A-    void printRec(void *rec){=0A-        st=
ruct MdbRec *record =3D (struct MdbRec *) rec;=0A-        printf("This is t=
he name: %s\n",(const char *)record->name);=0A-        printf("This is the =
message: %s\n",(const char *)record->msg);        =0A-    }=0A+void printRe=
c(void *rec){=0A+    struct MdbRec *record =3D (struct MdbRec *) rec;=0A+  =
  printf("This is the name: %s\n",(const char *)record->name);=0A+    print=
f("This is the message: %s\n",(const char *)record->msg);        =0A+}=0A =
=0A int main(int argc, char **argv) {=0A     /*=0A@@ -28,15 +28,15 @@ int m=
ain(int argc, char **argv) {=0A     }=0A =0A     struct List list;=0A+  =0A=
     initList(&list);=0A =0A     /*=0A-     * Read the file line-by-line, p=
rinting out line numbers as we go.=0A+     * Read the file line-by-line, co=
pying line numbers into a list as we go.=0A      */=0A =0A     // Define a =
buffer we will read each line into.=0A-   =0A-    =0A+     =0A     size_t s=
ize =3D sizeof(struct MdbRec);=0A     char buf[size];   =0A     int len;=0A=
@@ -44,7 +44,9 @@ int main(int argc, char **argv) {=0A     while((len =3D f=
read(buf, 1, size, fp)) > 0) {=0A          =0A        if(len !=3D (int) siz=
e ){=0A-           perror("Didn't read enough bytes!");=0A+           perro=
r("The size of this database file is not a multiple of 40!");=0A+          =
 traverseList(&list, &free);=0A+           removeAllNodes(&list);=0A       =
     exit(1);=0A        }=0A        // char name[16];=0A@@ -55,23 +57,26 @@=
 int main(int argc, char **argv) {=0A         struct MdbRec *record =3D mal=
loc(size);=0A         if(record =3D=3D NULL){=0A             perror("malloc=
 returned NULL");=0A+            traverseList(&list, &free);=0A+           =
 removeAllNodes(&list);=0A             exit(1);=0A         }=0A            =
=0A         memcpy(record->name,  buf, 16);=0A         memcpy(record->msg, =
buf + 16, 24);=0A-       =0A-      =0A+        =0A         =0A         prev=
 =3D addAfter(&list, prev, record); =0A         if(prev =3D=3D NULL){=0A-  =
          perror("Couldn't add after!");=0A+            perror("Couldn't ad=
d the next data in!");=0A+            traverseList(&list, &free);=0A+      =
      removeAllNodes(&list);=0A             exit(1);=0A         } =0A     }=
=0A =0A     /*=0A-     * Did we terminate the fgets() loop because of an er=
ror?=0A+     * Did we terminate the fread() loop because of an error?=0A   =
   * If so, report the error.=0A      */=0A =0A@@ -80,18 +85,21 @@ int main=
(int argc, char **argv) {=0A         exit(1);=0A     }=0A =0A+    fclose(fp=
);=0A+=0A     // traverseList(&list, &printRec);=0A     =0A+    // printf("=
%s\n", buf);=0A+    =0A     =0A-   // printf("%s\n", buf);=0A-    printf("l=
ookup: ");=0A     =0A-    int n =3D 7; =0A-    char buf2[n];=0A+    char bu=
f2[500];=0A      =0A+    printf("lookup: ");=0A+=0A     while(fgets(buf2, s=
izeof(buf2), stdin)){=0A-        int sizeOfString;=0A-        =0A+       =
=0A+        int sizeOfString; =0A        // printf("This the buffer before:=
 %s\n", buf2);=0A         =0A         if(strlen(buf2)<=3D6){=0A@@ -119,42 +=
127,32 @@ int main(int argc, char **argv) {=0A             struct MdbRec *r=
ecord;=0A             while(curr !=3D NULL){=0A                 record =3D =
(struct MdbRec *) curr->data;=0A-               // printf("The name: %s\n",=
record->name);  =0A-               // printf("The msg: %s\n",record->msg);=
=0A+                // printf("The name: %s\n",record->name);  =0A+        =
        // printf("The msg: %s\n",record->msg);=0A =0A                 if(s=
trstr(record->name,string) !=3D NULL){=0A                     printf("%4d: =
{%s} said {%s}\n",lineno, record->name, record->msg);=0A                 }e=
lse if(strstr(record->msg,string) !=3D NULL){=0A-                    printf=
("%4d: {%s} said  {%s}\n",lineno, record->name, record->msg);=0A+          =
          printf("%4d: {%s} said {%s}\n",lineno, record->name, record->msg)=
;=0A                 }=0A                  =0A                 lineno++;=0A=
                 curr =3D curr->next;=0A         }=0A-            printf("\=
n");=0A =0A-  =0A+    printf("\nlookup: ");=0A+   =0A+    // fseek(stdin, 0=
, SEEK_END);   =0A    =0A-    printf("lookup: ");=0A-    =0A-    =0A-   // =
fseek(stdin, 0, SEEK_END);   =0A-=0A     }=0A-=0A     =0A+    traverseList(=
&list, &free);=0A+    removeAllNodes(&list);   =0A =0A     if (ferror(stdin=
)) {=0A-        perror("There was an error in stdin");=0A+        perror("T=
here was an error in stdin.");=0A         exit(1);=0A     }=0A =0A-    trav=
erseList(&list, &free);=0A-    removeAllNodes(&list);=0A-    /*=0A-     * C=
lose our file pointer, and quit.=0A-     */=0A-=0A-    fclose(fp);=0A     r=
eturn 0;=0A }=0A-- =0A2.34.1=0A=0A
--QawcFD8xKR5FIQzb--

From do.not.reply@cloud.cs.columbia.edu Sat Nov 12 00:20:44 2022
Date: Sat, 12 Nov 2022 00:20:44 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab5.mbox
Message-ID: <Y28tLPdIM10GXl7k@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="PnLJWAQtfrbtxhV2"
Content-Disposition: inline
Status: RO
Content-Length: 37877
Lines: 936


--PnLJWAQtfrbtxhV2
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 4bb7b158b89462c168e022c1c2605a5b6c909b05 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 7 Nov 2022 01:01:03 -0500
Subject: [PATCH 1/8] First commit, wrote Makefile and created http-client.c
 and added some code.

---
 Makefile      | 10 +++++++
 http-client.c | 74 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 84 insertions(+)
 create mode 100644 Makefile
 create mode 100644 http-client.c

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..eaaf81c
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,10 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+http-client:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o tcp-http-client
diff --git a/http-client.c b/http-client.c
new file mode 100644
index 0000000..5d16284
--- /dev/null
+++ b/http-client.c
@@ -0,0 +1,74 @@
+// Because we are using POSIX features that aren't part of the C standard, we
+// need to #define this macro before #including standard library headers to be
+// granted access to POSIX-specific definitions such as struct addrinfo.
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+/*
+ * Convenient error handler for printing errno-associated message and exit(1).
+ */
+static void die(char *msg) {
+    perror(msg);
+    exit(1);
+}
+
+int main(int argc, char **argv) {
+    /*
+     * Check and obtain command-line arguments
+     */
+    if (argc != 4) {
+        fprintf(stderr, "Usage: %s <host> <port-number> <URI>\n",
+                argv[0]);
+        exit(1);
+    }
+
+    char *host = argv[1];
+    char *port_number = argv[2];
+    char *URI = argv[3];
+
+    /*
+     * Obtain server address information using getaddrinfo().
+     */
+
+    // Define hints for getaddrinfo(), which we need to zero out first.
+    struct addrinfo hints;
+    memset(&hints, 0, sizeof(hints));
+
+    // Specify what kind of connection we intend to make; these values tell
+    // getaddrinfo() that we don't care about other kinds of addresses.
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    int addr_err;
+    if ((addr_err = getaddrinfo(host, port_number, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (connect(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("connect");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info);
+
+}
+
-- 
2.34.1


From 4d459eda6cb421ad1e6ee698b27f5ac4f079ad7a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 7 Nov 2022 02:42:40 -0500
Subject: [PATCH 2/8] I had accidentally created the files without part1
 directory. Corrected that now.

---
 Makefile => part1/Makefile           |  2 +-
 http-client.c => part1/http-client.c | 11 ++++++++++-
 2 files changed, 11 insertions(+), 2 deletions(-)
 rename Makefile => part1/Makefile (75%)
 rename http-client.c => part1/http-client.c (90%)

diff --git a/Makefile b/part1/Makefile
similarity index 75%
rename from Makefile
rename to part1/Makefile
index eaaf81c..97ad8bb 100644
--- a/Makefile
+++ b/part1/Makefile
@@ -7,4 +7,4 @@ http-client:
 
 .PHONY: clean
 clean:
-	rm -rf a.out *.o tcp-http-client
+	rm -rf a.out *.o http-client
diff --git a/http-client.c b/part1/http-client.c
similarity index 90%
rename from http-client.c
rename to part1/http-client.c
index 5d16284..f146fb7 100644
--- a/http-client.c
+++ b/part1/http-client.c
@@ -62,13 +62,22 @@ int main(int argc, char **argv) {
 
     int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
     if (serv_fd < 0)
-        die("socket");
+       die("socket");
 
     if (connect(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
         die("connect");
 
     // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
     freeaddrinfo(info);
+        
+    char *request = "
+    int send(int sockfd, const void *buf, size_t len, int flags);
 
+    /*
+    GET /index.html HTTP/1.0
+    Host: %s:%s
+    User-Agent: curl/7.83.1
+    Accept: */
+                
 }
 
-- 
2.34.1


From 179b73526a4ab410a1772e5c5df1b0a736fff222 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 7 Nov 2022 04:14:36 -0500
Subject: [PATCH 3/8] Now I can send a request and copy the response to a file.
 But I copy the entire response now, should fix that!

---
 part1/http-client.c | 42 +++++++++++++++++++++++++++++++++---------
 1 file changed, 33 insertions(+), 9 deletions(-)

diff --git a/part1/http-client.c b/part1/http-client.c
index f146fb7..73269fe 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -69,15 +69,39 @@ int main(int argc, char **argv) {
 
     // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
     freeaddrinfo(info);
-        
-    char *request = "
-    int send(int sockfd, const void *buf, size_t len, int flags);
+   
+    FILE *sock_fp = fdopen(serv_fd, "rb");  
+    
+    char *name = strrchr(URI,'/');
+    
+    if(name == NULL)
+        die("wrong URI");
+    
+    FILE *file = fopen(++name,"wb");
 
-    /*
-    GET /index.html HTTP/1.0
-    Host: %s:%s
-    User-Agent: curl/7.83.1
-    Accept: */
-                
+    char buf[1000];    
+
+    send(serv_fd, "GET ", 4, 0);
+    send(serv_fd, URI, strlen(URI), 0);
+    send(serv_fd, " HTTP/1.0\r\n", 11, 0);
+    send(serv_fd, "Host: ", 6, 0);
+    send(serv_fd, host, strlen(host), 0);
+    send(serv_fd, ":", 1, 0);
+    send(serv_fd, port_number, strlen(port_number), 0);
+    send(serv_fd, "\r\n", 2, 0);
+    send(serv_fd, "Accept: */*\r\n", 13, 0);
+    send(serv_fd, "\r\n", 2, 0);
+   
+    int len;
+    
+    while((len = fread(buf, 1, sizeof(buf)-1, sock_fp))>0){
+        buf[len] = '\0';
+        fputs(buf, file);
+    }
+
+    fputs("\n", file); 
+   
+    fclose(sock_fp);
+    fclose(file);
 }
 
-- 
2.34.1


From 8dd19767eeecf32ae057b8777fe4f1dd5a97d8e7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 7 Nov 2022 22:00:35 -0500
Subject: [PATCH 4/8] Now I can do the basic functions, but will have to tidy
 up my code and prevent potential errors and take care of edge cases.

---
 part1/Makefile      |  2 +-
 part1/http-client.c | 63 ++++++++++++++++++++++++++++++++++-----------
 2 files changed, 49 insertions(+), 16 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index 97ad8bb..234cc80 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -7,4 +7,4 @@ http-client:
 
 .PHONY: clean
 clean:
-	rm -rf a.out *.o http-client
+	rm -rf a.out *.o *.html *.html.1 *.jpg *.jpg.1 *.jpeg *.jpeg.1 *.png *.png.1 http-client
diff --git a/part1/http-client.c b/part1/http-client.c
index 73269fe..a60265c 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -71,15 +71,7 @@ int main(int argc, char **argv) {
     freeaddrinfo(info);
    
     FILE *sock_fp = fdopen(serv_fd, "rb");  
-    
-    char *name = strrchr(URI,'/');
-    
-    if(name == NULL)
-        die("wrong URI");
-    
-    FILE *file = fopen(++name,"wb");
-
-    char buf[1000];    
+        
 
     send(serv_fd, "GET ", 4, 0);
     send(serv_fd, URI, strlen(URI), 0);
@@ -91,15 +83,56 @@ int main(int argc, char **argv) {
     send(serv_fd, "\r\n", 2, 0);
     send(serv_fd, "Accept: */*\r\n", 13, 0);
     send(serv_fd, "\r\n", 2, 0);
-   
-    int len;
     
-    while((len = fread(buf, 1, sizeof(buf)-1, sock_fp))>0){
-        buf[len] = '\0';
-        fputs(buf, file);
+
+    char a;
+    while((a = fgetc(sock_fp)) != ' ');
+
+    int i = 0;
+    char buf2[50] = {0};
+
+    if((a = fgetc(sock_fp)) != '2'){
+       buf2[i++] = (char) a;
+       buf2[i++] = fgetc(sock_fp);
+       while(buf2[i-2] != '\r' || buf2[i-1] != '\n'){
+           buf2[i++] = fgetc(sock_fp);
+       }
+       buf2[i-2] = '\n';
+       buf2[i-1] = 0;
+
+       printf("%s",buf2);
+       exit(1);
     }
 
-    fputs("\n", file); 
+    char *name = strrchr(URI,'/');
+ 
+    if(name == NULL)
+        die("wrong URI");
+ 
+    FILE *file = fopen(++name,"wb");
+    
+    char check[4] = {0};
+    i = 0;
+
+    char msg[1000] = {0}; 
+    int j = 0;
+
+    while(check[i] != '\r' || check[(i + 1) % 4] != '\n' || check[(i + 2) % 4] != '\r' || check[(i + 3) % 4] != '\n'){
+        check[i] = fgetc(sock_fp);
+        msg[j++] = check[i];   
+        i = (i + 1) % 4;
+    }
+    
+    msg[j] = '\n';
+
+    printf("%s", msg);
+
+    int len;
+    char buf[500];
+
+    while((len = fread(buf, 1, sizeof(buf), sock_fp))>0){
+        fwrite(buf, 1, len, file);
+    } 
    
     fclose(sock_fp);
     fclose(file);
-- 
2.34.1


From 9c62b3d8d311c64168ef51c7cc5a217d39a073a7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 7 Nov 2022 23:04:51 -0500
Subject: [PATCH 5/8] Made small changes on http-client.c!

---
 part1/http-client.c | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/part1/http-client.c b/part1/http-client.c
index a60265c..a4f8350 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -85,12 +85,13 @@ int main(int argc, char **argv) {
     send(serv_fd, "\r\n", 2, 0);
     
 
-    char a;
-    while((a = fgetc(sock_fp)) != ' ');
+   
+    while(fgetc(sock_fp) != ' ');
 
     int i = 0;
-    char buf2[50] = {0};
-
+    char buf2[1000] = {0};
+    
+    char a;    
     if((a = fgetc(sock_fp)) != '2'){
        buf2[i++] = (char) a;
        buf2[i++] = fgetc(sock_fp);
@@ -111,24 +112,25 @@ int main(int argc, char **argv) {
  
     FILE *file = fopen(++name,"wb");
     
+
+
     char check[4] = {0};
     i = 0;
-
-    char msg[1000] = {0}; 
-    int j = 0;
+    //char msg[1000] = {0}; 
+    //int j = 0;
 
     while(check[i] != '\r' || check[(i + 1) % 4] != '\n' || check[(i + 2) % 4] != '\r' || check[(i + 3) % 4] != '\n'){
         check[i] = fgetc(sock_fp);
-        msg[j++] = check[i];   
+       // msg[j++] = check[i];   
         i = (i + 1) % 4;
     }
     
-    msg[j] = '\n';
+    //msg[j] = '\n';
 
-    printf("%s", msg);
+    //printf("%s", msg);
 
     int len;
-    char buf[500];
+    char buf[1000];
 
     while((len = fread(buf, 1, sizeof(buf), sock_fp))>0){
         fwrite(buf, 1, len, file);
-- 
2.34.1


From fcf69c82e00dd20a4943c4beb7c3caea2783dcd6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 11 Nov 2022 01:17:01 -0500
Subject: [PATCH 6/8] make a change to http-client.c to make it print error
 messages correctly.

---
 part1/http-client.c | 70 +++++++++++++++++++++++++++++----------------
 1 file changed, 46 insertions(+), 24 deletions(-)

diff --git a/part1/http-client.c b/part1/http-client.c
index a4f8350..0af4f22 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -85,43 +85,49 @@ int main(int argc, char **argv) {
     send(serv_fd, "\r\n", 2, 0);
     
 
-   
-    while(fgetc(sock_fp) != ' ');
-
+    char buf[1000] = {0};
     int i = 0;
-    char buf2[1000] = {0};
-    
-    char a;    
-    if((a = fgetc(sock_fp)) != '2'){
-       buf2[i++] = (char) a;
-       buf2[i++] = fgetc(sock_fp);
-       while(buf2[i-2] != '\r' || buf2[i-1] != '\n'){
-           buf2[i++] = fgetc(sock_fp);
+
+    while((buf[i++]=fgetc(sock_fp)) != ' '); //to move the stream pointer to the first char of the status code of the HTTP response header
+
+    char a;
+
+    if((a = fgetc(sock_fp)) != '2'){ // if there is an error
+       buf[i++] = (char) a;
+ 
+       while(buf[i-2] != '\r' || buf[i-1] != '\n'){
+           buf[i++] = fgetc(sock_fp);
        }
-       buf2[i-2] = '\n';
-       buf2[i-1] = 0;
+       buf[i-2] = '\n';
+       buf[i-1] = 0;
 
-       printf("%s",buf2);
-       exit(1);
+       printf("%s\n",buf);
+       //fflush(stdout);
+
+       fclose(sock_fp);
+       exit(1); //ask about this to John 1 or 0
     }
 
     char *name = strrchr(URI,'/');
- 
+    
+
     if(name == NULL)
         die("wrong URI");
  
-    FILE *file = fopen(++name,"wb");
+   
+    FILE *file = fopen(++name, "wb"); //increment the address pointer to skip /
     
 
 
-    char check[4] = {0};
+    char check[4] = {0}; // I will store the most recent four bytes of the HTTP response until I get /r/n/r/n
     i = 0;
+   
     //char msg[1000] = {0}; 
     //int j = 0;
 
     while(check[i] != '\r' || check[(i + 1) % 4] != '\n' || check[(i + 2) % 4] != '\r' || check[(i + 3) % 4] != '\n'){
         check[i] = fgetc(sock_fp);
-       // msg[j++] = check[i];   
+        // msg[j++] = check[i];   
         i = (i + 1) % 4;
     }
     
@@ -130,13 +136,29 @@ int main(int argc, char **argv) {
     //printf("%s", msg);
 
     int len;
-    char buf[1000];
-
-    while((len = fread(buf, 1, sizeof(buf), sock_fp))>0){
-        fwrite(buf, 1, len, file);
+    int len2;
+    char inputBuf[1000] = {0};
+
+    while((len = fread(inputBuf, 1, sizeof(inputBuf), sock_fp))>0){
+         if(ferror(sock_fp)){
+             fclose(sock_fp);
+             fclose(file);
+             die("error in reading from a socket file");
+         }   
+
+        if((len2 = fwrite(inputBuf, 1, len, file) < len)) {
+            fclose(sock_fp);
+            fclose(file);
+            die("error in writing to a file");
+        }
     } 
    
+    if(ferror(sock_fp)){
+        fclose(sock_fp);
+        fclose(file);
+        die("error in reading from a socket file");
+    }
+        
     fclose(sock_fp);
     fclose(file);
 }
-
-- 
2.34.1


From e3a81428c14dc5cd13f95fd25d85dc1fc869963a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 11 Nov 2022 03:31:23 -0500
Subject: [PATCH 7/8] Added an error-checking if statement for fopen!

---
 part1/http-client.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/part1/http-client.c b/part1/http-client.c
index 0af4f22..002c62e 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -109,15 +109,16 @@ int main(int argc, char **argv) {
     }
 
     char *name = strrchr(URI,'/');
-    
 
     if(name == NULL)
         die("wrong URI");
- 
-   
-    FILE *file = fopen(++name, "wb"); //increment the address pointer to skip /
     
+    name++; // increment the address pointer to skip
 
+    FILE *file = fopen(name, "wb");     
+    if(file == NULL)
+        die("fopen");
+    
 
     char check[4] = {0}; // I will store the most recent four bytes of the HTTP response until I get /r/n/r/n
     i = 0;
-- 
2.34.1


From 4216f2f30e82f391bc8d3213429ae3b1e6013d6a Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 12 Nov 2022 00:16:10 -0500
Subject: [PATCH 8/8] I included valgrind output in readme and is ready for
 submit.

---
 README.txt          | 22 ++++++++++++++++++----
 part1/http-client.c | 16 ++++++++++------
 2 files changed, 28 insertions(+), 10 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..7f40003 100644
--- a/README.txt
+++ b/README.txt
@@ -1,11 +1,25 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 5 
+  - My code should work as intended.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==600591== Memcheck, a memory error detector
+==600591== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==600591== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==600591== Command: ./http-client www.gnu.org 80 /software/make/manual/make.html
+==600591== 
+==600591== 
+==600591== HEAP SUMMARY:
+==600591==     in use at exit: 0 bytes in 0 blocks
+==600591==   total heap usage: 36 allocs, 36 frees, 36,095 bytes allocated
+==600591== 
+==600591== All heap blocks were freed -- no leaks are possible
+==600591== 
+==600591== For lists of detected and suppressed errors, rerun with: -s
+==600591== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/part1/http-client.c b/part1/http-client.c
index 002c62e..066ca37 100644
--- a/part1/http-client.c
+++ b/part1/http-client.c
@@ -110,15 +110,19 @@ int main(int argc, char **argv) {
 
     char *name = strrchr(URI,'/');
 
-    if(name == NULL)
-        die("wrong URI");
-    
+    if(name == NULL){
+        printf("wrong URI\n");
+        fclose(sock_fp);
+        exit(1);
+    }
+
     name++; // increment the address pointer to skip
 
     FILE *file = fopen(name, "wb");     
-    if(file == NULL)
+    if(file == NULL){
+        fclose(sock_fp);
         die("fopen");
-    
+    }
 
     char check[4] = {0}; // I will store the most recent four bytes of the HTTP response until I get /r/n/r/n
     i = 0;
@@ -153,7 +157,7 @@ int main(int argc, char **argv) {
             die("error in writing to a file");
         }
     } 
-   
+
     if(ferror(sock_fp)){
         fclose(sock_fp);
         fclose(file);
-- 
2.34.1


--PnLJWAQtfrbtxhV2
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab5.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 4bb7b158b89462c168e022c1c2605a5b6c909b05 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Mon, 7 Nov 2022 01:01:03 =
-0500=0ASubject: [PATCH 1/8] First commit, wrote Makefile and created http-=
client.c=0A and added some code.=0A=0A---=0A Makefile      | 10 +++++++=0A =
http-client.c | 74 +++++++++++++++++++++++++++++++++++++++++++++++++++=0A 2=
 files changed, 84 insertions(+)=0A create mode 100644 Makefile=0A create m=
ode 100644 http-client.c=0A=0Adiff --git a/Makefile b/Makefile=0Anew file m=
ode 100644=0Aindex 0000000..eaaf81c=0A--- /dev/null=0A+++ b/Makefile=0A@@ -=
0,0 +1,10 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3Dc17=0A+=
LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+http-client:=0A+=0A+.PHONY: clean=0A+clean=
:=0A+	rm -rf a.out *.o tcp-http-client=0Adiff --git a/http-client.c b/http-=
client.c=0Anew file mode 100644=0Aindex 0000000..5d16284=0A--- /dev/null=0A=
+++ b/http-client.c=0A@@ -0,0 +1,74 @@=0A+// Because we are using POSIX fea=
tures that aren't part of the C standard, we=0A+// need to #define this mac=
ro before #including standard library headers to be=0A+// granted access to=
 POSIX-specific definitions such as struct addrinfo.=0A+#define _GNU_SOURCE=
=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=0A=
+#include <unistd.h>=0A+=0A+#include <sys/types.h>=0A+#include <sys/socket.=
h>=0A+#include <arpa/inet.h>=0A+#include <netdb.h>=0A+=0A+/*=0A+ * Convenie=
nt error handler for printing errno-associated message and exit(1).=0A+ */=
=0A+static void die(char *msg) {=0A+    perror(msg);=0A+    exit(1);=0A+}=
=0A+=0A+int main(int argc, char **argv) {=0A+    /*=0A+     * Check and obt=
ain command-line arguments=0A+     */=0A+    if (argc !=3D 4) {=0A+        =
fprintf(stderr, "Usage: %s <host> <port-number> <URI>\n",=0A+              =
  argv[0]);=0A+        exit(1);=0A+    }=0A+=0A+    char *host =3D argv[1];=
=0A+    char *port_number =3D argv[2];=0A+    char *URI =3D argv[3];=0A+=0A=
+    /*=0A+     * Obtain server address information using getaddrinfo().=0A=
+     */=0A+=0A+    // Define hints for getaddrinfo(), which we need to zer=
o out first.=0A+    struct addrinfo hints;=0A+    memset(&hints, 0, sizeof(=
hints));=0A+=0A+    // Specify what kind of connection we intend to make; t=
hese values tell=0A+    // getaddrinfo() that we don't care about other kin=
ds of addresses.=0A+    hints.ai_family =3D AF_INET;        // Only accept =
IPv4 addresses=0A+    hints.ai_socktype =3D SOCK_STREAM;  // stream socket =
for TCP connections=0A+    hints.ai_protocol =3D IPPROTO_TCP;  // TCP proto=
col=0A+=0A+    // Define where getaddrinfo() will return the information it=
 found.=0A+    struct addrinfo *info;=0A+=0A+    // Call getaddrinfo(), spe=
cifying the server IP address and port as strings.=0A+    // getaddrinfo() =
will parse those for us and point info to the result.=0A+    int addr_err;=
=0A+    if ((addr_err =3D getaddrinfo(host, port_number, &hints, &info)) !=
=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_=
err));=0A+        exit(1);=0A+    }=0A+=0A+    int serv_fd =3D socket(info-=
>ai_family, info->ai_socktype, info->ai_protocol);=0A+    if (serv_fd < 0)=
=0A+        die("socket");=0A+=0A+    if (connect(serv_fd, info->ai_addr, i=
nfo->ai_addrlen) < 0)=0A+        die("connect");=0A+=0A+    // BTW: we're d=
one with the info retrieved by getaddrinfo(), so free it.=0A+    freeaddrin=
fo(info);=0A+=0A+}=0A+=0A-- =0A2.34.1=0A=0A=0AFrom 4d459eda6cb421ad1e6ee698=
b27f5ac4f079ad7a Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@colum=
bia.edu>=0ADate: Mon, 7 Nov 2022 02:42:40 -0500=0ASubject: [PATCH 2/8] I ha=
d accidentally created the files without part1=0A directory. Corrected that=
 now.=0A=0A---=0A Makefile =3D> part1/Makefile           |  2 +-=0A http-cl=
ient.c =3D> part1/http-client.c | 11 ++++++++++-=0A 2 files changed, 11 ins=
ertions(+), 2 deletions(-)=0A rename Makefile =3D> part1/Makefile (75%)=0A =
rename http-client.c =3D> part1/http-client.c (90%)=0A=0Adiff --git a/Makef=
ile b/part1/Makefile=0Asimilarity index 75%=0Arename from Makefile=0Arename=
 to part1/Makefile=0Aindex eaaf81c..97ad8bb 100644=0A--- a/Makefile=0A+++ b=
/part1/Makefile=0A@@ -7,4 +7,4 @@ http-client:=0A =0A .PHONY: clean=0A clea=
n:=0A-	rm -rf a.out *.o tcp-http-client=0A+	rm -rf a.out *.o http-client=0A=
diff --git a/http-client.c b/part1/http-client.c=0Asimilarity index 90%=0Ar=
ename from http-client.c=0Arename to part1/http-client.c=0Aindex 5d16284..f=
146fb7 100644=0A--- a/http-client.c=0A+++ b/part1/http-client.c=0A@@ -62,13=
 +62,22 @@ int main(int argc, char **argv) {=0A =0A     int serv_fd =3D soc=
ket(info->ai_family, info->ai_socktype, info->ai_protocol);=0A     if (serv=
_fd < 0)=0A-        die("socket");=0A+       die("socket");=0A =0A     if (=
connect(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A         die("conn=
ect");=0A =0A     // BTW: we're done with the info retrieved by getaddrinfo=
(), so free it.=0A     freeaddrinfo(info);=0A+        =0A+    char *request=
 =3D "=0A+    int send(int sockfd, const void *buf, size_t len, int flags);=
=0A =0A+    /*=0A+    GET /index.html HTTP/1.0=0A+    Host: %s:%s=0A+    Us=
er-Agent: curl/7.83.1=0A+    Accept: */=0A+                =0A }=0A =0A-- =
=0A2.34.1=0A=0A=0AFrom 179b73526a4ab410a1772e5c5df1b0a736fff222 Mon Sep 17 =
00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Mon, 7 Nov =
2022 04:14:36 -0500=0ASubject: [PATCH 3/8] Now I can send a request and cop=
y the response to a file.=0A But I copy the entire response now, should fix=
 that!=0A=0A---=0A part1/http-client.c | 42 +++++++++++++++++++++++++++++++=
++---------=0A 1 file changed, 33 insertions(+), 9 deletions(-)=0A=0Adiff -=
-git a/part1/http-client.c b/part1/http-client.c=0Aindex f146fb7..73269fe 1=
00644=0A--- a/part1/http-client.c=0A+++ b/part1/http-client.c=0A@@ -69,15 +=
69,39 @@ int main(int argc, char **argv) {=0A =0A     // BTW: we're done wi=
th the info retrieved by getaddrinfo(), so free it.=0A     freeaddrinfo(inf=
o);=0A-        =0A-    char *request =3D "=0A-    int send(int sockfd, cons=
t void *buf, size_t len, int flags);=0A+   =0A+    FILE *sock_fp =3D fdopen=
(serv_fd, "rb");  =0A+    =0A+    char *name =3D strrchr(URI,'/');=0A+    =
=0A+    if(name =3D=3D NULL)=0A+        die("wrong URI");=0A+    =0A+    FI=
LE *file =3D fopen(++name,"wb");=0A =0A-    /*=0A-    GET /index.html HTTP/=
1.0=0A-    Host: %s:%s=0A-    User-Agent: curl/7.83.1=0A-    Accept: */=0A-=
                =0A+    char buf[1000];    =0A+=0A+    send(serv_fd, "GET "=
, 4, 0);=0A+    send(serv_fd, URI, strlen(URI), 0);=0A+    send(serv_fd, " =
HTTP/1.0\r\n", 11, 0);=0A+    send(serv_fd, "Host: ", 6, 0);=0A+    send(se=
rv_fd, host, strlen(host), 0);=0A+    send(serv_fd, ":", 1, 0);=0A+    send=
(serv_fd, port_number, strlen(port_number), 0);=0A+    send(serv_fd, "\r\n"=
, 2, 0);=0A+    send(serv_fd, "Accept: */*\r\n", 13, 0);=0A+    send(serv_f=
d, "\r\n", 2, 0);=0A+   =0A+    int len;=0A+    =0A+    while((len =3D frea=
d(buf, 1, sizeof(buf)-1, sock_fp))>0){=0A+        buf[len] =3D '\0';=0A+   =
     fputs(buf, file);=0A+    }=0A+=0A+    fputs("\n", file); =0A+   =0A+  =
  fclose(sock_fp);=0A+    fclose(file);=0A }=0A =0A-- =0A2.34.1=0A=0A=0AFro=
m 8dd19767eeecf32ae057b8777fe4f1dd5a97d8e7 Mon Sep 17 00:00:00 2001=0AFrom:=
 Arman Ozcan <ao2794@columbia.edu>=0ADate: Mon, 7 Nov 2022 22:00:35 -0500=
=0ASubject: [PATCH 4/8] Now I can do the basic functions, but will have to =
tidy=0A up my code and prevent potential errors and take care of edge cases=
=2E=0A=0A---=0A part1/Makefile      |  2 +-=0A part1/http-client.c | 63 +++=
+++++++++++++++++++++++++++++++-----------=0A 2 files changed, 49 insertion=
s(+), 16 deletions(-)=0A=0Adiff --git a/part1/Makefile b/part1/Makefile=0Ai=
ndex 97ad8bb..234cc80 100644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=
=0A@@ -7,4 +7,4 @@ http-client:=0A =0A .PHONY: clean=0A clean:=0A-	rm -rf a=
=2Eout *.o http-client=0A+	rm -rf a.out *.o *.html *.html.1 *.jpg *.jpg.1 *=
=2Ejpeg *.jpeg.1 *.png *.png.1 http-client=0Adiff --git a/part1/http-client=
=2Ec b/part1/http-client.c=0Aindex 73269fe..a60265c 100644=0A--- a/part1/ht=
tp-client.c=0A+++ b/part1/http-client.c=0A@@ -71,15 +71,7 @@ int main(int a=
rgc, char **argv) {=0A     freeaddrinfo(info);=0A    =0A     FILE *sock_fp =
=3D fdopen(serv_fd, "rb");  =0A-    =0A-    char *name =3D strrchr(URI,'/')=
;=0A-    =0A-    if(name =3D=3D NULL)=0A-        die("wrong URI");=0A-    =
=0A-    FILE *file =3D fopen(++name,"wb");=0A-=0A-    char buf[1000];    =
=0A+        =0A =0A     send(serv_fd, "GET ", 4, 0);=0A     send(serv_fd, U=
RI, strlen(URI), 0);=0A@@ -91,15 +83,56 @@ int main(int argc, char **argv) =
{=0A     send(serv_fd, "\r\n", 2, 0);=0A     send(serv_fd, "Accept: */*\r\n=
", 13, 0);=0A     send(serv_fd, "\r\n", 2, 0);=0A-   =0A-    int len;=0A   =
  =0A-    while((len =3D fread(buf, 1, sizeof(buf)-1, sock_fp))>0){=0A-    =
    buf[len] =3D '\0';=0A-        fputs(buf, file);=0A+=0A+    char a;=0A+ =
   while((a =3D fgetc(sock_fp)) !=3D ' ');=0A+=0A+    int i =3D 0;=0A+    c=
har buf2[50] =3D {0};=0A+=0A+    if((a =3D fgetc(sock_fp)) !=3D '2'){=0A+  =
     buf2[i++] =3D (char) a;=0A+       buf2[i++] =3D fgetc(sock_fp);=0A+   =
    while(buf2[i-2] !=3D '\r' || buf2[i-1] !=3D '\n'){=0A+           buf2[i=
++] =3D fgetc(sock_fp);=0A+       }=0A+       buf2[i-2] =3D '\n';=0A+      =
 buf2[i-1] =3D 0;=0A+=0A+       printf("%s",buf2);=0A+       exit(1);=0A   =
  }=0A =0A-    fputs("\n", file); =0A+    char *name =3D strrchr(URI,'/');=
=0A+ =0A+    if(name =3D=3D NULL)=0A+        die("wrong URI");=0A+ =0A+    =
FILE *file =3D fopen(++name,"wb");=0A+    =0A+    char check[4] =3D {0};=0A=
+    i =3D 0;=0A+=0A+    char msg[1000] =3D {0}; =0A+    int j =3D 0;=0A+=
=0A+    while(check[i] !=3D '\r' || check[(i + 1) % 4] !=3D '\n' || check[(=
i + 2) % 4] !=3D '\r' || check[(i + 3) % 4] !=3D '\n'){=0A+        check[i]=
 =3D fgetc(sock_fp);=0A+        msg[j++] =3D check[i];   =0A+        i =3D =
(i + 1) % 4;=0A+    }=0A+    =0A+    msg[j] =3D '\n';=0A+=0A+    printf("%s=
", msg);=0A+=0A+    int len;=0A+    char buf[500];=0A+=0A+    while((len =
=3D fread(buf, 1, sizeof(buf), sock_fp))>0){=0A+        fwrite(buf, 1, len,=
 file);=0A+    } =0A    =0A     fclose(sock_fp);=0A     fclose(file);=0A-- =
=0A2.34.1=0A=0A=0AFrom 9c62b3d8d311c64168ef51c7cc5a217d39a073a7 Mon Sep 17 =
00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Mon, 7 Nov =
2022 23:04:51 -0500=0ASubject: [PATCH 5/8] Made small changes on http-clien=
t.c!=0A=0A---=0A part1/http-client.c | 24 +++++++++++++-----------=0A 1 fil=
e changed, 13 insertions(+), 11 deletions(-)=0A=0Adiff --git a/part1/http-c=
lient.c b/part1/http-client.c=0Aindex a60265c..a4f8350 100644=0A--- a/part1=
/http-client.c=0A+++ b/part1/http-client.c=0A@@ -85,12 +85,13 @@ int main(i=
nt argc, char **argv) {=0A     send(serv_fd, "\r\n", 2, 0);=0A     =0A =0A-=
    char a;=0A-    while((a =3D fgetc(sock_fp)) !=3D ' ');=0A+   =0A+    wh=
ile(fgetc(sock_fp) !=3D ' ');=0A =0A     int i =3D 0;=0A-    char buf2[50] =
=3D {0};=0A-=0A+    char buf2[1000] =3D {0};=0A+    =0A+    char a;    =0A =
    if((a =3D fgetc(sock_fp)) !=3D '2'){=0A        buf2[i++] =3D (char) a;=
=0A        buf2[i++] =3D fgetc(sock_fp);=0A@@ -111,24 +112,25 @@ int main(i=
nt argc, char **argv) {=0A  =0A     FILE *file =3D fopen(++name,"wb");=0A  =
   =0A+=0A+=0A     char check[4] =3D {0};=0A     i =3D 0;=0A-=0A-    char m=
sg[1000] =3D {0}; =0A-    int j =3D 0;=0A+    //char msg[1000] =3D {0}; =0A=
+    //int j =3D 0;=0A =0A     while(check[i] !=3D '\r' || check[(i + 1) % =
4] !=3D '\n' || check[(i + 2) % 4] !=3D '\r' || check[(i + 3) % 4] !=3D '\n=
'){=0A         check[i] =3D fgetc(sock_fp);=0A-        msg[j++] =3D check[i=
];   =0A+       // msg[j++] =3D check[i];   =0A         i =3D (i + 1) % 4;=
=0A     }=0A     =0A-    msg[j] =3D '\n';=0A+    //msg[j] =3D '\n';=0A =0A-=
    printf("%s", msg);=0A+    //printf("%s", msg);=0A =0A     int len;=0A- =
   char buf[500];=0A+    char buf[1000];=0A =0A     while((len =3D fread(bu=
f, 1, sizeof(buf), sock_fp))>0){=0A         fwrite(buf, 1, len, file);=0A--=
 =0A2.34.1=0A=0A=0AFrom fcf69c82e00dd20a4943c4beb7c3caea2783dcd6 Mon Sep 17=
 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 11 No=
v 2022 01:17:01 -0500=0ASubject: [PATCH 6/8] make a change to http-client.c=
 to make it print error=0A messages correctly.=0A=0A---=0A part1/http-clien=
t.c | 70 +++++++++++++++++++++++++++++----------------=0A 1 file changed, 4=
6 insertions(+), 24 deletions(-)=0A=0Adiff --git a/part1/http-client.c b/pa=
rt1/http-client.c=0Aindex a4f8350..0af4f22 100644=0A--- a/part1/http-client=
=2Ec=0A+++ b/part1/http-client.c=0A@@ -85,43 +85,49 @@ int main(int argc, c=
har **argv) {=0A     send(serv_fd, "\r\n", 2, 0);=0A     =0A =0A-   =0A-   =
 while(fgetc(sock_fp) !=3D ' ');=0A-=0A+    char buf[1000] =3D {0};=0A     =
int i =3D 0;=0A-    char buf2[1000] =3D {0};=0A-    =0A-    char a;    =0A-=
    if((a =3D fgetc(sock_fp)) !=3D '2'){=0A-       buf2[i++] =3D (char) a;=
=0A-       buf2[i++] =3D fgetc(sock_fp);=0A-       while(buf2[i-2] !=3D '\r=
' || buf2[i-1] !=3D '\n'){=0A-           buf2[i++] =3D fgetc(sock_fp);=0A+=
=0A+    while((buf[i++]=3Dfgetc(sock_fp)) !=3D ' '); //to move the stream p=
ointer to the first char of the status code of the HTTP response header=0A+=
=0A+    char a;=0A+=0A+    if((a =3D fgetc(sock_fp)) !=3D '2'){ // if there=
 is an error=0A+       buf[i++] =3D (char) a;=0A+ =0A+       while(buf[i-2]=
 !=3D '\r' || buf[i-1] !=3D '\n'){=0A+           buf[i++] =3D fgetc(sock_fp=
);=0A        }=0A-       buf2[i-2] =3D '\n';=0A-       buf2[i-1] =3D 0;=0A+=
       buf[i-2] =3D '\n';=0A+       buf[i-1] =3D 0;=0A =0A-       printf("%=
s",buf2);=0A-       exit(1);=0A+       printf("%s\n",buf);=0A+       //fflu=
sh(stdout);=0A+=0A+       fclose(sock_fp);=0A+       exit(1); //ask about t=
his to John 1 or 0=0A     }=0A =0A     char *name =3D strrchr(URI,'/');=0A-=
 =0A+    =0A+=0A     if(name =3D=3D NULL)=0A         die("wrong URI");=0A  =
=0A-    FILE *file =3D fopen(++name,"wb");=0A+   =0A+    FILE *file =3D fop=
en(++name, "wb"); //increment the address pointer to skip /=0A     =0A =0A =
=0A-    char check[4] =3D {0};=0A+    char check[4] =3D {0}; // I will stor=
e the most recent four bytes of the HTTP response until I get /r/n/r/n=0A  =
   i =3D 0;=0A+   =0A     //char msg[1000] =3D {0}; =0A     //int j =3D 0;=
=0A =0A     while(check[i] !=3D '\r' || check[(i + 1) % 4] !=3D '\n' || che=
ck[(i + 2) % 4] !=3D '\r' || check[(i + 3) % 4] !=3D '\n'){=0A         chec=
k[i] =3D fgetc(sock_fp);=0A-       // msg[j++] =3D check[i];   =0A+        =
// msg[j++] =3D check[i];   =0A         i =3D (i + 1) % 4;=0A     }=0A     =
=0A@@ -130,13 +136,29 @@ int main(int argc, char **argv) {=0A     //printf(=
"%s", msg);=0A =0A     int len;=0A-    char buf[1000];=0A-=0A-    while((le=
n =3D fread(buf, 1, sizeof(buf), sock_fp))>0){=0A-        fwrite(buf, 1, le=
n, file);=0A+    int len2;=0A+    char inputBuf[1000] =3D {0};=0A+=0A+    w=
hile((len =3D fread(inputBuf, 1, sizeof(inputBuf), sock_fp))>0){=0A+       =
  if(ferror(sock_fp)){=0A+             fclose(sock_fp);=0A+             fcl=
ose(file);=0A+             die("error in reading from a socket file");=0A+ =
        }   =0A+=0A+        if((len2 =3D fwrite(inputBuf, 1, len, file) < l=
en)) {=0A+            fclose(sock_fp);=0A+            fclose(file);=0A+    =
        die("error in writing to a file");=0A+        }=0A     } =0A    =0A=
+    if(ferror(sock_fp)){=0A+        fclose(sock_fp);=0A+        fclose(fil=
e);=0A+        die("error in reading from a socket file");=0A+    }=0A+    =
    =0A     fclose(sock_fp);=0A     fclose(file);=0A }=0A-=0A-- =0A2.34.1=
=0A=0A=0AFrom e3a81428c14dc5cd13f95fd25d85dc1fc869963a Mon Sep 17 00:00:00 =
2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 11 Nov 2022 03:=
31:23 -0500=0ASubject: [PATCH 7/8] Added an error-checking if statement for=
 fopen!=0A=0A---=0A part1/http-client.c | 9 +++++----=0A 1 file changed, 5 =
insertions(+), 4 deletions(-)=0A=0Adiff --git a/part1/http-client.c b/part1=
/http-client.c=0Aindex 0af4f22..002c62e 100644=0A--- a/part1/http-client.c=
=0A+++ b/part1/http-client.c=0A@@ -109,15 +109,16 @@ int main(int argc, cha=
r **argv) {=0A     }=0A =0A     char *name =3D strrchr(URI,'/');=0A-    =0A=
 =0A     if(name =3D=3D NULL)=0A         die("wrong URI");=0A- =0A-   =0A- =
   FILE *file =3D fopen(++name, "wb"); //increment the address pointer to s=
kip /=0A     =0A+    name++; // increment the address pointer to skip=0A =
=0A+    FILE *file =3D fopen(name, "wb");     =0A+    if(file =3D=3D NULL)=
=0A+        die("fopen");=0A+    =0A =0A     char check[4] =3D {0}; // I wi=
ll store the most recent four bytes of the HTTP response until I get /r/n/r=
/n=0A     i =3D 0;=0A-- =0A2.34.1=0A=0A=0AFrom 4216f2f30e82f391bc8d3213429a=
e3b1e6013d6a Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.=
edu>=0ADate: Sat, 12 Nov 2022 00:16:10 -0500=0ASubject: [PATCH 8/8] I inclu=
ded valgrind output in readme and is ready for=0A submit.=0A=0A---=0A READM=
E.txt          | 22 ++++++++++++++++++----=0A part1/http-client.c | 16 ++++=
++++++------=0A 2 files changed, 28 insertions(+), 10 deletions(-)=0A=0Adif=
f --git a/README.txt b/README.txt=0Aindex 49c4472..7f40003 100644=0A--- a/R=
EADME.txt=0A+++ b/README.txt=0A@@ -1,11 +1,25 @@=0A This file should contai=
n:=0A =0A-  - your name=0A-  - your UNI=0A-  - lab assignment number=0A-  -=
 description for each part=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab 5 =
=0A+  - My code should work as intended.=0A =0A The description should indi=
cate whether your solution for the part is=0A working or not.  You may also=
 want to include anything else you would=0A like to communicate to the grad=
er such as extra functionalities you=0A implemented or how you tried to fix=
 your non-working code.=0A+=3D=3D600591=3D=3D Memcheck, a memory error dete=
ctor=0A+=3D=3D600591=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julia=
n Seward et al.=0A+=3D=3D600591=3D=3D Using Valgrind-3.18.1 and LibVEX; rer=
un with -h for copyright info=0A+=3D=3D600591=3D=3D Command: ./http-client =
www.gnu.org 80 /software/make/manual/make.html=0A+=3D=3D600591=3D=3D =0A+=
=3D=3D600591=3D=3D =0A+=3D=3D600591=3D=3D HEAP SUMMARY:=0A+=3D=3D600591=3D=
=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D600591=3D=3D   total h=
eap usage: 36 allocs, 36 frees, 36,095 bytes allocated=0A+=3D=3D600591=3D=
=3D =0A+=3D=3D600591=3D=3D All heap blocks were freed -- no leaks are possi=
ble=0A+=3D=3D600591=3D=3D =0A+=3D=3D600591=3D=3D For lists of detected and =
suppressed errors, rerun with: -s=0A+=3D=3D600591=3D=3D ERROR SUMMARY: 0 er=
rors from 0 contexts (suppressed: 0 from 0)=0Adiff --git a/part1/http-clien=
t.c b/part1/http-client.c=0Aindex 002c62e..066ca37 100644=0A--- a/part1/htt=
p-client.c=0A+++ b/part1/http-client.c=0A@@ -110,15 +110,19 @@ int main(int=
 argc, char **argv) {=0A =0A     char *name =3D strrchr(URI,'/');=0A =0A-  =
  if(name =3D=3D NULL)=0A-        die("wrong URI");=0A-    =0A+    if(name =
=3D=3D NULL){=0A+        printf("wrong URI\n");=0A+        fclose(sock_fp);=
=0A+        exit(1);=0A+    }=0A+=0A     name++; // increment the address p=
ointer to skip=0A =0A     FILE *file =3D fopen(name, "wb");     =0A-    if(=
file =3D=3D NULL)=0A+    if(file =3D=3D NULL){=0A+        fclose(sock_fp);=
=0A         die("fopen");=0A-    =0A+    }=0A =0A     char check[4] =3D {0}=
; // I will store the most recent four bytes of the HTTP response until I g=
et /r/n/r/n=0A     i =3D 0;=0A@@ -153,7 +157,7 @@ int main(int argc, char *=
*argv) {=0A             die("error in writing to a file");=0A         }=0A =
    } =0A-   =0A+=0A     if(ferror(sock_fp)){=0A         fclose(sock_fp);=
=0A         fclose(file);=0A-- =0A2.34.1=0A=0A
--PnLJWAQtfrbtxhV2--

From do.not.reply@cloud.cs.columbia.edu Wed Nov 30 18:28:59 2022
Date: Wed, 30 Nov 2022 18:28:59 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab6.mbox
Message-ID: <Y4fnOmBMPbL3ICvn@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="XQjv2NlBR1EoUd//"
Content-Disposition: inline
Status: RO
Content-Length: 124307
Lines: 2642


--XQjv2NlBR1EoUd//
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 17:01:52 -0500
Subject: [PATCH 1/9] I created a Makefile and http-server.c with skeletal
 code.

---
 part1/Makefile      |  16 +++++
 part1/http-server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 165 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/http-server.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..564dbfd
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o http-server
+
+.PHONY: all
+all: clean http-server
diff --git a/part1/http-server.c b/part1/http-server.c
new file mode 100644
index 0000000..dae362f
--- /dev/null
+++ b/part1/http-server.c
@@ -0,0 +1,149 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+int main(int argc, char **argv)
+{
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    //char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        /*
+         * Handle client connection.
+         */
+
+        // Keep track of how many bytes we've received.
+        size_t recv_len = 0;
+
+        int len;
+        char buf[32];
+
+        // recv() is like read(), except there's an extra flags argument.
+        //
+        // Since we didn't pass any flags to recv(), this is equivalent to
+        // read(clnt_fd, buf, sizeof(buf)).
+        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+            die("recv");
+
+        while (len > 0) {
+            // Book-keeping.
+            recv_len += len;
+
+            // send() is like write(), except there's an extra flags argument.
+            //
+            // Since we didn't pass any flags to send(), this is equivalent to
+            // write(clnt_fd, buf, len).
+            if (send(clnt_fd, buf, len, 0) != len)
+                die("send");
+
+            // recv() might not have read everything the client sent, so we need
+            // to continue recv()ing.
+            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+                die("recv");
+        }
+
+        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
+
+        // Close client connection.
+        close(clnt_fd);
+
+        // Resume server loop to handle next client connection.
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
-- 
2.34.1


From e0bfbf633d48c7dab909c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 21:41:13 -0500
Subject: [PATCH 2/9] Can parse the HTTP request now.

---
 part1/http-server.c | 72 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 70 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index dae362f..980293d 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#define BUF_SIZE 4096
 static void die(const char *msg)
 {
     perror(msg);
@@ -95,9 +96,73 @@ int main(int argc, char **argv)
         fprintf(stderr, "Accepted connection from %s\n",
                 inet_ntoa(clnt_addr.sin_addr));
 
+        FILE *clnt_r = fdopen(clnt_fd, "rb");
+        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+        
         /*
-         * Handle client connection.
+         * Receive the HTTP response.
          */
+        
+        char buf[BUF_SIZE];
+
+        // Read the first line
+        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+            fclose(clnt_w);
+            continue;
+        }
+
+        // If the initial request line is not complete
+        if(buf[strlen(buf)-1] != '\n'){
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+
+
+        char *token_separators = "\t \r\n"; // tab, space, new line
+        char *method = strtok(buf, token_separators);
+        char *requestURI = strtok(NULL, token_separators);
+        char *httpVersion = strtok(NULL, token_separators);
+        
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+            fprintf(clnt_w,
+                "HTTP/1.0 501 Not Implemented\n\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+        
+        // If URI doesn't start with '/' or there exists '..' in the URI
+        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+            fprintf(clnt_w,
+                "HTTP/1.0 400 Bad Request\n\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        } 
+
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+             ,method, requestURI, httpVersion);
+
+        /*        
+         * Handle client connection.
+        
 
         // Keep track of how many bytes we've received.
         size_t recv_len = 0;
@@ -131,8 +196,11 @@ int main(int argc, char **argv)
 
         fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
 
+        */
+
         // Close client connection.
-        close(clnt_fd);
+        fclose(clnt_r);
+        fclose(clnt_w);
 
         // Resume server loop to handle next client connection.
     }
-- 
2.34.1


From 5012829bc3c592d667c295a7da1bf207dc7745d1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 22:32:29 -0500
Subject: [PATCH 3/9] Now I can send a file back, but it just sends the same
 file now.

---
 part1/http-server.c | 37 +++++++++++++++++++++++++++++++++++--
 1 file changed, 35 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 980293d..f4afac9 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -135,7 +135,7 @@ int main(int argc, char **argv)
   
 
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
                 "HTTP/1.0 501 Not Implemented\n\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>\n");
@@ -152,7 +152,7 @@ int main(int argc, char **argv)
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
-        } 
+        }
 
         fprintf(stderr,
             "This is method: %s\n"
@@ -160,6 +160,39 @@ int main(int argc, char **argv)
             "This is httpVersion: %s\n"
              ,method, requestURI, httpVersion);
 
+        /*
+        * Read from the file, and write out to file_name.
+        */
+
+        // Open up file_name for reading.
+        FILE *file = fopen("file.txt", "rb");
+        if(file == NULL)
+            die("fopen");
+
+        char buf2[BUF_SIZE];
+        // Switch to fread()/fwrite() so that we can download binary files.
+        size_t n;
+        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+            if (fwrite(buf2, 1, n, clnt_w) != n) {
+                fprintf(stderr, "Encountered error writing to client\n");
+                exit(1);
+            }
+        }
+
+        /*
+        * All done, clean up.
+        */
+
+        // fread() returns 0 on EOF or on error, so we need to check for errors.
+        if (ferror(file)) {
+            fprintf(stderr, "Encountered error reading from file.\n");
+            exit(1);
+        }
+
+        // Close FILE * for output file.
+        if (fclose(file))
+            die("close");
+
         /*        
          * Handle client connection.
         
-- 
2.34.1


From 10a38d9d1573ffab2631791ec2e2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 01:07:19 -0500
Subject: [PATCH 4/9] Now my program can send the file if it exists and send
 404 Not Found when it doesn't.

---
 part1/http-server.c | 42 +++++++++++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 15 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index f4afac9..eb9a728 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -32,7 +32,7 @@ int main(int argc, char **argv)
         usage_and_exit(argv[0]);
 
     char *server_port = argv[1];
-    //char *web_root = argv[2];
+    char *web_root = argv[2];
 
 
     /*
@@ -137,8 +137,8 @@ int main(int argc, char **argv)
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
         if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\n\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
@@ -147,30 +147,40 @@ int main(int argc, char **argv)
         // If URI doesn't start with '/' or there exists '..' in the URI
         if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
             fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\n\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
         }
 
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-             ,method, requestURI, httpVersion);
-
         /*
         * Read from the file, and write out to file_name.
         */
-
+        
+        char filename[1000] = {0};
+        
+        strcpy(filename, web_root);
+        strcat(filename, requestURI);
+        
+        printf("%s\n", filename);        
         // Open up file_name for reading.
-        FILE *file = fopen("file.txt", "rb");
-        if(file == NULL)
-            die("fopen");
+        FILE *file = fopen(filename, "rb");
+        if(file == NULL){
+            printf("File is not found\n");
+            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                    "<html><body><h1>404 Not Found</h1></body></html>");
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
 
         char buf2[BUF_SIZE];
+       
         // Switch to fread()/fwrite() so that we can download binary files.
+
+        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+
         size_t n;
         while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
             if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -189,6 +199,8 @@ int main(int argc, char **argv)
             exit(1);
         }
 
+    
+
         // Close FILE * for output file.
         if (fclose(file))
             die("close");
-- 
2.34.1


From 9b98287beb7a42cd036eb343094128d736ca56df Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 02:34:29 -0500
Subject: [PATCH 5/9] Now I can send 301 Moved Permanently responses!

---
 part1/http-server.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index eb9a728..1c12a49 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -6,6 +6,7 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <unistd.h>
 
 #define BUF_SIZE 4096
@@ -153,7 +154,11 @@ int main(int argc, char **argv)
             fclose(clnt_w);
             continue;
         }
-
+        
+        // If URI ends with '/', append "index.html" to the URI 
+        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
+            strcat(requestURI, "index.html");
+        }
         /*
         * Read from the file, and write out to file_name.
         */
@@ -162,12 +167,27 @@ int main(int argc, char **argv)
         
         strcpy(filename, web_root);
         strcat(filename, requestURI);
-        
-        printf("%s\n", filename);        
+
+        printf("Filename is: %s\n", filename);
+
+        struct stat st;
+        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
+            printf("Path is a directory!\n");
+            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                    "Location: %s/\r\n\r\n"
+                    "<html><body>\r\n"
+                    "<h1>301 Moved Permanently</h1>\r\n"
+                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                    "</body></html>", requestURI, requestURI);
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
+
         // Open up file_name for reading.
         FILE *file = fopen(filename, "rb");
         if(file == NULL){
-            printf("File is not found\n");
+            printf("File is not found!\n");
             fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                     "<html><body><h1>404 Not Found</h1></body></html>");
             fclose(clnt_w);
-- 
2.34.1


From 857918bf62df7d94d34eae5f4ecb64a8f9650c27 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Tue, 29 Nov 2022 05:18:47 -0500
Subject: [PATCH 6/9] Made a lot of changes, seperated the for loop and client
 handling, also attempted to make sure there is no memory leak, but I have to
 spend more time on that.

---
 part1/http-server.c | 349 ++++++++++++++++++++++----------------------
 1 file changed, 175 insertions(+), 174 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 1c12a49..cf244f2 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <signal.h>
 
 #define BUF_SIZE 4096
 static void die(const char *msg)
@@ -23,8 +24,176 @@ static void usage_and_exit(char *argv0)
     exit(1);
 }
 
+static void handle_client(int clnt_fd, char *web_root, char *ip_address){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+    /*
+     * Receive the HTTP response.
+     */
+        
+    char buf[BUF_SIZE];
+
+    // Read the first line
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the initial request line is not complete
+    if(buf[strlen(buf)-1] != '\n'){
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+
+    char *token_separators = "\t \r\n"; // tab, space, new line
+    char *method = strtok(buf, token_separators);
+    char *requestURI = strtok(NULL, token_separators);
+    char *httpVersion = strtok(NULL, token_separators);
+        
+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+
+     
+            
+    fprintf(stderr, "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+        // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
+            
+        fprintf(stderr, "This is after appending: %s\n",requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        strcat(requestURI, "index.html");
+    }
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        printf("Path is a directory!\n");
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>", requestURI, requestURI);
+        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(stderr, "File is not found!\n");
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>");
+        fprintf(stderr, "This is URI: %s\n", requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
+            ip_address, method, requestURI, httpVersion);
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            fprintf(stderr, "Encountered error while writing to client\n");
+            exit(1);
+        }
+    }
+
+    /*
+    * All done, clean up.
+    */
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        fprintf(stderr, "Encountered error reading from file.\n");
+        exit(1);
+    } 
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
 int main(int argc, char **argv)
 {
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
     /*
      * Parse arguments and determine output file name.
      */
@@ -92,182 +261,14 @@ int main(int argc, char **argv)
                              &clnt_addr_len);
         if (clnt_fd < 0)
             die("accept");
-
-        // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",
-                inet_ntoa(clnt_addr.sin_addr));
-
-        FILE *clnt_r = fdopen(clnt_fd, "rb");
-        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
-        
-        /*
-         * Receive the HTTP response.
-         */
-        
-        char buf[BUF_SIZE];
-
-        // Read the first line
-        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
-            fclose(clnt_w);
-            continue;
-        }
-
-        // If the initial request line is not complete
-        if(buf[strlen(buf)-1] != '\n'){
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-
-
-        char *token_separators = "\t \r\n"; // tab, space, new line
-        char *method = strtok(buf, token_separators);
-        char *requestURI = strtok(NULL, token_separators);
-        char *httpVersion = strtok(NULL, token_separators);
-        
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
-  
-
-        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-            fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\r\n\r\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
         
-        // If URI doesn't start with '/' or there exists '..' in the URI
-        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-            fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-        
-        // If URI ends with '/', append "index.html" to the URI 
-        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
-            strcat(requestURI, "index.html");
-        }
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        char filename[1000] = {0};
-        
-        strcpy(filename, web_root);
-        strcat(filename, requestURI);
-
-        printf("Filename is: %s\n", filename);
-
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            printf("Path is a directory!\n");
-            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
-                    "Location: %s/\r\n\r\n"
-                    "<html><body>\r\n"
-                    "<h1>301 Moved Permanently</h1>\r\n"
-                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                    "</body></html>", requestURI, requestURI);
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        // Open up file_name for reading.
-        FILE *file = fopen(filename, "rb");
-        if(file == NULL){
-            printf("File is not found!\n");
-            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                    "<html><body><h1>404 Not Found</h1></body></html>");
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        char buf2[BUF_SIZE];
-       
-        // Switch to fread()/fwrite() so that we can download binary files.
-
-        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-
-        size_t n;
-        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
-            if (fwrite(buf2, 1, n, clnt_w) != n) {
-                fprintf(stderr, "Encountered error writing to client\n");
-                exit(1);
-            }
-        }
-
-        /*
-        * All done, clean up.
-        */
-
-        // fread() returns 0 on EOF or on error, so we need to check for errors.
-        if (ferror(file)) {
-            fprintf(stderr, "Encountered error reading from file.\n");
-            exit(1);
-        }
-
-    
-
-        // Close FILE * for output file.
-        if (fclose(file))
-            die("close");
-
-        /*        
-         * Handle client connection.
-        
-
-        // Keep track of how many bytes we've received.
-        size_t recv_len = 0;
-
-        int len;
-        char buf[32];
-
-        // recv() is like read(), except there's an extra flags argument.
-        //
-        // Since we didn't pass any flags to recv(), this is equivalent to
-        // read(clnt_fd, buf, sizeof(buf)).
-        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-            die("recv");
-
-        while (len > 0) {
-            // Book-keeping.
-            recv_len += len;
-
-            // send() is like write(), except there's an extra flags argument.
-            //
-            // Since we didn't pass any flags to send(), this is equivalent to
-            // write(clnt_fd, buf, len).
-            if (send(clnt_fd, buf, len, 0) != len)
-                die("send");
-
-            // recv() might not have read everything the client sent, so we need
-            // to continue recv()ing.
-            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-                die("recv");
-        }
-
-        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
-
-        */
-
-        // Close client connection.
-        fclose(clnt_r);
-        fclose(clnt_w);
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
-        // Resume server loop to handle next client connection.
+        handle_client(clnt_fd, web_root, ip_address);
+          
     }
 
     /*
-- 
2.34.1


From 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 05:53:07 -0500
Subject: [PATCH 7/9] I noticed a mistake. I had assumed that we won't be given
 header lines, but that's not correct. So, I generalized it. Now it can handle
 multiple header lines.

---
 part1/http-server.c | 118 ++++++++++++++++++++++++++++----------------
 1 file changed, 75 insertions(+), 43 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index cf244f2..f1194ac 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -11,6 +11,7 @@
 #include <signal.h>
 
 #define BUF_SIZE 4096
+
 static void die(const char *msg)
 {
     perror(msg);
@@ -29,51 +30,88 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     FILE *clnt_r = fdopen(clnt_fd, "rb");
     FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
      
-    /*
+     /*
      * Receive the HTTP response.
      */
-        
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
     char buf[BUF_SIZE];
 
     // Read the first line
-    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
         fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
         fclose(clnt_w);
         return;
     }
 
-    // If the initial request line is not complete
-    if(buf[strlen(buf)-1] != '\n'){
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+
+
+  // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
 
+    char buf3[BUF_SIZE];
 
-    char *token_separators = "\t \r\n"; // tab, space, new line
-    char *method = strtok(buf, token_separators);
-    char *requestURI = strtok(NULL, token_separators);
-    char *httpVersion = strtok(NULL, token_separators);
-        
-        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "400 Bad Request\n");
 
-     
-            
-    fprintf(stderr, "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
   
 
     // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
     if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
         fprintf(clnt_w,
             "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
-                ip_address, method, requestURI, httpVersion);
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "501 Not Implemented\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
@@ -82,21 +120,18 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // If URI doesn't start with '/' or there exists '..' in the URI
     if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
         // If URI ends with /, append index.html
-    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
-            
-        fprintf(stderr, "This is after appending: %s\n",requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
-    }
+  
         
         /*
         * Read from the file, and write out to file_name.
@@ -106,38 +141,34 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         
     strcat(web_root, requestURI);
 
-    fprintf(stderr, "Filename is: %s\n", web_root);
+    // fprintf(stderr, "Filename is: %s\n", web_root);
 
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
-        printf("Path is a directory!\n");
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
                 "Location: %s/\r\n\r\n"
                 "<html><body>\r\n"
                 "<h1>301 Moved Permanently</h1>\r\n"
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                "</body></html>", requestURI, requestURI);
-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
-                ip_address, method, requestURI, httpVersion);
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return; 
     }
 
     // Open up file_name for reading.
     FILE *file = fopen(web_root, "rb");
     if(file == NULL){
-        fprintf(stderr, "File is not found!\n");
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                "<html><body><h1>404 Not Found</h1></body></html>");
-        fprintf(stderr, "This is URI: %s\n", requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
-        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return;
     }
 
@@ -149,8 +180,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // Use fread()/fwrite() so that we can upload binary files.
 
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
-            ip_address, method, requestURI, httpVersion);
+    fprintf(stderr, "200 OK\n");
     size_t n;
     while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -163,6 +193,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     * All done, clean up.
     */
 
+    buf[0] = 0;
+
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
         fprintf(stderr, "Encountered error reading from file.\n");
-- 
2.34.1


From 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:26:54 -0500
Subject: [PATCH 8/9] Wrote part2, but will probably need some changes.

---
 part1/http-server.c       |  96 ++++++-----
 part2/Makefile            |  16 ++
 part2/multi-http-server.c | 354 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 423 insertions(+), 43 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/multi-http-server.c

diff --git a/part1/http-server.c b/part1/http-server.c
index f1194ac..3e500eb 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -41,7 +41,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
    
     char buf[BUF_SIZE];
 
-    // Read the first line
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -64,15 +65,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     httpVersion = strtok(NULL, token_separators);
     char * extra = strtok(NULL, token_separators);
 
-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
-
 
-  // If the initial request line is not complete or there is an extra word at the end
+    // If the initial request line is not complete or there is an extra word at the end
     if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
 
         fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
@@ -81,13 +81,39 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         return;
     }
 
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
     char buf3[BUF_SIZE];
 
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        	fprintf(stderr, "400 Bad Request\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
 
         	fprintf(stderr, "There was an issue with header lines\n");
         	buf[0] = 0;
@@ -104,31 +130,10 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     //From this point on, we can assume that HTTP request has correct structure
   
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
 
-    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-        fprintf(clnt_w,
-            "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
-        fprintf(stderr, "501 Not Implemented\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-        // If URI ends with /, append index.html
+    // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
   
@@ -155,7 +160,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return; 
     }
 
@@ -168,7 +172,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return;
     }
 
@@ -179,28 +182,35 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
        
     // Use fread()/fwrite() so that we can upload binary files.
 
+
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
     fprintf(stderr, "200 OK\n");
     size_t n;
-    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
-            fprintf(stderr, "Encountered error while writing to client\n");
-            exit(1);
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
         }
     }
 
-    /*
-    * All done, clean up.
-    */
-
-    buf[0] = 0;
 
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
-        fprintf(stderr, "Encountered error reading from file.\n");
-        exit(1);
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
     } 
 
+
+    /*
+    * All done, clean up.
+    */
+
     // Close FILE * for output file.
     if (fclose(file))
         die("close");       
@@ -297,7 +307,7 @@ int main(int argc, char **argv)
         char *ip_address = inet_ntoa(clnt_addr.sin_addr);
             
         // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",ip_address);
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
         handle_client(clnt_fd, web_root, ip_address);
           
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..9be1e81
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: multi-http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o multi-http-server
+
+.PHONY: all
+all: clean multi-http-server
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
new file mode 100644
index 0000000..929e9f7
--- /dev/null
+++ b/part2/multi-http-server.c
@@ -0,0 +1,354 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/wait.h>
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+void reap_children(int sig){
+    while (waitpid(-1, NULL, WNOHANG) > 0)
+        ;
+}
+
+static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+     /*
+     * Receive the HTTP response.
+     */
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
+    char buf[BUF_SIZE];
+
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+
+    // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    char buf3[BUF_SIZE];
+
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
+
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
+  
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
+
+    // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
+        strcat(requestURI, "index.html");
+  
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    // fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "200 OK\n");
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
+        }
+    }
+
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
+    } 
+
+
+    /*
+    * All done, clean up.
+    */
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
+int main(int argc, char **argv)
+{
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+        
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
+
+        pid_t pid = fork();
+
+        // Both the parent and child will resume execution here.
+        if (pid == 0){
+            
+            // Child process
+            close(serv_fd);
+            handle_client(clnt_fd, web_root, ip_address, getpid());
+            exit(0);
+
+        }else{
+            
+            close(clnt_fd);
+            // Parent process
+            struct sigaction sa2;
+            memset(&sa2, 0, sizeof(sa2));         // Zero-initialize sigaction structure
+            sigemptyset(&sa2.sa_mask);           // Don't mask any signals
+            sa.sa_flags = SA_RESTART;             // Restart interrupted system calls
+            sa.sa_handler = &reap_children;      // Reap children upon receiving signal
+
+            if (sigaction(SIGCHLD, &sa, NULL))
+                die("sigaction");
+        }
+         
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
+
-- 
2.34.1


From 5161264295a97a290b1442fd240cde6ea9372bcc Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:28:11 -0500
Subject: [PATCH 9/9] Made a change to README.

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..b6c6f1c 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab6
+  - It should work!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


--XQjv2NlBR1EoUd//
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab6.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 26 Nov 2022 17:01:52=
 -0500=0ASubject: [PATCH 1/9] I created a Makefile and http-server.c with s=
keletal=0A code.=0A=0A---=0A part1/Makefile      |  16 +++++=0A part1/http-=
server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++=0A 2 files chan=
ged, 165 insertions(+)=0A create mode 100644 part1/Makefile=0A create mode =
100644 part1/http-server.c=0A=0Adiff --git a/part1/Makefile b/part1/Makefil=
e=0Anew file mode 100644=0Aindex 0000000..564dbfd=0A--- /dev/null=0A+++ b/p=
art1/Makefile=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wped=
antic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+def=
ault: http-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm=
 -rf a.out *.o http-server=0A+=0A+.PHONY: all=0A+all: clean http-server=0Ad=
iff --git a/part1/http-server.c b/part1/http-server.c=0Anew file mode 10064=
4=0Aindex 0000000..dae362f=0A--- /dev/null=0A+++ b/part1/http-server.c=0A@@=
 -0,0 +1,149 @@=0A+#define _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#includ=
e <netdb.h>=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <strin=
g.h>=0A+#include <sys/socket.h>=0A+#include <sys/types.h>=0A+#include <unis=
td.h>=0A+=0A+static void die(const char *msg)=0A+{=0A+    perror(msg);=0A+ =
   exit(1);=0A+}=0A+=0A+static void usage_and_exit(char *argv0)=0A+{=0A+   =
 fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);=0A+    fpr=
intf(stderr, "   ex) %s 8888 ~/html\n", argv0);=0A+    exit(1);=0A+}=0A+=0A=
+int main(int argc, char **argv)=0A+{=0A+    /*=0A+     * Parse arguments a=
nd determine output file name.=0A+     */=0A+=0A+    if (argc !=3D 3)=0A+  =
      usage_and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv[1];=0A=
+    //char *web_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtain socke=
t address structure from server name and port number.=0A+     */=0A+=0A+   =
 struct addrinfo hints, *info;=0A+    memset(&hints, 0, sizeof(hints));=0A+=
=0A+    hints.ai_family =3D AF_INET;       // Only accept IPv4 addresses=0A=
+    hints.ai_socktype =3D SOCK_STREAM; // Stream socket for TCP connection=
s=0A+    hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints.ai=
_flags =3D AI_PASSIVE;     // Construct socket address for bind()ing=0A+=0A=
+    int aerr;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &hints, =
&info)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strer=
ror(aerr));=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Create a s=
ocket(), bind() it to the server, and wrap in FILE *s.=0A+     */=0A+=0A+  =
  int serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_proto=
col);=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    if (bind=
(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+=
   =0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for connecti=
ons on this socket, maintaining a queue of=0A+    // at most 8 pending conn=
ections.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=
=0A+=0A+     /*=0A+     * Server loop runs forever (writing "for (;;)" is t=
he same as "while(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=0A+  =
       * accept() connection from client.=0A+         */=0A+=0A+        // =
Define space to receive client address info.=0A+        struct sockaddr_in =
clnt_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A=
+        // accept() blocks until a client connects with the server, and re=
turns=0A+        // a NEW socket file descriptor for interacting with the c=
lient.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &clnt=
_addr,=0A+                             &clnt_addr_len);=0A+        if (clnt=
_fd < 0)=0A+            die("accept");=0A+=0A+        // clnt_addr is now p=
opulated with information about the client.=0A+        fprintf(stderr, "Acc=
epted connection from %s\n",=0A+                inet_ntoa(clnt_addr.sin_add=
r));=0A+=0A+        /*=0A+         * Handle client connection.=0A+         =
*/=0A+=0A+        // Keep track of how many bytes we've received.=0A+      =
  size_t recv_len =3D 0;=0A+=0A+        int len;=0A+        char buf[32];=
=0A+=0A+        // recv() is like read(), except there's an extra flags arg=
ument.=0A+        //=0A+        // Since we didn't pass any flags to recv()=
, this is equivalent to=0A+        // read(clnt_fd, buf, sizeof(buf)).=0A+ =
       if ((len =3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A+           =
 die("recv");=0A+=0A+        while (len > 0) {=0A+            // Book-keepi=
ng.=0A+            recv_len +=3D len;=0A+=0A+            // send() is like =
write(), except there's an extra flags argument.=0A+            //=0A+     =
       // Since we didn't pass any flags to send(), this is equivalent to=
=0A+            // write(clnt_fd, buf, len).=0A+            if (send(clnt_f=
d, buf, len, 0) !=3D len)=0A+                die("send");=0A+=0A+          =
  // recv() might not have read everything the client sent, so we need=0A+ =
           // to continue recv()ing.=0A+            if ((len =3D recv(clnt_=
fd, buf, sizeof(buf), 0)) < 0)=0A+                die("recv");=0A+        }=
=0A+=0A+        fprintf(stderr, "Received (and sent) %lu bytes in total\n",=
 recv_len);=0A+=0A+        // Close client connection.=0A+        close(cln=
t_fd);=0A+=0A+        // Resume server loop to handle next client connectio=
n.=0A+    }=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    // Th=
eoretically, if we want our server to handle graceful termination, we=0A+  =
  // should also close() the server socket here too:=0A+    close(serv_fd);=
=0A+=0A+    return 0;=0A+}=0A-- =0A2.34.1=0A=0A=0AFrom e0bfbf633d48c7dab909=
c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@c=
olumbia.edu>=0ADate: Sat, 26 Nov 2022 21:41:13 -0500=0ASubject: [PATCH 2/9]=
 Can parse the HTTP request now.=0A=0A---=0A part1/http-server.c | 72 +++++=
++++++++++++++++++++++++++++++++++++++--=0A 1 file changed, 70 insertions(+=
), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/http-server=
=2Ec=0Aindex dae362f..980293d 100644=0A--- a/part1/http-server.c=0A+++ b/pa=
rt1/http-server.c=0A@@ -8,6 +8,7 @@=0A #include <sys/types.h>=0A #include <=
unistd.h>=0A =0A+#define BUF_SIZE 4096=0A static void die(const char *msg)=
=0A {=0A     perror(msg);=0A@@ -95,9 +96,73 @@ int main(int argc, char **ar=
gv)=0A         fprintf(stderr, "Accepted connection from %s\n",=0A         =
        inet_ntoa(clnt_addr.sin_addr));=0A =0A+        FILE *clnt_r =3D fdo=
pen(clnt_fd, "rb");=0A+        FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=
=0A+        =0A         /*=0A-         * Handle client connection.=0A+     =
    * Receive the HTTP response.=0A          */=0A+        =0A+        char=
 buf[BUF_SIZE];=0A+=0A+        // Read the first line=0A+        if (fgets(=
buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A+            fprintf(stderr, "Cl=
ient connection terminated prematurely.\n");=0A+            fclose(clnt_r);=
 //if(fclose(clnt_r)){die("close");}=0A+            fclose(clnt_w);=0A+    =
        continue;=0A+        }=0A+=0A+        // If the initial request lin=
e is not complete=0A+        if(buf[strlen(buf)-1] !=3D '\n'){=0A+         =
   fprintf(stderr, "Client connection terminated prematurely.\n");=0A+     =
       fclose(clnt_r);=0A+            fclose(clnt_w);=0A+            contin=
ue;=0A+        }=0A+=0A+=0A+        char *token_separators =3D "\t \r\n"; /=
/ tab, space, new line=0A+        char *method =3D strtok(buf, token_separa=
tors);=0A+        char *requestURI =3D strtok(NULL, token_separators);=0A+ =
       char *httpVersion =3D strtok(NULL, token_separators);=0A+        =0A=
+        fprintf(stderr,=0A+            "This is method: %s\n"=0A+         =
   "This is requestURI: %s\n"=0A+            "This is httpVersion: %s\n"=0A=
+            ,method, requestURI, httpVersion);=0A+  =0A+=0A+        // If =
the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A+ =
       if (strcmp("GET", method) !=3D 0 || strcmp("HTTP/1.0", httpVersion) =
!=3D 0 || strcmp("HTTP/1.1", httpVersion) !=3D 0) {=0A+            fprintf(=
clnt_w,=0A+                "HTTP/1.0 501 Not Implemented\n\n"=0A+          =
      "<html><body><h1>501 Not Implemented</h1></body></html>\n");=0A+     =
       fclose(clnt_r);=0A+            fclose(clnt_w);=0A+            contin=
ue;=0A+        }=0A+        =0A+        // If URI doesn't start with '/' or=
 there exists '..' in the URI=0A+        if (strncmp("/", requestURI, 1) !=
=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A+            fprintf(clnt=
_w,=0A+                "HTTP/1.0 400 Bad Request\n\n"=0A+                "<=
html><body><h1>400 Bad Request</h1></body></html>\n");=0A+            fclos=
e(clnt_r);=0A+            fclose(clnt_w);=0A+            continue;=0A+     =
   } =0A+=0A+        fprintf(stderr,=0A+            "This is method: %s\n"=
=0A+            "This is requestURI: %s\n"=0A+            "This is httpVers=
ion: %s\n"=0A+             ,method, requestURI, httpVersion);=0A+=0A+      =
  /*        =0A+         * Handle client connection.=0A+        =0A =0A    =
     // Keep track of how many bytes we've received.=0A         size_t recv=
_len =3D 0;=0A@@ -131,8 +196,11 @@ int main(int argc, char **argv)=0A =0A  =
       fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len=
);=0A =0A+        */=0A+=0A         // Close client connection.=0A-        =
close(clnt_fd);=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A =
=0A         // Resume server loop to handle next client connection.=0A     =
}=0A-- =0A2.34.1=0A=0A=0AFrom 5012829bc3c592d667c295a7da1bf207dc7745d1 Mon =
Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat,=
 26 Nov 2022 22:32:29 -0500=0ASubject: [PATCH 3/9] Now I can send a file ba=
ck, but it just sends the same=0A file now.=0A=0A---=0A part1/http-server.c=
 | 37 +++++++++++++++++++++++++++++++++++--=0A 1 file changed, 35 insertion=
s(+), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/http-ser=
ver.c=0Aindex 980293d..f4afac9 100644=0A--- a/part1/http-server.c=0A+++ b/p=
art1/http-server.c=0A@@ -135,7 +135,7 @@ int main(int argc, char **argv)=0A=
   =0A =0A         // If the request is not GET or the HTTP version is not =
HTTP/1.0 or HTTP/1.1=0A-        if (strcmp("GET", method) !=3D 0 || strcmp(=
"HTTP/1.0", httpVersion) !=3D 0 || strcmp("HTTP/1.1", httpVersion) !=3D 0) =
{=0A+        if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpV=
ersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A        =
     fprintf(clnt_w,=0A                 "HTTP/1.0 501 Not Implemented\n\n"=
=0A                 "<html><body><h1>501 Not Implemented</h1></body></html>=
\n");=0A@@ -152,7 +152,7 @@ int main(int argc, char **argv)=0A             =
fclose(clnt_r);=0A             fclose(clnt_w);=0A             continue;=0A-=
        } =0A+        }=0A =0A         fprintf(stderr,=0A             "This=
 is method: %s\n"=0A@@ -160,6 +160,39 @@ int main(int argc, char **argv)=0A=
             "This is httpVersion: %s\n"=0A              ,method, requestUR=
I, httpVersion);=0A =0A+        /*=0A+        * Read from the file, and wri=
te out to file_name.=0A+        */=0A+=0A+        // Open up file_name for =
reading.=0A+        FILE *file =3D fopen("file.txt", "rb");=0A+        if(f=
ile =3D=3D NULL)=0A+            die("fopen");=0A+=0A+        char buf2[BUF_=
SIZE];=0A+        // Switch to fread()/fwrite() so that we can download bin=
ary files.=0A+        size_t n;=0A+        while ((n =3D fread(buf2, 1, siz=
eof(buf2), file)) > 0) {=0A+            if (fwrite(buf2, 1, n, clnt_w) !=3D=
 n) {=0A+                fprintf(stderr, "Encountered error writing to clie=
nt\n");=0A+                exit(1);=0A+            }=0A+        }=0A+=0A+  =
      /*=0A+        * All done, clean up.=0A+        */=0A+=0A+        // f=
read() returns 0 on EOF or on error, so we need to check for errors.=0A+   =
     if (ferror(file)) {=0A+            fprintf(stderr, "Encountered error =
reading from file.\n");=0A+            exit(1);=0A+        }=0A+=0A+       =
 // Close FILE * for output file.=0A+        if (fclose(file))=0A+         =
   die("close");=0A+=0A         /*        =0A          * Handle client conn=
ection.=0A         =0A-- =0A2.34.1=0A=0A=0AFrom 10a38d9d1573ffab2631791ec2e=
2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia=
=2Eedu>=0ADate: Mon, 28 Nov 2022 01:07:19 -0500=0ASubject: [PATCH 4/9] Now =
my program can send the file if it exists and send=0A 404 Not Found when it=
 doesn't.=0A=0A---=0A part1/http-server.c | 42 +++++++++++++++++++++++++++-=
--------------=0A 1 file changed, 27 insertions(+), 15 deletions(-)=0A=0Adi=
ff --git a/part1/http-server.c b/part1/http-server.c=0Aindex f4afac9..eb9a7=
28 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=0A@@ -32,=
7 +32,7 @@ int main(int argc, char **argv)=0A         usage_and_exit(argv[0=
]);=0A =0A     char *server_port =3D argv[1];=0A-    //char *web_root =3D a=
rgv[2];=0A+    char *web_root =3D argv[2];=0A =0A =0A     /*=0A@@ -137,8 +1=
37,8 @@ int main(int argc, char **argv)=0A         // If the request is not=
 GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A         if (strcmp(=
"GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || strc=
mp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A             fprintf(clnt_w,=0A-=
                "HTTP/1.0 501 Not Implemented\n\n"=0A-                "<htm=
l><body><h1>501 Not Implemented</h1></body></html>\n");=0A+                =
"HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+                "<html><body><h1>=
501 Not Implemented</h1></body></html>");=0A             fclose(clnt_r);=0A=
             fclose(clnt_w);=0A             continue;=0A@@ -147,30 +147,40 =
@@ int main(int argc, char **argv)=0A         // If URI doesn't start with =
'/' or there exists '..' in the URI=0A         if (strncmp("/", requestURI,=
 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A             fprintf=
(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\n\n"=0A-             =
   "<html><body><h1>400 Bad Request</h1></body></html>\n");=0A+            =
    "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><body><h1>=
400 Bad Request</h1></body></html>");=0A             fclose(clnt_r);=0A    =
         fclose(clnt_w);=0A             continue;=0A         }=0A =0A-     =
   fprintf(stderr,=0A-            "This is method: %s\n"=0A-            "Th=
is is requestURI: %s\n"=0A-            "This is httpVersion: %s\n"=0A-     =
        ,method, requestURI, httpVersion);=0A-=0A         /*=0A         * R=
ead from the file, and write out to file_name.=0A         */=0A-=0A+       =
 =0A+        char filename[1000] =3D {0};=0A+        =0A+        strcpy(fil=
ename, web_root);=0A+        strcat(filename, requestURI);=0A+        =0A+ =
       printf("%s\n", filename);        =0A         // Open up file_name fo=
r reading.=0A-        FILE *file =3D fopen("file.txt", "rb");=0A-        if=
(file =3D=3D NULL)=0A-            die("fopen");=0A+        FILE *file =3D f=
open(filename, "rb");=0A+        if(file =3D=3D NULL){=0A+            print=
f("File is not found\n");=0A+            fprintf(clnt_w, "HTTP/1.0 404 Not =
Found\r\n\r\n"=0A+                    "<html><body><h1>404 Not Found</h1></=
body></html>");=0A+            fclose(clnt_w);=0A+            fclose(clnt_r=
);=0A+            continue;=0A+        }=0A =0A         char buf2[BUF_SIZE]=
;=0A+       =0A         // Switch to fread()/fwrite() so that we can downlo=
ad binary files.=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=
=0A+=0A         size_t n;=0A         while ((n =3D fread(buf2, 1, sizeof(bu=
f2), file)) > 0) {=0A             if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=
=0A@@ -189,6 +199,8 @@ int main(int argc, char **argv)=0A             exit(=
1);=0A         }=0A =0A+    =0A+=0A         // Close FILE * for output file=
=2E=0A         if (fclose(file))=0A             die("close");=0A-- =0A2.34.=
1=0A=0A=0AFrom 9b98287beb7a42cd036eb343094128d736ca56df Mon Sep 17 00:00:00=
 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Mon, 28 Nov 2022 02=
:34:29 -0500=0ASubject: [PATCH 5/9] Now I can send 301 Moved Permanently re=
sponses!=0A=0A---=0A part1/http-server.c | 28 ++++++++++++++++++++++++----=
=0A 1 file changed, 24 insertions(+), 4 deletions(-)=0A=0Adiff --git a/part=
1/http-server.c b/part1/http-server.c=0Aindex eb9a728..1c12a49 100644=0A---=
 a/part1/http-server.c=0A+++ b/part1/http-server.c=0A@@ -6,6 +6,7 @@=0A #in=
clude <string.h>=0A #include <sys/socket.h>=0A #include <sys/types.h>=0A+#i=
nclude <sys/stat.h>=0A #include <unistd.h>=0A =0A #define BUF_SIZE 4096=0A@=
@ -153,7 +154,11 @@ int main(int argc, char **argv)=0A             fclose(c=
lnt_w);=0A             continue;=0A         }=0A-=0A+        =0A+        //=
 If URI ends with '/', append "index.html" to the URI =0A+        if (strle=
n(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  =3D=3D '/'){=
=0A+            strcat(requestURI, "index.html");=0A+        }=0A         /=
*=0A         * Read from the file, and write out to file_name.=0A         *=
/=0A@@ -162,12 +167,27 @@ int main(int argc, char **argv)=0A         =0A   =
      strcpy(filename, web_root);=0A         strcat(filename, requestURI);=
=0A-        =0A-        printf("%s\n", filename);        =0A+=0A+        pr=
intf("Filename is: %s\n", filename);=0A+=0A+        struct stat st;=0A+    =
    if (stat(filename, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+         =
   printf("Path is a directory!\n");=0A+            fprintf(clnt_w, "HTTP/1=
=2E0 301 Moved Permanently\r\n"=0A+                    "Location: %s/\r\n\r=
\n"=0A+                    "<html><body>\r\n"=0A+                    "<h1>3=
01 Moved Permanently</h1>\r\n"=0A+                    "<p>The document has =
moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+                    "</body><=
/html>", requestURI, requestURI);=0A+            fclose(clnt_w);=0A+       =
     fclose(clnt_r);=0A+            continue;=0A+        }=0A+=0A         /=
/ Open up file_name for reading.=0A         FILE *file =3D fopen(filename, =
"rb");=0A         if(file =3D=3D NULL){=0A-            printf("File is not =
found\n");=0A+            printf("File is not found!\n");=0A             fp=
rintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A                     "<htm=
l><body><h1>404 Not Found</h1></body></html>");=0A             fclose(clnt_=
w);=0A-- =0A2.34.1=0A=0A=0AFrom 857918bf62df7d94d34eae5f4ecb64a8f9650c27 Mo=
n Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Tu=
e, 29 Nov 2022 05:18:47 -0500=0ASubject: [PATCH 6/9] Made a lot of changes,=
 seperated the for loop and client=0A handling, also attempted to make sure=
 there is no memory leak, but I have to=0A spend more time on that.=0A=0A--=
-=0A part1/http-server.c | 349 ++++++++++++++++++++++----------------------=
=0A 1 file changed, 175 insertions(+), 174 deletions(-)=0A=0Adiff --git a/p=
art1/http-server.c b/part1/http-server.c=0Aindex 1c12a49..cf244f2 100644=0A=
--- a/part1/http-server.c=0A+++ b/part1/http-server.c=0A@@ -8,6 +8,7 @@=0A =
#include <sys/types.h>=0A #include <sys/stat.h>=0A #include <unistd.h>=0A+#=
include <signal.h>=0A =0A #define BUF_SIZE 4096=0A static void die(const ch=
ar *msg)=0A@@ -23,8 +24,176 @@ static void usage_and_exit(char *argv0)=0A  =
   exit(1);=0A }=0A =0A+static void handle_client(int clnt_fd, char *web_ro=
ot, char *ip_address){=0A+        =0A+    FILE *clnt_r =3D fdopen(clnt_fd, =
"rb");=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A+     =0A+    =
/*=0A+     * Receive the HTTP response.=0A+     */=0A+        =0A+    char =
buf[BUF_SIZE];=0A+=0A+    // Read the first line=0A+    if (fgets(buf, size=
of(buf), clnt_r) =3D=3D NULL) {=0A+        fprintf(stderr, "Client connecti=
on terminated prematurely.\n");=0A+        fclose(clnt_r); //if(fclose(clnt=
_r)){die("close");}=0A+        fclose(clnt_w);=0A+        return;=0A+    }=
=0A+=0A+    // If the initial request line is not complete=0A+    if(buf[st=
rlen(buf)-1] !=3D '\n'){=0A+        fprintf(stderr, "Client connection term=
inated prematurely.\n");=0A+        fclose(clnt_r);=0A+        fclose(clnt_=
w);=0A+        return;=0A+    }=0A+=0A+=0A+    char *token_separators =3D "=
\t \r\n"; // tab, space, new line=0A+    char *method =3D strtok(buf, token=
_separators);=0A+    char *requestURI =3D strtok(NULL, token_separators);=
=0A+    char *httpVersion =3D strtok(NULL, token_separators);=0A+        =
=0A+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_ad=
dr), method, requestURI, httpVersion);=0A+=0A+     =0A+            =0A+    =
fprintf(stderr, "This is method: %s\n"=0A+            "This is requestURI: =
%s\n"=0A+            "This is httpVersion: %s\n"=0A+            ,method, re=
questURI, httpVersion);=0A+  =0A+=0A+    // If the request is not GET or th=
e HTTP version is not HTTP/1.0 or HTTP/1.1=0A+    if (strcmp("GET", method)=
 !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || strcmp("HTTP/1.1",=
 httpVersion) =3D=3D 0)) {=0A+        fprintf(clnt_w,=0A+            "HTTP/=
1.0 501 Not Implemented\r\n\r\n"=0A+            "<html><body><h1>501 Not Im=
plemented</h1></body></html>");=0A+        fprintf(stderr, "%s \"%s %s %s\"=
 501 Not Implemented\n",=0A+                ip_address, method, requestURI,=
 httpVersion);=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+   =
     return;=0A+    }=0A+        =0A+    // If URI doesn't start with '/' o=
r there exists '..' in the URI=0A+    if (strncmp("/", requestURI, 1) !=3D =
0 || strstr(requestURI, "..") !=3D NULL ) {=0A+        fprintf(clnt_w, "HTT=
P/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad =
Request</h1></body></html>");=0A+        fprintf(stderr, "%s \"%s %s %s\" 4=
00 Bad Request\n",=0A+                ip_address, method, requestURI, httpV=
ersion);=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        r=
eturn;=0A+    }=0A+        =0A+        // If URI ends with /, append index.=
html=0A+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI=
) - 1))  =3D=3D '/'){=0A+            =0A+        fprintf(stderr, "This is a=
fter appending: %s\n",requestURI);=0A+        fprintf(stderr, "This is http=
Version: %s\n", httpVersion);=0A+        strcat(requestURI, "index.html");=
=0A+    }=0A+        =0A+        /*=0A+        * Read from the file, and wr=
ite out to file_name.=0A+        */=0A+        =0A+        // char *filenam=
e; [strlen(web_root + strlen(requestURI)) + 1];=0A+        =0A+    strcat(w=
eb_root, requestURI);=0A+=0A+    fprintf(stderr, "Filename is: %s\n", web_r=
oot);=0A+=0A+    struct stat st;=0A+    if (stat(web_root, &st) =3D=3D 0 &&=
 S_ISDIR(st.st_mode)) {=0A+        printf("Path is a directory!\n");=0A+   =
     fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=0A+              =
  "Location: %s/\r\n\r\n"=0A+                "<html><body>\r\n"=0A+        =
        "<h1>301 Moved Permanently</h1>\r\n"=0A+                "<p>The doc=
ument has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+                "</=
body></html>", requestURI, requestURI);=0A+        fprintf(stderr, "%s \"%s=
 %s %s\" 301 Moved Permanently\n",=0A+                ip_address, method, r=
equestURI, httpVersion);=0A+        fclose(clnt_w);=0A+        fclose(clnt_=
r);=0A+        *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0'=
;=0A+        return; =0A+    }=0A+=0A+    // Open up file_name for reading.=
=0A+    FILE *file =3D fopen(web_root, "rb");=0A+    if(file =3D=3D NULL){=
=0A+        fprintf(stderr, "File is not found!\n");=0A+        fprintf(cln=
t_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>4=
04 Not Found</h1></body></html>");=0A+        fprintf(stderr, "This is URI:=
 %s\n", requestURI);=0A+        fprintf(stderr, "This is httpVersion: %s\n"=
, httpVersion);=0A+        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n=
",=0A+                ip_address, method, requestURI, httpVersion);=0A+    =
    fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *(web_root + strl=
en(web_root) - strlen(requestURI)) =3D '\0';=0A+        return;=0A+    }=0A=
+=0A+    // Bring back web_root to its original content=0A+    *(web_root +=
 strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+        =0A+    char =
buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() so that we can up=
load binary files.=0A+=0A+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=
=0A+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",=0A+            ip_addre=
ss, method, requestURI, httpVersion);=0A+    size_t n;=0A+    while ((n =3D=
 fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A+        if (fwrite(buf2, 1, =
n, clnt_w) !=3D n) {=0A+            fprintf(stderr, "Encountered error whil=
e writing to client\n");=0A+            exit(1);=0A+        }=0A+    }=0A+=
=0A+    /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    // fread() ret=
urns 0 on EOF or on error, so we need to check for errors.=0A+    if (ferro=
r(file)) {=0A+        fprintf(stderr, "Encountered error reading from file.=
\n");=0A+        exit(1);=0A+    } =0A+=0A+    // Close FILE * for output f=
ile.=0A+    if (fclose(file))=0A+        die("close");       =0A+=0A+    //=
 Close client connection.=0A+    fclose(clnt_r);=0A+    fclose(clnt_w);=0A+=
=0A+    // Resume server loop to handle next client connection.=0A+    retu=
rn;=0A+}=0A+=0A+=0A+=0A int main(int argc, char **argv)=0A {=0A+=0A+    str=
uct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));         // Zero-initia=
lize sigaction structure=0A+    sigemptyset(&sa.sa_mask);           // Don'=
t mask any signals=0A+    sa.sa_handler =3D SIG_IGN;            // Ignore t=
he signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+        die("sig=
action");=0A+=0A     /*=0A      * Parse arguments and determine output file=
 name.=0A      */=0A@@ -92,182 +261,14 @@ int main(int argc, char **argv)=
=0A                              &clnt_addr_len);=0A         if (clnt_fd < =
0)=0A             die("accept");=0A-=0A-        // clnt_addr is now populat=
ed with information about the client.=0A-        fprintf(stderr, "Accepted =
connection from %s\n",=0A-                inet_ntoa(clnt_addr.sin_addr));=
=0A-=0A-        FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A-        FILE *cl=
nt_w =3D fdopen(dup(clnt_fd), "wb");=0A-        =0A-        /*=0A-         =
* Receive the HTTP response.=0A-         */=0A-        =0A-        char buf=
[BUF_SIZE];=0A-=0A-        // Read the first line=0A-        if (fgets(buf,=
 sizeof(buf), clnt_r) =3D=3D NULL) {=0A-            fprintf(stderr, "Client=
 connection terminated prematurely.\n");=0A-            fclose(clnt_r); //i=
f(fclose(clnt_r)){die("close");}=0A-            fclose(clnt_w);=0A-        =
    continue;=0A-        }=0A-=0A-        // If the initial request line is=
 not complete=0A-        if(buf[strlen(buf)-1] !=3D '\n'){=0A-            f=
printf(stderr, "Client connection terminated prematurely.\n");=0A-         =
   fclose(clnt_r);=0A-            fclose(clnt_w);=0A-            continue;=
=0A-        }=0A-=0A-=0A-        char *token_separators =3D "\t \r\n"; // t=
ab, space, new line=0A-        char *method =3D strtok(buf, token_separator=
s);=0A-        char *requestURI =3D strtok(NULL, token_separators);=0A-    =
    char *httpVersion =3D strtok(NULL, token_separators);=0A-        =0A-  =
      fprintf(stderr,=0A-            "This is method: %s\n"=0A-            =
"This is requestURI: %s\n"=0A-            "This is httpVersion: %s\n"=0A-  =
          ,method, requestURI, httpVersion);=0A-  =0A-=0A-        // If the=
 request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A-    =
    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =
=3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-            fpr=
intf(clnt_w,=0A-                "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A- =
               "<html><body><h1>501 Not Implemented</h1></body></html>");=
=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-         =
   continue;=0A-        }=0A         =0A-        // If URI doesn't start wi=
th '/' or there exists '..' in the URI=0A-        if (strncmp("/", requestU=
RI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A-            fpri=
ntf(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-      =
          "<html><body><h1>400 Bad Request</h1></body></html>");=0A-       =
     fclose(clnt_r);=0A-            fclose(clnt_w);=0A-            continue=
;=0A-        }=0A-        =0A-        // If URI ends with '/', append "inde=
x.html" to the URI =0A-        if (strlen(requestURI) > 0 && *(requestURI +=
 strlen(requestURI) - 1)  =3D=3D '/'){=0A-            strcat(requestURI, "i=
ndex.html");=0A-        }=0A-        /*=0A-        * Read from the file, an=
d write out to file_name.=0A-        */=0A-        =0A-        char filenam=
e[1000] =3D {0};=0A-        =0A-        strcpy(filename, web_root);=0A-    =
    strcat(filename, requestURI);=0A-=0A-        printf("Filename is: %s\n"=
, filename);=0A-=0A-        struct stat st;=0A-        if (stat(filename, &=
st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-            printf("Path is a dir=
ectory!\n");=0A-            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently=
\r\n"=0A-                    "Location: %s/\r\n\r\n"=0A-                   =
 "<html><body>\r\n"=0A-                    "<h1>301 Moved Permanently</h1>\=
r\n"=0A-                    "<p>The document has moved <a href=3D\"%s/\">he=
re</a>.</p>\r\n"=0A-                    "</body></html>", requestURI, reque=
stURI);=0A-            fclose(clnt_w);=0A-            fclose(clnt_r);=0A-  =
          continue;=0A-        }=0A-=0A-        // Open up file_name for re=
ading.=0A-        FILE *file =3D fopen(filename, "rb");=0A-        if(file =
=3D=3D NULL){=0A-            printf("File is not found!\n");=0A-           =
 fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A-                    "<=
html><body><h1>404 Not Found</h1></body></html>");=0A-            fclose(cl=
nt_w);=0A-            fclose(clnt_r);=0A-            continue;=0A-        }=
=0A-=0A-        char buf2[BUF_SIZE];=0A-       =0A-        // Switch to fre=
ad()/fwrite() so that we can download binary files.=0A-=0A-        fprintf(=
clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=0A-=0A-        size_t n;=0A-        whi=
le ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A-            if (fw=
rite(buf2, 1, n, clnt_w) !=3D n) {=0A-                fprintf(stderr, "Enco=
untered error writing to client\n");=0A-                exit(1);=0A-       =
     }=0A-        }=0A-=0A-        /*=0A-        * All done, clean up.=0A- =
       */=0A-=0A-        // fread() returns 0 on EOF or on error, so we nee=
d to check for errors.=0A-        if (ferror(file)) {=0A-            fprint=
f(stderr, "Encountered error reading from file.\n");=0A-            exit(1)=
;=0A-        }=0A-=0A-    =0A-=0A-        // Close FILE * for output file.=
=0A-        if (fclose(file))=0A-            die("close");=0A-=0A-        /=
*        =0A-         * Handle client connection.=0A-        =0A-=0A-      =
  // Keep track of how many bytes we've received.=0A-        size_t recv_le=
n =3D 0;=0A-=0A-        int len;=0A-        char buf[32];=0A-=0A-        //=
 recv() is like read(), except there's an extra flags argument.=0A-        =
//=0A-        // Since we didn't pass any flags to recv(), this is equivale=
nt to=0A-        // read(clnt_fd, buf, sizeof(buf)).=0A-        if ((len =
=3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A-            die("recv");=0A=
-=0A-        while (len > 0) {=0A-            // Book-keeping.=0A-         =
   recv_len +=3D len;=0A-=0A-            // send() is like write(), except =
there's an extra flags argument.=0A-            //=0A-            // Since =
we didn't pass any flags to send(), this is equivalent to=0A-            //=
 write(clnt_fd, buf, len).=0A-            if (send(clnt_fd, buf, len, 0) !=
=3D len)=0A-                die("send");=0A-=0A-            // recv() might=
 not have read everything the client sent, so we need=0A-            // to =
continue recv()ing.=0A-            if ((len =3D recv(clnt_fd, buf, sizeof(b=
uf), 0)) < 0)=0A-                die("recv");=0A-        }=0A-=0A-        f=
printf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);=0A-=
=0A-        */=0A-=0A-        // Close client connection.=0A-        fclose=
(clnt_r);=0A-        fclose(clnt_w);=0A+        char *ip_address =3D inet_n=
toa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr is now pop=
ulated with information about the client.=0A+        fprintf(stderr, "Accep=
ted connection from %s\n",ip_address);=0A =0A-        // Resume server loop=
 to handle next client connection.=0A+        handle_client(clnt_fd, web_ro=
ot, ip_address);=0A+          =0A     }=0A =0A     /*=0A-- =0A2.34.1=0A=0A=
=0AFrom 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00:00 2001=
=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 2022 05:53:0=
7 -0500=0ASubject: [PATCH 7/9] I noticed a mistake. I had assumed that we w=
on't be given=0A header lines, but that's not correct. So, I generalized it=
=2E Now it can handle=0A multiple header lines.=0A=0A---=0A part1/http-serv=
er.c | 118 ++++++++++++++++++++++++++++----------------=0A 1 file changed, =
75 insertions(+), 43 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/p=
art1/http-server.c=0Aindex cf244f2..f1194ac 100644=0A--- a/part1/http-serve=
r.c=0A+++ b/part1/http-server.c=0A@@ -11,6 +11,7 @@=0A #include <signal.h>=
=0A =0A #define BUF_SIZE 4096=0A+=0A static void die(const char *msg)=0A {=
=0A     perror(msg);=0A@@ -29,51 +30,88 @@ static void handle_client(int cl=
nt_fd, char *web_root, char *ip_address){=0A     FILE *clnt_r =3D fdopen(cl=
nt_fd, "rb");=0A     FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A      =
=0A-    /*=0A+     /*=0A      * Receive the HTTP response.=0A      */=0A-  =
      =0A+    =0A+    char *method =3D NULL;=0A+    char *requestURI =3D NU=
LL;=0A+    char *httpVersion =3D NULL;    =0A+    char *token_separators =
=3D "\t \r\n"; // tab, space, new line=0A+   =0A     char buf[BUF_SIZE];=0A=
 =0A     // Read the first line=0A-    if (fgets(buf, sizeof(buf), clnt_r) =
=3D=3D NULL) {=0A-        fprintf(stderr, "Client connection terminated pre=
maturely.\n");=0A+    if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {   =
    =0A+        method =3D strtok(buf, token_separators);=0A+        reques=
tURI =3D strtok(NULL, token_separators);=0A+        httpVersion =3D strtok(=
NULL, token_separators);=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad R=
equest\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1></b=
ody></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Requ=
est\n",=0A+                ip_address, method, requestURI, httpVersion);=0A=
+=0A+        fprintf(stderr, "Client connection terminated prematurely by t=
he first if.\n");=0A+        buf[0] =3D '\0';=0A         fclose(clnt_r); //=
if(fclose(clnt_r)){die("close");}=0A         fclose(clnt_w);=0A         ret=
urn;=0A     }=0A =0A-    // If the initial request line is not complete=0A-=
    if(buf[strlen(buf)-1] !=3D '\n'){=0A-        fprintf(stderr, "Client co=
nnection terminated prematurely.\n");=0A+    method =3D strtok(buf, token_s=
eparators);=0A+    requestURI =3D strtok(NULL, token_separators);=0A+    ht=
tpVersion =3D strtok(NULL, token_separators);=0A+    char * extra =3D strto=
k(NULL, token_separators);=0A+=0A+    fprintf(stderr, "%s \"%s %s %s\" ", i=
p_address, method, requestURI, httpVersion);=0A+=0A+=0A+  // If the initial=
 request line is not complete or there is an extra word at the end=0A+    i=
f(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL |=
| extra !=3D NULL){=0A+       =0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad=
 Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1><=
/body></html>\r\n");=0A+        fprintf(stderr, "400 Bad Request\n");=0A+=
=0A+        fprintf(stderr, "Client connection terminated prematurely by th=
e third if.\n");=0A+        buf[0] =3D 0; =0A         fclose(clnt_r);=0A   =
      fclose(clnt_w);=0A         return;=0A     }=0A =0A+    char buf3[BUF_=
SIZE];=0A =0A-    char *token_separators =3D "\t \r\n"; // tab, space, new =
line=0A-    char *method =3D strtok(buf, token_separators);=0A-    char *re=
questURI =3D strtok(NULL, token_separators);=0A-    char *httpVersion =3D s=
trtok(NULL, token_separators);=0A-        =0A-        //fprintf(stderr,"%s =
\"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVers=
ion);=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NU=
LL) {       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=
=0A+                	    "<html><body><h1>400 Bad Request</h1></body></html=
>\r\n");=0A+        	fprintf(stderr, "400 Bad Request\n");=0A =0A-     =0A-=
            =0A-    fprintf(stderr, "This is method: %s\n"=0A-            "=
This is requestURI: %s\n"=0A-            "This is httpVersion: %s\n"=0A-   =
         ,method, requestURI, httpVersion);=0A+        	fprintf(stderr, "Th=
ere was an issue with header lines\n");=0A+        	buf[0] =3D 0;=0A+      =
  	fclose(clnt_r);=0A+        	fclose(clnt_w);=0A+        	return;=0A+    	=
}=0A+=0A+=0A+	if(strlen(buf3) <=3D 2  && buf3[strlen(buf3)-1] =3D=3D '\n' )=
=0A+ 		break;=0A+=0A+    }=0A+=0A+    //From this point on, we can assume t=
hat HTTP request has correct structure=0A   =0A =0A     // If the request i=
s not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A     if (strcmp=
("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || str=
cmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A         fprintf(clnt_w,=0A    =
         "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-            "<html><body=
><h1>501 Not Implemented</h1></body></html>");=0A-        fprintf(stderr, "=
%s \"%s %s %s\" 501 Not Implemented\n",=0A-                ip_address, meth=
od, requestURI, httpVersion);=0A+            "<html><body><h1>501 Not Imple=
mented</h1></body></html>\r\n");=0A+        fprintf(stderr, "501 Not Implem=
ented\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=0A         f=
close(clnt_w);=0A         return;=0A@@ -82,21 +120,18 @@ static void handle=
_client(int clnt_fd, char *web_root, char *ip_address){=0A     // If URI do=
esn't start with '/' or there exists '..' in the URI=0A     if (strncmp("/"=
, requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A       =
  fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-                "<h=
tml><body><h1>400 Bad Request</h1></body></html>");=0A-        fprintf(stde=
rr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip_address, met=
hod, requestURI, httpVersion);=0A+                "<html><body><h1>400 Bad =
Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "400 Bad Reque=
st\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=0A         fclo=
se(clnt_w);=0A         return;=0A     }=0A         =0A         // If URI en=
ds with /, append index.html=0A-    if (strlen(requestURI) > 0 && (*(reques=
tURI + strlen(requestURI) - 1))  =3D=3D '/'){=0A-            =0A-        fp=
rintf(stderr, "This is after appending: %s\n",requestURI);=0A-        fprin=
tf(stderr, "This is httpVersion: %s\n", httpVersion);=0A+    if (strlen(req=
uestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/')      =
   =0A         strcat(requestURI, "index.html");=0A-    }=0A+  =0A         =
=0A         /*=0A         * Read from the file, and write out to file_name.=
=0A@@ -106,38 +141,34 @@ static void handle_client(int clnt_fd, char *web_r=
oot, char *ip_address){=0A         =0A     strcat(web_root, requestURI);=0A=
 =0A-    fprintf(stderr, "Filename is: %s\n", web_root);=0A+    // fprintf(=
stderr, "Filename is: %s\n", web_root);=0A =0A     struct stat st;=0A     i=
f (stat(web_root, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-        printf=
("Path is a directory!\n");=0A         fprintf(clnt_w, "HTTP/1.0 301 Moved =
Permanently\r\n"=0A                 "Location: %s/\r\n\r\n"=0A             =
    "<html><body>\r\n"=0A                 "<h1>301 Moved Permanently</h1>\r=
\n"=0A                 "<p>The document has moved <a href=3D\"%s/\">here</a=
>.</p>\r\n"=0A-                "</body></html>", requestURI, requestURI);=
=0A-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",=0A- =
               ip_address, method, requestURI, httpVersion);=0A+           =
     "</body></html>\r\n", requestURI, requestURI);=0A+        fprintf(stde=
rr, "301 Moved Permanently\n");=0A         fclose(clnt_w);=0A         fclos=
e(clnt_r);=0A         *(web_root + strlen(web_root) - strlen(requestURI)) =
=3D '\0';=0A+        buf[0] =3D 0;=0A         return; =0A     }=0A =0A     =
// Open up file_name for reading.=0A     FILE *file =3D fopen(web_root, "rb=
");=0A     if(file =3D=3D NULL){=0A-        fprintf(stderr, "File is not fo=
und!\n");=0A         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A-  =
              "<html><body><h1>404 Not Found</h1></body></html>");=0A-     =
   fprintf(stderr, "This is URI: %s\n", requestURI);=0A-        fprintf(std=
err, "This is httpVersion: %s\n", httpVersion);=0A-        fprintf(stderr, =
"%s \"%s %s %s\" 404 Not Found\n",=0A-                ip_address, method, r=
equestURI, httpVersion);=0A+                "<html><body><h1>404 Not Found<=
/h1></body></html>\r\n");=0A+        fprintf(stderr, "404 Not Found\n");=0A=
         fclose(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root +=
 strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        buf[0] =3D 0;=
=0A         return;=0A     }=0A =0A@@ -149,8 +180,7 @@ static void handle_c=
lient(int clnt_fd, char *web_root, char *ip_address){=0A     // Use fread()=
/fwrite() so that we can upload binary files.=0A =0A     fprintf(clnt_w, "H=
TTP/1.0 200 OK\r\n\r\n");=0A-    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n"=
,=0A-            ip_address, method, requestURI, httpVersion);=0A+    fprin=
tf(stderr, "200 OK\n");=0A     size_t n;=0A     while ((n =3D fread(buf2, 1=
, sizeof(buf2), file)) > 0) {=0A         if (fwrite(buf2, 1, n, clnt_w) !=
=3D n) {=0A@@ -163,6 +193,8 @@ static void handle_client(int clnt_fd, char =
*web_root, char *ip_address){=0A     * All done, clean up.=0A     */=0A =0A=
+    buf[0] =3D 0;=0A+=0A     // fread() returns 0 on EOF or on error, so w=
e need to check for errors.=0A     if (ferror(file)) {=0A         fprintf(s=
tderr, "Encountered error reading from file.\n");=0A-- =0A2.34.1=0A=0A=0AFr=
om 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:00:00 2001=0AFrom=
: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 2022 18:26:54 -0500=
=0ASubject: [PATCH 8/9] Wrote part2, but will probably need some changes.=
=0A=0A---=0A part1/http-server.c       |  96 ++++++-----=0A part2/Makefile =
           |  16 ++=0A part2/multi-http-server.c | 354 ++++++++++++++++++++=
++++++++++++++++++=0A 3 files changed, 423 insertions(+), 43 deletions(-)=
=0A create mode 100644 part2/Makefile=0A create mode 100644 part2/multi-htt=
p-server.c=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Ain=
dex f1194ac..3e500eb 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-=
server.c=0A@@ -41,7 +41,8 @@ static void handle_client(int clnt_fd, char *w=
eb_root, char *ip_address){=0A    =0A     char buf[BUF_SIZE];=0A =0A-    //=
 Read the first line=0A+    // Read the first line CHECK IF IT EVER ENTERS =
HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTER THIS=0A     if (fgets(buf,=
 sizeof(buf), clnt_r) =3D=3D NULL) {       =0A         method =3D strtok(bu=
f, token_separators);=0A         requestURI =3D strtok(NULL, token_separato=
rs);=0A@@ -64,15 +65,14 @@ static void handle_client(int clnt_fd, char *web=
_root, char *ip_address){=0A     httpVersion =3D strtok(NULL, token_separat=
ors);=0A     char * extra =3D strtok(NULL, token_separators);=0A =0A-    fp=
rintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersi=
on);=0A-=0A =0A-  // If the initial request line is not complete or there i=
s an extra word at the end=0A+    // If the initial request line is not com=
plete or there is an extra word at the end=0A     if(method =3D=3D NULL || =
requestURI =3D=3D NULL || httpVersion =3D=3D NULL || extra !=3D NULL){=0A  =
      =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A    =
             "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-=
        fprintf(stderr, "400 Bad Request\n");=0A+        fprintf(stderr, "%=
s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, method, r=
equestURI, httpVersion);=0A =0A         fprintf(stderr, "Client connection =
terminated prematurely by the third if.\n");=0A         buf[0] =3D 0; =0A@@=
 -81,13 +81,39 @@ static void handle_client(int clnt_fd, char *web_root, ch=
ar *ip_address){=0A         return;=0A     }=0A =0A+    // If the request i=
s not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A+    if (strcmp=
("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || str=
cmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+        fprintf(clnt_w,=0A+   =
         "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+            "<html><body=
><h1>501 Not Implemented</h1></body></html>\r\n");=0A+        fprintf(stder=
r, "%s \"%s %s %s\" 501 Not Implemented\n",=0A+               ip_address, m=
ethod, requestURI, httpVersion);=0A+        buf[0] =3D 0;=0A+        fclose=
(clnt_r);=0A+        fclose(clnt_w);=0A+        return;=0A+    }=0A+       =
 =0A+    // If URI doesn't start with '/' or there exists '..' in the URI=
=0A+    if (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/..")=
 !=3D NULL ) {=0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n=
"=0A+                "<html><body><h1>400 Bad Request</h1></body></html>\r\=
n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+   =
             ip_address, method, requestURI, httpVersion);=0A+        buf[0=
] =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        r=
eturn;=0A+    }=0A+=0A     char buf3[BUF_SIZE];=0A =0A     while(1){=0A 	 i=
f (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {       =0A        		fpri=
ntf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A                 	    "<ht=
ml><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-        	fprintf(=
stderr, "400 Bad Request\n");=0A+        	fprintf(stderr, "%s \"%s %s %s\" =
400 Bad Request\n",=0A+                        ip_address, method, requestU=
RI, httpVersion);=0A =0A         	fprintf(stderr, "There was an issue with =
header lines\n");=0A         	buf[0] =3D 0;=0A@@ -104,31 +130,10 @@ static =
void handle_client(int clnt_fd, char *web_root, char *ip_address){=0A =0A  =
   //From this point on, we can assume that HTTP request has correct struct=
ure=0A   =0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, re=
questURI, httpVersion);=0A+    buf[0] =3D 0;=0A =0A-    // If the request i=
s not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A-    if (strcmp=
("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || str=
cmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-        fprintf(clnt_w,=0A-   =
         "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-            "<html><body=
><h1>501 Not Implemented</h1></body></html>\r\n");=0A-        fprintf(stder=
r, "501 Not Implemented\n");=0A-        buf[0] =3D 0;=0A-        fclose(cln=
t_r);=0A-        fclose(clnt_w);=0A-        return;=0A-    }=0A-        =0A=
-    // If URI doesn't start with '/' or there exists '..' in the URI=0A-  =
  if (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D N=
ULL ) {=0A-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-  =
              "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A=
-        fprintf(stderr, "400 Bad Request\n");=0A-        buf[0] =3D 0;=0A-=
        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-        return;=0A-  =
  }=0A-        =0A-        // If URI ends with /, append index.html=0A+    =
// If URI ends with /, append index.html=0A     if (strlen(requestURI) > 0 =
&& (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/')         =0A       =
  strcat(requestURI, "index.html");=0A   =0A@@ -155,7 +160,6 @@ static void=
 handle_client(int clnt_fd, char *web_root, char *ip_address){=0A         f=
close(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root + strlen(we=
b_root) - strlen(requestURI)) =3D '\0';=0A-        buf[0] =3D 0;=0A        =
 return; =0A     }=0A =0A@@ -168,7 +172,6 @@ static void handle_client(int =
clnt_fd, char *web_root, char *ip_address){=0A         fclose(clnt_w);=0A  =
       fclose(clnt_r);=0A         *(web_root + strlen(web_root) - strlen(re=
questURI)) =3D '\0';=0A-        buf[0] =3D 0;=0A         return;=0A     }=
=0A =0A@@ -179,28 +182,35 @@ static void handle_client(int clnt_fd, char *w=
eb_root, char *ip_address){=0A        =0A     // Use fread()/fwrite() so th=
at we can upload binary files.=0A =0A+=0A     fprintf(clnt_w, "HTTP/1.0 200=
 OK\r\n\r\n");=0A     fprintf(stderr, "200 OK\n");=0A     size_t n;=0A-    =
while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A+    while ((n =
=3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {=0A     =
    if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A-            fprintf(stderr,=
 "Encountered error while writing to client\n");=0A-            exit(1);=0A=
+            // Don't crash the server and move to the next client.=0A+    =
        fclose(clnt_w);=0A+            fclose(clnt_r);=0A+            perro=
r("send bytes to client");=0A+            return;=0A         }=0A     }=0A =
=0A-    /*=0A-    * All done, clean up.=0A-    */=0A-=0A-    buf[0] =3D 0;=
=0A =0A     // fread() returns 0 on EOF or on error, so we need to check fo=
r errors.=0A     if (ferror(file)) {=0A-        fprintf(stderr, "Encountere=
d error reading from file.\n");=0A-        exit(1);=0A+        // Don't cra=
sh the server and move to the next client.=0A+        fclose(clnt_w);=0A+  =
      fclose(clnt_r);=0A+        perror("read from the file requested");=0A=
+        return;=0A     } =0A =0A+=0A+    /*=0A+    * All done, clean up.=
=0A+    */=0A+=0A     // Close FILE * for output file.=0A     if (fclose(fi=
le))=0A         die("close");       =0A@@ -297,7 +307,7 @@ int main(int arg=
c, char **argv)=0A         char *ip_address =3D inet_ntoa(clnt_addr.sin_add=
r);=0A             =0A         // clnt_addr is now populated with informati=
on about the client.=0A-        fprintf(stderr, "Accepted connection from %=
s\n",ip_address);=0A+        //fprintf(stderr, "Accepted connection from %s=
\n",ip_address);=0A =0A         handle_client(clnt_fd, web_root, ip_address=
);=0A           =0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file =
mode 100644=0Aindex 0000000..9be1e81=0A--- /dev/null=0A+++ b/part2/Makefile=
=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=3D=
c17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+default: multi-h=
ttp-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -rf a.=
out *.o multi-http-server=0A+=0A+.PHONY: all=0A+all: clean multi-http-serve=
r=0Adiff --git a/part2/multi-http-server.c b/part2/multi-http-server.c=0Ane=
w file mode 100644=0Aindex 0000000..929e9f7=0A--- /dev/null=0A+++ b/part2/m=
ulti-http-server.c=0A@@ -0,0 +1,354 @@=0A+#define _GNU_SOURCE=0A+#include <=
arpa/inet.h>=0A+#include <netdb.h>=0A+#include <stdio.h>=0A+#include <stdli=
b.h>=0A+#include <string.h>=0A+#include <sys/socket.h>=0A+#include <sys/typ=
es.h>=0A+#include <sys/stat.h>=0A+#include <unistd.h>=0A+#include <signal.h=
>=0A+#include <sys/wait.h>=0A+=0A+#define BUF_SIZE 4096=0A+=0A+static void =
die(const char *msg)=0A+{=0A+    perror(msg);=0A+    exit(1);=0A+}=0A+=0A+s=
tatic void usage_and_exit(char *argv0)=0A+{=0A+    fprintf(stderr, "usage: =
%s <server-port> <web-root>\n", argv0);=0A+    fprintf(stderr, "   ex) %s 8=
888 ~/html\n", argv0);=0A+    exit(1);=0A+}=0A+=0A+void reap_children(int s=
ig){=0A+    while (waitpid(-1, NULL, WNOHANG) > 0)=0A+        ;=0A+}=0A+=0A=
+static void handle_client(int clnt_fd, char *web_root, char *ip_address, p=
id_t pid){=0A+        =0A+    FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A+  =
  FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A+     =0A+     /*=0A+     =
* Receive the HTTP response.=0A+     */=0A+    =0A+    char *method =3D NUL=
L;=0A+    char *requestURI =3D NULL;=0A+    char *httpVersion =3D NULL;    =
=0A+    char *token_separators =3D "\t \r\n"; // tab, space, new line=0A+  =
 =0A+    char buf[BUF_SIZE];=0A+=0A+    // Read the first line CHECK IF IT =
EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTER THIS=0A+    if=
 (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A+        method =
=3D strtok(buf, token_separators);=0A+        requestURI =3D strtok(NULL, t=
oken_separators);=0A+        httpVersion =3D strtok(NULL, token_separators)=
;=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+    =
            "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A+ =
       fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+            =
    ip_address, method, requestURI, httpVersion);=0A+=0A+        fprintf(st=
derr, "Client connection terminated prematurely by the first if.\n");=0A+  =
      buf[0] =3D '\0';=0A+        fclose(clnt_r); //if(fclose(clnt_r)){die(=
"close");}=0A+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A+  =
  method =3D strtok(buf, token_separators);=0A+    requestURI =3D strtok(NU=
LL, token_separators);=0A+    httpVersion =3D strtok(NULL, token_separators=
);=0A+    char * extra =3D strtok(NULL, token_separators);=0A+=0A+=0A+    /=
/ If the initial request line is not complete or there is an extra word at =
the end=0A+    if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersi=
on =3D=3D NULL || extra !=3D NULL){=0A+       =0A+        fprintf(clnt_w, "=
HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><body><h1>400 B=
ad Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s=
 %s\" 400 Bad Request\n",=0A+                ip_address, method, requestURI=
, httpVersion);=0A+=0A+        fprintf(stderr, "Client connection terminate=
d prematurely by the third if.\n");=0A+        buf[0] =3D 0; =0A+        fc=
lose(clnt_r);=0A+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A=
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HT=
TP/1.1=0A+    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", http=
Version) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+      =
  fprintf(clnt_w,=0A+            "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+=
            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");=
=0A+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",=0A+   =
            ip_address, method, requestURI, httpVersion);=0A+        buf[0]=
 =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        re=
turn;=0A+    }=0A+        =0A+    // If URI doesn't start with '/' or there=
 exists '..' in the URI=0A+    if (strncmp("/", requestURI, 1) !=3D 0 || st=
rstr(requestURI, "/..") !=3D NULL ) {=0A+        fprintf(clnt_w, "HTTP/1.0 =
400 Bad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Reques=
t</h1></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400=
 Bad Request\n",=0A+                ip_address, method, requestURI, httpVer=
sion);=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r);=0A+        fclos=
e(clnt_w);=0A+        return;=0A+    }=0A+=0A+    char buf3[BUF_SIZE];=0A+=
=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {=
       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+ =
               	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n=
");=0A+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+   =
                     ip_address, method, requestURI, httpVersion);=0A+=0A+ =
       	fprintf(stderr, "There was an issue with header lines\n");=0A+     =
   	buf[0] =3D 0;=0A+        	fclose(clnt_r);=0A+        	fclose(clnt_w);=
=0A+        	return;=0A+    	}=0A+=0A+=0A+	if(strlen(buf3) <=3D 2  && buf3[=
strlen(buf3)-1] =3D=3D '\n' )=0A+ 		break;=0A+=0A+    }=0A+=0A+    //From t=
his point on, we can assume that HTTP request has correct structure=0A+  =
=0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI,=
 httpVersion);=0A+    buf[0] =3D 0;=0A+=0A+    // If URI ends with /, appen=
d index.html=0A+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(re=
questURI) - 1))  =3D=3D '/')         =0A+        strcat(requestURI, "index.=
html");=0A+  =0A+        =0A+        /*=0A+        * Read from the file, an=
d write out to file_name.=0A+        */=0A+        =0A+        // char *fil=
ename; [strlen(web_root + strlen(requestURI)) + 1];=0A+        =0A+    strc=
at(web_root, requestURI);=0A+=0A+    // fprintf(stderr, "Filename is: %s\n"=
, web_root);=0A+=0A+    struct stat st;=0A+    if (stat(web_root, &st) =3D=
=3D 0 && S_ISDIR(st.st_mode)) {=0A+        fprintf(clnt_w, "HTTP/1.0 301 Mo=
ved Permanently\r\n"=0A+                "Location: %s/\r\n\r\n"=0A+        =
        "<html><body>\r\n"=0A+                "<h1>301 Moved Permanently</h=
1>\r\n"=0A+                "<p>The document has moved <a href=3D\"%s/\">her=
e</a>.</p>\r\n"=0A+                "</body></html>\r\n", requestURI, reques=
tURI);=0A+        fprintf(stderr, "301 Moved Permanently\n");=0A+        fc=
lose(clnt_w);=0A+        fclose(clnt_r);=0A+        *(web_root + strlen(web=
_root) - strlen(requestURI)) =3D '\0';=0A+        return; =0A+    }=0A+=0A+=
    // Open up file_name for reading.=0A+    FILE *file =3D fopen(web_root,=
 "rb");=0A+    if(file =3D=3D NULL){=0A+        fprintf(clnt_w, "HTTP/1.0 4=
04 Not Found\r\n\r\n"=0A+                "<html><body><h1>404 Not Found</h1=
></body></html>\r\n");=0A+        fprintf(stderr, "404 Not Found\n");=0A+  =
      fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *(web_root + st=
rlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        return;=0A+    }=
=0A+=0A+    // Bring back web_root to its original content=0A+    *(web_roo=
t + strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+        =0A+    ch=
ar buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() so that we can=
 upload binary files.=0A+=0A+=0A+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r=
\n");=0A+    fprintf(stderr, "200 OK\n");=0A+    size_t n;=0A+    while ((n=
 =3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {=0A+   =
     if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A+            // Don't crash=
 the server and move to the next client.=0A+            fclose(clnt_w);=0A+=
            fclose(clnt_r);=0A+            perror("send bytes to client");=
=0A+            return;=0A+        }=0A+    }=0A+=0A+=0A+    // fread() ret=
urns 0 on EOF or on error, so we need to check for errors.=0A+    if (ferro=
r(file)) {=0A+        // Don't crash the server and move to the next client=
=2E=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        perror=
("read from the file requested");=0A+        return;=0A+    } =0A+=0A+=0A+ =
   /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    // Close FILE * for=
 output file.=0A+    if (fclose(file))=0A+        die("close");       =0A+=
=0A+    // Close client connection.=0A+    fclose(clnt_r);=0A+    fclose(cl=
nt_w);=0A+=0A+    // Resume server loop to handle next client connection.=
=0A+    return;=0A+}=0A+=0A+=0A+=0A+int main(int argc, char **argv)=0A+{=0A=
+=0A+    struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));         //=
 Zero-initialize sigaction structure=0A+    sigemptyset(&sa.sa_mask);      =
     // Don't mask any signals=0A+    sa.sa_handler =3D SIG_IGN;           =
 // Ignore the signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+    =
    die("sigaction");=0A+=0A+    /*=0A+     * Parse arguments and determine=
 output file name.=0A+     */=0A+=0A+    if (argc !=3D 3)=0A+        usage_=
and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv[1];=0A+    char *w=
eb_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtain socket address stru=
cture from server name and port number.=0A+     */=0A+=0A+    struct addrin=
fo hints, *info;=0A+    memset(&hints, 0, sizeof(hints));=0A+=0A+    hints.=
ai_family =3D AF_INET;       // Only accept IPv4 addresses=0A+    hints.ai_=
socktype =3D SOCK_STREAM; // Stream socket for TCP connections=0A+    hints=
=2Eai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints.ai_flags =3D A=
I_PASSIVE;     // Construct socket address for bind()ing=0A+=0A+    int aer=
r;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &hints, &info)) !=3D=
 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));=
=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Create a socket(), bi=
nd() it to the server, and wrap in FILE *s.=0A+     */=0A+=0A+    int serv_=
fd =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=0A+  =
  if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    if (bind(serv_fd, i=
nfo->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+   =0A+    =
freeaddrinfo(info);=0A+=0A+    // Start listen()ing for connections on this=
 socket, maintaining a queue of=0A+    // at most 8 pending connections.=0A=
+    if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=0A+=0A+     =
/*=0A+     * Server loop runs forever (writing "for (;;)" is the same as "w=
hile(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=0A+         * acce=
pt() connection from client.=0A+         */=0A+=0A+        // Define space =
to receive client address info.=0A+        struct sockaddr_in clnt_addr;=0A=
+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+        // a=
ccept() blocks until a client connects with the server, and returns=0A+    =
    // a NEW socket file descriptor for interacting with the client.=0A+   =
     int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &clnt_addr,=0A+   =
                          &clnt_addr_len);=0A+        if (clnt_fd < 0)=0A+ =
           die("accept");=0A+        =0A+        char *ip_address =3D inet_=
ntoa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr is now po=
pulated with information about the client.=0A+        //fprintf(stderr, "Ac=
cepted connection from %s\n",ip_address);=0A+=0A+        pid_t pid =3D fork=
();=0A+=0A+        // Both the parent and child will resume execution here.=
=0A+        if (pid =3D=3D 0){=0A+            =0A+            // Child proc=
ess=0A+            close(serv_fd);=0A+            handle_client(clnt_fd, we=
b_root, ip_address, getpid());=0A+            exit(0);=0A+=0A+        }else=
{=0A+            =0A+            close(clnt_fd);=0A+            // Parent p=
rocess=0A+            struct sigaction sa2;=0A+            memset(&sa2, 0, =
sizeof(sa2));         // Zero-initialize sigaction structure=0A+           =
 sigemptyset(&sa2.sa_mask);           // Don't mask any signals=0A+        =
    sa.sa_flags =3D SA_RESTART;             // Restart interrupted system c=
alls=0A+            sa.sa_handler =3D &reap_children;      // Reap children=
 upon receiving signal=0A+=0A+            if (sigaction(SIGCHLD, &sa, NULL)=
)=0A+                die("sigaction");=0A+        }=0A+         =0A+    }=
=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    // Theoretically=
, if we want our server to handle graceful termination, we=0A+    // should=
 also close() the server socket here too:=0A+    close(serv_fd);=0A+=0A+   =
 return 0;=0A+}=0A+=0A-- =0A2.34.1=0A=0A=0AFrom 5161264295a97a290b1442fd240=
cde6ea9372bcc Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia=
=2Eedu>=0ADate: Wed, 30 Nov 2022 18:28:11 -0500=0ASubject: [PATCH 9/9] Made=
 a change to README.=0A=0A---=0A README.txt | 8 ++++----=0A 1 file changed,=
 4 insertions(+), 4 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=
=0Aindex 49c4472..b6c6f1c 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@=
 -1,9 +1,9 @@=0A This file should contain:=0A =0A-  - your name=0A-  - your=
 UNI=0A-  - lab assignment number=0A-  - description for each part=0A+  - A=
rman Ozcan=0A+  - ao2794=0A+  - lab6=0A+  - It should work!=0A =0A The desc=
ription should indicate whether your solution for the part is=0A working or=
 not.  You may also want to include anything else you would=0A-- =0A2.34.1=
=0A=0A
--XQjv2NlBR1EoUd//--

From do.not.reply@cloud.cs.columbia.edu Wed Nov 30 23:56:29 2022
Date: Wed, 30 Nov 2022 23:56:29 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab6.mbox
Message-ID: <Y4gz+32TX0feOOmO@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="AGhc5L19TJqsTzL+"
Content-Disposition: inline
Status: RO
Content-Length: 164633
Lines: 3388


--AGhc5L19TJqsTzL+
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 17:01:52 -0500
Subject: [PATCH 01/10] I created a Makefile and http-server.c with skeletal
 code.

---
 part1/Makefile      |  16 +++++
 part1/http-server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 165 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/http-server.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..564dbfd
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o http-server
+
+.PHONY: all
+all: clean http-server
diff --git a/part1/http-server.c b/part1/http-server.c
new file mode 100644
index 0000000..dae362f
--- /dev/null
+++ b/part1/http-server.c
@@ -0,0 +1,149 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+int main(int argc, char **argv)
+{
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    //char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        /*
+         * Handle client connection.
+         */
+
+        // Keep track of how many bytes we've received.
+        size_t recv_len = 0;
+
+        int len;
+        char buf[32];
+
+        // recv() is like read(), except there's an extra flags argument.
+        //
+        // Since we didn't pass any flags to recv(), this is equivalent to
+        // read(clnt_fd, buf, sizeof(buf)).
+        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+            die("recv");
+
+        while (len > 0) {
+            // Book-keeping.
+            recv_len += len;
+
+            // send() is like write(), except there's an extra flags argument.
+            //
+            // Since we didn't pass any flags to send(), this is equivalent to
+            // write(clnt_fd, buf, len).
+            if (send(clnt_fd, buf, len, 0) != len)
+                die("send");
+
+            // recv() might not have read everything the client sent, so we need
+            // to continue recv()ing.
+            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+                die("recv");
+        }
+
+        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
+
+        // Close client connection.
+        close(clnt_fd);
+
+        // Resume server loop to handle next client connection.
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
-- 
2.34.1


From e0bfbf633d48c7dab909c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 21:41:13 -0500
Subject: [PATCH 02/10] Can parse the HTTP request now.

---
 part1/http-server.c | 72 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 70 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index dae362f..980293d 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#define BUF_SIZE 4096
 static void die(const char *msg)
 {
     perror(msg);
@@ -95,9 +96,73 @@ int main(int argc, char **argv)
         fprintf(stderr, "Accepted connection from %s\n",
                 inet_ntoa(clnt_addr.sin_addr));
 
+        FILE *clnt_r = fdopen(clnt_fd, "rb");
+        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+        
         /*
-         * Handle client connection.
+         * Receive the HTTP response.
          */
+        
+        char buf[BUF_SIZE];
+
+        // Read the first line
+        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+            fclose(clnt_w);
+            continue;
+        }
+
+        // If the initial request line is not complete
+        if(buf[strlen(buf)-1] != '\n'){
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+
+
+        char *token_separators = "\t \r\n"; // tab, space, new line
+        char *method = strtok(buf, token_separators);
+        char *requestURI = strtok(NULL, token_separators);
+        char *httpVersion = strtok(NULL, token_separators);
+        
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+            fprintf(clnt_w,
+                "HTTP/1.0 501 Not Implemented\n\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+        
+        // If URI doesn't start with '/' or there exists '..' in the URI
+        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+            fprintf(clnt_w,
+                "HTTP/1.0 400 Bad Request\n\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        } 
+
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+             ,method, requestURI, httpVersion);
+
+        /*        
+         * Handle client connection.
+        
 
         // Keep track of how many bytes we've received.
         size_t recv_len = 0;
@@ -131,8 +196,11 @@ int main(int argc, char **argv)
 
         fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
 
+        */
+
         // Close client connection.
-        close(clnt_fd);
+        fclose(clnt_r);
+        fclose(clnt_w);
 
         // Resume server loop to handle next client connection.
     }
-- 
2.34.1


From 5012829bc3c592d667c295a7da1bf207dc7745d1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 22:32:29 -0500
Subject: [PATCH 03/10] Now I can send a file back, but it just sends the same
 file now.

---
 part1/http-server.c | 37 +++++++++++++++++++++++++++++++++++--
 1 file changed, 35 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 980293d..f4afac9 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -135,7 +135,7 @@ int main(int argc, char **argv)
   
 
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
                 "HTTP/1.0 501 Not Implemented\n\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>\n");
@@ -152,7 +152,7 @@ int main(int argc, char **argv)
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
-        } 
+        }
 
         fprintf(stderr,
             "This is method: %s\n"
@@ -160,6 +160,39 @@ int main(int argc, char **argv)
             "This is httpVersion: %s\n"
              ,method, requestURI, httpVersion);
 
+        /*
+        * Read from the file, and write out to file_name.
+        */
+
+        // Open up file_name for reading.
+        FILE *file = fopen("file.txt", "rb");
+        if(file == NULL)
+            die("fopen");
+
+        char buf2[BUF_SIZE];
+        // Switch to fread()/fwrite() so that we can download binary files.
+        size_t n;
+        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+            if (fwrite(buf2, 1, n, clnt_w) != n) {
+                fprintf(stderr, "Encountered error writing to client\n");
+                exit(1);
+            }
+        }
+
+        /*
+        * All done, clean up.
+        */
+
+        // fread() returns 0 on EOF or on error, so we need to check for errors.
+        if (ferror(file)) {
+            fprintf(stderr, "Encountered error reading from file.\n");
+            exit(1);
+        }
+
+        // Close FILE * for output file.
+        if (fclose(file))
+            die("close");
+
         /*        
          * Handle client connection.
         
-- 
2.34.1


From 10a38d9d1573ffab2631791ec2e2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 01:07:19 -0500
Subject: [PATCH 04/10] Now my program can send the file if it exists and send
 404 Not Found when it doesn't.

---
 part1/http-server.c | 42 +++++++++++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 15 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index f4afac9..eb9a728 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -32,7 +32,7 @@ int main(int argc, char **argv)
         usage_and_exit(argv[0]);
 
     char *server_port = argv[1];
-    //char *web_root = argv[2];
+    char *web_root = argv[2];
 
 
     /*
@@ -137,8 +137,8 @@ int main(int argc, char **argv)
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
         if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\n\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
@@ -147,30 +147,40 @@ int main(int argc, char **argv)
         // If URI doesn't start with '/' or there exists '..' in the URI
         if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
             fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\n\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
         }
 
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-             ,method, requestURI, httpVersion);
-
         /*
         * Read from the file, and write out to file_name.
         */
-
+        
+        char filename[1000] = {0};
+        
+        strcpy(filename, web_root);
+        strcat(filename, requestURI);
+        
+        printf("%s\n", filename);        
         // Open up file_name for reading.
-        FILE *file = fopen("file.txt", "rb");
-        if(file == NULL)
-            die("fopen");
+        FILE *file = fopen(filename, "rb");
+        if(file == NULL){
+            printf("File is not found\n");
+            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                    "<html><body><h1>404 Not Found</h1></body></html>");
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
 
         char buf2[BUF_SIZE];
+       
         // Switch to fread()/fwrite() so that we can download binary files.
+
+        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+
         size_t n;
         while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
             if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -189,6 +199,8 @@ int main(int argc, char **argv)
             exit(1);
         }
 
+    
+
         // Close FILE * for output file.
         if (fclose(file))
             die("close");
-- 
2.34.1


From 9b98287beb7a42cd036eb343094128d736ca56df Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 02:34:29 -0500
Subject: [PATCH 05/10] Now I can send 301 Moved Permanently responses!

---
 part1/http-server.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index eb9a728..1c12a49 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -6,6 +6,7 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <unistd.h>
 
 #define BUF_SIZE 4096
@@ -153,7 +154,11 @@ int main(int argc, char **argv)
             fclose(clnt_w);
             continue;
         }
-
+        
+        // If URI ends with '/', append "index.html" to the URI 
+        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
+            strcat(requestURI, "index.html");
+        }
         /*
         * Read from the file, and write out to file_name.
         */
@@ -162,12 +167,27 @@ int main(int argc, char **argv)
         
         strcpy(filename, web_root);
         strcat(filename, requestURI);
-        
-        printf("%s\n", filename);        
+
+        printf("Filename is: %s\n", filename);
+
+        struct stat st;
+        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
+            printf("Path is a directory!\n");
+            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                    "Location: %s/\r\n\r\n"
+                    "<html><body>\r\n"
+                    "<h1>301 Moved Permanently</h1>\r\n"
+                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                    "</body></html>", requestURI, requestURI);
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
+
         // Open up file_name for reading.
         FILE *file = fopen(filename, "rb");
         if(file == NULL){
-            printf("File is not found\n");
+            printf("File is not found!\n");
             fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                     "<html><body><h1>404 Not Found</h1></body></html>");
             fclose(clnt_w);
-- 
2.34.1


From 857918bf62df7d94d34eae5f4ecb64a8f9650c27 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Tue, 29 Nov 2022 05:18:47 -0500
Subject: [PATCH 06/10] Made a lot of changes, seperated the for loop and
 client handling, also attempted to make sure there is no memory leak, but I
 have to spend more time on that.

---
 part1/http-server.c | 349 ++++++++++++++++++++++----------------------
 1 file changed, 175 insertions(+), 174 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 1c12a49..cf244f2 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <signal.h>
 
 #define BUF_SIZE 4096
 static void die(const char *msg)
@@ -23,8 +24,176 @@ static void usage_and_exit(char *argv0)
     exit(1);
 }
 
+static void handle_client(int clnt_fd, char *web_root, char *ip_address){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+    /*
+     * Receive the HTTP response.
+     */
+        
+    char buf[BUF_SIZE];
+
+    // Read the first line
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the initial request line is not complete
+    if(buf[strlen(buf)-1] != '\n'){
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+
+    char *token_separators = "\t \r\n"; // tab, space, new line
+    char *method = strtok(buf, token_separators);
+    char *requestURI = strtok(NULL, token_separators);
+    char *httpVersion = strtok(NULL, token_separators);
+        
+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+
+     
+            
+    fprintf(stderr, "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+        // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
+            
+        fprintf(stderr, "This is after appending: %s\n",requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        strcat(requestURI, "index.html");
+    }
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        printf("Path is a directory!\n");
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>", requestURI, requestURI);
+        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(stderr, "File is not found!\n");
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>");
+        fprintf(stderr, "This is URI: %s\n", requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
+            ip_address, method, requestURI, httpVersion);
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            fprintf(stderr, "Encountered error while writing to client\n");
+            exit(1);
+        }
+    }
+
+    /*
+    * All done, clean up.
+    */
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        fprintf(stderr, "Encountered error reading from file.\n");
+        exit(1);
+    } 
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
 int main(int argc, char **argv)
 {
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
     /*
      * Parse arguments and determine output file name.
      */
@@ -92,182 +261,14 @@ int main(int argc, char **argv)
                              &clnt_addr_len);
         if (clnt_fd < 0)
             die("accept");
-
-        // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",
-                inet_ntoa(clnt_addr.sin_addr));
-
-        FILE *clnt_r = fdopen(clnt_fd, "rb");
-        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
-        
-        /*
-         * Receive the HTTP response.
-         */
-        
-        char buf[BUF_SIZE];
-
-        // Read the first line
-        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
-            fclose(clnt_w);
-            continue;
-        }
-
-        // If the initial request line is not complete
-        if(buf[strlen(buf)-1] != '\n'){
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-
-
-        char *token_separators = "\t \r\n"; // tab, space, new line
-        char *method = strtok(buf, token_separators);
-        char *requestURI = strtok(NULL, token_separators);
-        char *httpVersion = strtok(NULL, token_separators);
-        
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
-  
-
-        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-            fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\r\n\r\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
         
-        // If URI doesn't start with '/' or there exists '..' in the URI
-        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-            fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-        
-        // If URI ends with '/', append "index.html" to the URI 
-        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
-            strcat(requestURI, "index.html");
-        }
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        char filename[1000] = {0};
-        
-        strcpy(filename, web_root);
-        strcat(filename, requestURI);
-
-        printf("Filename is: %s\n", filename);
-
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            printf("Path is a directory!\n");
-            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
-                    "Location: %s/\r\n\r\n"
-                    "<html><body>\r\n"
-                    "<h1>301 Moved Permanently</h1>\r\n"
-                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                    "</body></html>", requestURI, requestURI);
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        // Open up file_name for reading.
-        FILE *file = fopen(filename, "rb");
-        if(file == NULL){
-            printf("File is not found!\n");
-            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                    "<html><body><h1>404 Not Found</h1></body></html>");
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        char buf2[BUF_SIZE];
-       
-        // Switch to fread()/fwrite() so that we can download binary files.
-
-        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-
-        size_t n;
-        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
-            if (fwrite(buf2, 1, n, clnt_w) != n) {
-                fprintf(stderr, "Encountered error writing to client\n");
-                exit(1);
-            }
-        }
-
-        /*
-        * All done, clean up.
-        */
-
-        // fread() returns 0 on EOF or on error, so we need to check for errors.
-        if (ferror(file)) {
-            fprintf(stderr, "Encountered error reading from file.\n");
-            exit(1);
-        }
-
-    
-
-        // Close FILE * for output file.
-        if (fclose(file))
-            die("close");
-
-        /*        
-         * Handle client connection.
-        
-
-        // Keep track of how many bytes we've received.
-        size_t recv_len = 0;
-
-        int len;
-        char buf[32];
-
-        // recv() is like read(), except there's an extra flags argument.
-        //
-        // Since we didn't pass any flags to recv(), this is equivalent to
-        // read(clnt_fd, buf, sizeof(buf)).
-        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-            die("recv");
-
-        while (len > 0) {
-            // Book-keeping.
-            recv_len += len;
-
-            // send() is like write(), except there's an extra flags argument.
-            //
-            // Since we didn't pass any flags to send(), this is equivalent to
-            // write(clnt_fd, buf, len).
-            if (send(clnt_fd, buf, len, 0) != len)
-                die("send");
-
-            // recv() might not have read everything the client sent, so we need
-            // to continue recv()ing.
-            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-                die("recv");
-        }
-
-        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
-
-        */
-
-        // Close client connection.
-        fclose(clnt_r);
-        fclose(clnt_w);
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
-        // Resume server loop to handle next client connection.
+        handle_client(clnt_fd, web_root, ip_address);
+          
     }
 
     /*
-- 
2.34.1


From 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 05:53:07 -0500
Subject: [PATCH 07/10] I noticed a mistake. I had assumed that we won't be
 given header lines, but that's not correct. So, I generalized it. Now it can
 handle multiple header lines.

---
 part1/http-server.c | 118 ++++++++++++++++++++++++++++----------------
 1 file changed, 75 insertions(+), 43 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index cf244f2..f1194ac 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -11,6 +11,7 @@
 #include <signal.h>
 
 #define BUF_SIZE 4096
+
 static void die(const char *msg)
 {
     perror(msg);
@@ -29,51 +30,88 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     FILE *clnt_r = fdopen(clnt_fd, "rb");
     FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
      
-    /*
+     /*
      * Receive the HTTP response.
      */
-        
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
     char buf[BUF_SIZE];
 
     // Read the first line
-    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
         fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
         fclose(clnt_w);
         return;
     }
 
-    // If the initial request line is not complete
-    if(buf[strlen(buf)-1] != '\n'){
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+
+
+  // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
 
+    char buf3[BUF_SIZE];
 
-    char *token_separators = "\t \r\n"; // tab, space, new line
-    char *method = strtok(buf, token_separators);
-    char *requestURI = strtok(NULL, token_separators);
-    char *httpVersion = strtok(NULL, token_separators);
-        
-        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "400 Bad Request\n");
 
-     
-            
-    fprintf(stderr, "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
   
 
     // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
     if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
         fprintf(clnt_w,
             "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
-                ip_address, method, requestURI, httpVersion);
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "501 Not Implemented\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
@@ -82,21 +120,18 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // If URI doesn't start with '/' or there exists '..' in the URI
     if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
         // If URI ends with /, append index.html
-    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
-            
-        fprintf(stderr, "This is after appending: %s\n",requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
-    }
+  
         
         /*
         * Read from the file, and write out to file_name.
@@ -106,38 +141,34 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         
     strcat(web_root, requestURI);
 
-    fprintf(stderr, "Filename is: %s\n", web_root);
+    // fprintf(stderr, "Filename is: %s\n", web_root);
 
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
-        printf("Path is a directory!\n");
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
                 "Location: %s/\r\n\r\n"
                 "<html><body>\r\n"
                 "<h1>301 Moved Permanently</h1>\r\n"
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                "</body></html>", requestURI, requestURI);
-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
-                ip_address, method, requestURI, httpVersion);
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return; 
     }
 
     // Open up file_name for reading.
     FILE *file = fopen(web_root, "rb");
     if(file == NULL){
-        fprintf(stderr, "File is not found!\n");
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                "<html><body><h1>404 Not Found</h1></body></html>");
-        fprintf(stderr, "This is URI: %s\n", requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
-        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return;
     }
 
@@ -149,8 +180,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // Use fread()/fwrite() so that we can upload binary files.
 
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
-            ip_address, method, requestURI, httpVersion);
+    fprintf(stderr, "200 OK\n");
     size_t n;
     while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -163,6 +193,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     * All done, clean up.
     */
 
+    buf[0] = 0;
+
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
         fprintf(stderr, "Encountered error reading from file.\n");
-- 
2.34.1


From 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:26:54 -0500
Subject: [PATCH 08/10] Wrote part2, but will probably need some changes.

---
 part1/http-server.c       |  96 ++++++-----
 part2/Makefile            |  16 ++
 part2/multi-http-server.c | 354 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 423 insertions(+), 43 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/multi-http-server.c

diff --git a/part1/http-server.c b/part1/http-server.c
index f1194ac..3e500eb 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -41,7 +41,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
    
     char buf[BUF_SIZE];
 
-    // Read the first line
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -64,15 +65,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     httpVersion = strtok(NULL, token_separators);
     char * extra = strtok(NULL, token_separators);
 
-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
-
 
-  // If the initial request line is not complete or there is an extra word at the end
+    // If the initial request line is not complete or there is an extra word at the end
     if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
 
         fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
@@ -81,13 +81,39 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         return;
     }
 
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
     char buf3[BUF_SIZE];
 
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        	fprintf(stderr, "400 Bad Request\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
 
         	fprintf(stderr, "There was an issue with header lines\n");
         	buf[0] = 0;
@@ -104,31 +130,10 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     //From this point on, we can assume that HTTP request has correct structure
   
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
 
-    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-        fprintf(clnt_w,
-            "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
-        fprintf(stderr, "501 Not Implemented\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-        // If URI ends with /, append index.html
+    // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
   
@@ -155,7 +160,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return; 
     }
 
@@ -168,7 +172,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return;
     }
 
@@ -179,28 +182,35 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
        
     // Use fread()/fwrite() so that we can upload binary files.
 
+
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
     fprintf(stderr, "200 OK\n");
     size_t n;
-    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
-            fprintf(stderr, "Encountered error while writing to client\n");
-            exit(1);
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
         }
     }
 
-    /*
-    * All done, clean up.
-    */
-
-    buf[0] = 0;
 
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
-        fprintf(stderr, "Encountered error reading from file.\n");
-        exit(1);
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
     } 
 
+
+    /*
+    * All done, clean up.
+    */
+
     // Close FILE * for output file.
     if (fclose(file))
         die("close");       
@@ -297,7 +307,7 @@ int main(int argc, char **argv)
         char *ip_address = inet_ntoa(clnt_addr.sin_addr);
             
         // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",ip_address);
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
         handle_client(clnt_fd, web_root, ip_address);
           
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..9be1e81
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: multi-http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o multi-http-server
+
+.PHONY: all
+all: clean multi-http-server
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
new file mode 100644
index 0000000..929e9f7
--- /dev/null
+++ b/part2/multi-http-server.c
@@ -0,0 +1,354 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/wait.h>
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+void reap_children(int sig){
+    while (waitpid(-1, NULL, WNOHANG) > 0)
+        ;
+}
+
+static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+     /*
+     * Receive the HTTP response.
+     */
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
+    char buf[BUF_SIZE];
+
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+
+    // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    char buf3[BUF_SIZE];
+
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
+
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
+  
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
+
+    // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
+        strcat(requestURI, "index.html");
+  
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    // fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "200 OK\n");
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
+        }
+    }
+
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
+    } 
+
+
+    /*
+    * All done, clean up.
+    */
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
+int main(int argc, char **argv)
+{
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+        
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
+
+        pid_t pid = fork();
+
+        // Both the parent and child will resume execution here.
+        if (pid == 0){
+            
+            // Child process
+            close(serv_fd);
+            handle_client(clnt_fd, web_root, ip_address, getpid());
+            exit(0);
+
+        }else{
+            
+            close(clnt_fd);
+            // Parent process
+            struct sigaction sa2;
+            memset(&sa2, 0, sizeof(sa2));         // Zero-initialize sigaction structure
+            sigemptyset(&sa2.sa_mask);           // Don't mask any signals
+            sa.sa_flags = SA_RESTART;             // Restart interrupted system calls
+            sa.sa_handler = &reap_children;      // Reap children upon receiving signal
+
+            if (sigaction(SIGCHLD, &sa, NULL))
+                die("sigaction");
+        }
+         
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
+
-- 
2.34.1


From 5161264295a97a290b1442fd240cde6ea9372bcc Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:28:11 -0500
Subject: [PATCH 09/10] Made a change to README.

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..b6c6f1c 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab6
+  - It should work!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From ad8500bd591cd6d51ecbe9b7ce004e6faa945c01 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 23:55:45 -0500
Subject: [PATCH 10/10] Final commit.

---
 README.txt                | 72 ++++++++++++++++++++++++++++++++-
 part1/http-server.c       | 53 ++++++++----------------
 part2/multi-http-server.c | 85 ++++++++++++++++-----------------------
 3 files changed, 122 insertions(+), 88 deletions(-)

diff --git a/README.txt b/README.txt
index b6c6f1c..e0816e8 100644
--- a/README.txt
+++ b/README.txt
@@ -3,9 +3,79 @@ This file should contain:
   - Arman Ozcan
   - ao2794
   - lab6
-  - It should work!
+  - It should work! And I set up my web page.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==68827== Memcheck, a memory error detector
+==68827== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==68827== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==68827== Command: ./http-server 10125 /mnt/disks/students229/ao2794/html
+==68827== 
+34.145.159.110 "GET /cs3157/ HTTP/1.0" 200 OK
+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented
+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented
+34.145.159.110 "GET /cs3157 HTTP/1.1" 301 Moved Permanently
+==68827== 
+==68827== Process terminating with default action of signal 2 (SIGINT)
+==68827==    at 0x498A5D7: accept (accept.c:26)
+==68827==    by 0x10A1AF: main (http-server.c:283)
+==68827== 
+==68827== HEAP SUMMARY:
+==68827==     in use at exit: 0 bytes in 0 blocks
+==68827==   total heap usage: 19 allocs, 19 frees, 37,592 bytes allocated
+==68827== 
+==68827== All heap blocks were freed -- no leaks are possible
+==68827== 
+==68827== For lists of detected and suppressed errors, rerun with: -s
+==68827== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==115292== Memcheck, a memory error detector
+==115292== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==115292== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==115292== Command: ./multi-http-server 10129 /mnt/disks/students229/ao2794/html
+==115292== 
+34.145.159.110 (116118) "GET /cs3157/photos.jpg HTTP/1.1" 404 Not Found
+==116118== 
+==116118== HEAP SUMMARY:
+==116118==     in use at exit: 0 bytes in 0 blocks
+==116118==   total heap usage: 6 allocs, 6 frees, 9,672 bytes allocated
+==116118== 
+==116118== All heap blocks were freed -- no leaks are possible
+==116118== 
+==116118== For lists of detected and suppressed errors, rerun with: -s
+==116118== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+34.145.159.110 (117352) "GET /cs3157/images/photos.jpg HTTP/1.1" 404 Not Found
+==117352== 
+==117352== HEAP SUMMARY:
+==117352==     in use at exit: 0 bytes in 0 blocks
+==117352==   total heap usage: 6 allocs, 6 frees, 9,672 bytes allocated
+==117352== 
+==117352== All heap blocks were freed -- no leaks are possible
+==117352== 
+==117352== For lists of detected and suppressed errors, rerun with: -s
+==117352== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+34.145.159.110 (117760) "GET /cs3157/images/photo.jpg HTTP/1.1" 200 OK
+==117760== 
+==117760== HEAP SUMMARY:
+==117760==     in use at exit: 0 bytes in 0 blocks
+==117760==   total heap usage: 7 allocs, 7 frees, 17,864 bytes allocated
+==117760== 
+==117760== All heap blocks were freed -- no leaks are possible
+==117760== 
+==117760== For lists of detected and suppressed errors, rerun with: -s
+==117760== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==115292== 
+==115292== Process terminating with default action of signal 2 (SIGINT)
+==115292==    at 0x498A5D7: accept (accept.c:26)
+==115292==    by 0x10A2A7: main (multi-http-server.c:291)
+==115292== 
+==115292== HEAP SUMMARY:
+==115292==     in use at exit: 0 bytes in 0 blocks
+==115292==   total heap usage: 1 allocs, 1 frees, 64 bytes allocated
+==115292== 
+==115292== All heap blocks were freed -- no leaks are possible
+==115292== 
+==115292== For lists of detected and suppressed errors, rerun with: -s
+==115292== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/part1/http-server.c b/part1/http-server.c
index 3e500eb..5923fd2 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -41,8 +41,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
    
     char buf[BUF_SIZE];
 
-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
-    // CHECK AFTER THIS
+    // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -53,9 +52,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                 ip_address, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
-        buf[0] = '\0';
-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        buf[0] = 0;
+        fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
@@ -67,14 +65,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
 
     // If the initial request line is not complete or there is an extra word at the end
-    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+    // Or the URI doesn't start with '/' or there exists 
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL || strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/../") != NULL  || ( (strlen(requestURI) >= 3) && *(requestURI + strlen(requestURI) - 1) == '.' && *(requestURI + strlen(requestURI) - 2) == '.' && *(requestURI + strlen(requestURI) - 3) == '/') ){
        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                 ip_address, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
@@ -88,41 +86,28 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
             "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
         fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
                ip_address, method, requestURI, httpVersion);
+    
         buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-
     char buf3[BUF_SIZE];
-
+    
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
         	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                         ip_address, method, requestURI, httpVersion);
-
-        	fprintf(stderr, "There was an issue with header lines\n");
-        	buf[0] = 0;
+ 
+                buf[0] = 0;
         	fclose(clnt_r);
         	fclose(clnt_w);
         	return;
     	}
 
-
 	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
  		break;
 
@@ -135,19 +120,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
-        strcat(requestURI, "index.html");
-  
-        
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        strcat(requestURI, "index.html"); 
+         
         
     strcat(web_root, requestURI);
 
-    // fprintf(stderr, "Filename is: %s\n", web_root);
-
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
@@ -157,6 +134,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
                 "</body></html>\r\n", requestURI, requestURI);
         fprintf(stderr, "301 Moved Permanently\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -169,6 +147,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>\r\n");
         fprintf(stderr, "404 Not Found\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -191,9 +170,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
             // Don't crash the server and move to the next client.
             fclose(clnt_w);
             fclose(clnt_r);
+            fclose(file);
             perror("send bytes to client");
             return;
         }
+        fflush(clnt_w);
     }
 
 
@@ -202,6 +183,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         // Don't crash the server and move to the next client.
         fclose(clnt_w);
         fclose(clnt_r);
+        fclose(file);
         perror("read from the file requested");
         return;
     } 
@@ -212,8 +194,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     */
 
     // Close FILE * for output file.
-    if (fclose(file))
-        die("close");       
+    fclose(file);       
 
     // Close client connection.
     fclose(clnt_r);
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
index 929e9f7..4eb8018 100644
--- a/part2/multi-http-server.c
+++ b/part2/multi-http-server.c
@@ -31,11 +31,12 @@ void reap_children(int sig){
         ;
 }
 
-static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){
-        
+static void handle_client(int clnt_fd, char *web_root, char *ip_address){
+
     FILE *clnt_r = fdopen(clnt_fd, "rb");
     FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
-     
+    int pid = (int) getpid();
+
      /*
      * Receive the HTTP response.
      */
@@ -47,8 +48,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
    
     char buf[BUF_SIZE];
 
-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
-    // CHECK AFTER THIS
+    // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -56,12 +56,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                ip_address, pid, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
-        buf[0] = '\0';
-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        buf[0] = 0;
+        fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
@@ -73,14 +72,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
 
     // If the initial request line is not complete or there is an extra word at the end
-    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
-       
+    // Or the URI doesn't start with '/' or there exists 
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL || strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/../") != NULL  || ( (strlen(requestURI) >= 3) && *(requestURI + strlen(requestURI) - 1) == '.' && *(requestURI + strlen(requestURI) - 2) == '.' && *(requestURI + strlen(requestURI) - 3) == '/') ){
+
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                ip_address, pid, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
@@ -92,43 +91,30 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         fprintf(clnt_w,
             "HTTP/1.0 501 Not Implemented\r\n\r\n"
             "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
-               ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, pid, method, requestURI, httpVersion);
+    
         buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-
     char buf3[BUF_SIZE];
-
+    
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                        ip_address, method, requestURI, httpVersion);
-
-        	fprintf(stderr, "There was an issue with header lines\n");
-        	buf[0] = 0;
+        	fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, pid, method, requestURI, httpVersion);
+ 
+                buf[0] = 0;
         	fclose(clnt_r);
         	fclose(clnt_w);
         	return;
     	}
 
-
 	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
  		break;
 
@@ -136,33 +122,26 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
     //From this point on, we can assume that HTTP request has correct structure
   
-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    fprintf(stderr, "%s (%d) \"%s %s %s\" ", ip_address, pid, method, requestURI, httpVersion);
     buf[0] = 0;
 
     // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
-        strcat(requestURI, "index.html");
-  
-        
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        strcat(requestURI, "index.html"); 
+         
         
     strcat(web_root, requestURI);
 
-    // fprintf(stderr, "Filename is: %s\n", web_root);
-
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
-                "Location: %s/\r\n\r\n"
+                "Location: %s/\r\n\r\n" 
                 "<html><body>\r\n"
                 "<h1>301 Moved Permanently</h1>\r\n"
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
                 "</body></html>\r\n", requestURI, requestURI);
         fprintf(stderr, "301 Moved Permanently\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -175,6 +154,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>\r\n");
         fprintf(stderr, "404 Not Found\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -197,9 +177,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
             // Don't crash the server and move to the next client.
             fclose(clnt_w);
             fclose(clnt_r);
+            fclose(file);
             perror("send bytes to client");
             return;
         }
+        fflush(clnt_w);
     }
 
 
@@ -208,6 +190,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         // Don't crash the server and move to the next client.
         fclose(clnt_w);
         fclose(clnt_r);
+        fclose(file);
         perror("read from the file requested");
         return;
     } 
@@ -218,8 +201,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
     */
 
     // Close FILE * for output file.
-    if (fclose(file))
-        die("close");       
+    fclose(file);       
 
     // Close client connection.
     fclose(clnt_r);
@@ -227,6 +209,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
     // Resume server loop to handle next client connection.
     return;
+
 }
 
 
@@ -322,7 +305,7 @@ int main(int argc, char **argv)
             
             // Child process
             close(serv_fd);
-            handle_client(clnt_fd, web_root, ip_address, getpid());
+            handle_client(clnt_fd, web_root, ip_address);
             exit(0);
 
         }else{
-- 
2.34.1


--AGhc5L19TJqsTzL+
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab6.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 26 Nov 2022 17:01:52=
 -0500=0ASubject: [PATCH 01/10] I created a Makefile and http-server.c with=
 skeletal=0A code.=0A=0A---=0A part1/Makefile      |  16 +++++=0A part1/htt=
p-server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++=0A 2 files ch=
anged, 165 insertions(+)=0A create mode 100644 part1/Makefile=0A create mod=
e 100644 part1/http-server.c=0A=0Adiff --git a/part1/Makefile b/part1/Makef=
ile=0Anew file mode 100644=0Aindex 0000000..564dbfd=0A--- /dev/null=0A+++ b=
/part1/Makefile=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wp=
edantic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+d=
efault: http-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=0A+	=
rm -rf a.out *.o http-server=0A+=0A+.PHONY: all=0A+all: clean http-server=
=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Anew file mode 1=
00644=0Aindex 0000000..dae362f=0A--- /dev/null=0A+++ b/part1/http-server.c=
=0A@@ -0,0 +1,149 @@=0A+#define _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#i=
nclude <netdb.h>=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <=
string.h>=0A+#include <sys/socket.h>=0A+#include <sys/types.h>=0A+#include =
<unistd.h>=0A+=0A+static void die(const char *msg)=0A+{=0A+    perror(msg);=
=0A+    exit(1);=0A+}=0A+=0A+static void usage_and_exit(char *argv0)=0A+{=
=0A+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);=0A+=
    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);=0A+    exit(1);=0A+}=
=0A+=0A+int main(int argc, char **argv)=0A+{=0A+    /*=0A+     * Parse argu=
ments and determine output file name.=0A+     */=0A+=0A+    if (argc !=3D 3=
)=0A+        usage_and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv=
[1];=0A+    //char *web_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtai=
n socket address structure from server name and port number.=0A+     */=0A+=
=0A+    struct addrinfo hints, *info;=0A+    memset(&hints, 0, sizeof(hints=
));=0A+=0A+    hints.ai_family =3D AF_INET;       // Only accept IPv4 addre=
sses=0A+    hints.ai_socktype =3D SOCK_STREAM; // Stream socket for TCP con=
nections=0A+    hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    h=
ints.ai_flags =3D AI_PASSIVE;     // Construct socket address for bind()ing=
=0A+=0A+    int aerr;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &=
hints, &info)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", ga=
i_strerror(aerr));=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Cre=
ate a socket(), bind() it to the server, and wrap in FILE *s.=0A+     */=0A=
+=0A+    int serv_fd =3D socket(info->ai_family, info->ai_socktype, info->a=
i_protocol);=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    i=
f (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind=
");=0A+   =0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for c=
onnections on this socket, maintaining a queue of=0A+    // at most 8 pendi=
ng connections.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen")=
;=0A+=0A+=0A+     /*=0A+     * Server loop runs forever (writing "for (;;)"=
 is the same as "while(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=
=0A+         * accept() connection from client.=0A+         */=0A+=0A+     =
   // Define space to receive client address info.=0A+        struct sockad=
dr_in clnt_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=
=0A+=0A+        // accept() blocks until a client connects with the server,=
 and returns=0A+        // a NEW socket file descriptor for interacting wit=
h the client.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *=
) &clnt_addr,=0A+                             &clnt_addr_len);=0A+        i=
f (clnt_fd < 0)=0A+            die("accept");=0A+=0A+        // clnt_addr i=
s now populated with information about the client.=0A+        fprintf(stder=
r, "Accepted connection from %s\n",=0A+                inet_ntoa(clnt_addr.=
sin_addr));=0A+=0A+        /*=0A+         * Handle client connection.=0A+  =
       */=0A+=0A+        // Keep track of how many bytes we've received.=0A=
+        size_t recv_len =3D 0;=0A+=0A+        int len;=0A+        char buf=
[32];=0A+=0A+        // recv() is like read(), except there's an extra flag=
s argument.=0A+        //=0A+        // Since we didn't pass any flags to r=
ecv(), this is equivalent to=0A+        // read(clnt_fd, buf, sizeof(buf)).=
=0A+        if ((len =3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A+      =
      die("recv");=0A+=0A+        while (len > 0) {=0A+            // Book-=
keeping.=0A+            recv_len +=3D len;=0A+=0A+            // send() is =
like write(), except there's an extra flags argument.=0A+            //=0A+=
            // Since we didn't pass any flags to send(), this is equivalent=
 to=0A+            // write(clnt_fd, buf, len).=0A+            if (send(cln=
t_fd, buf, len, 0) !=3D len)=0A+                die("send");=0A+=0A+       =
     // recv() might not have read everything the client sent, so we need=
=0A+            // to continue recv()ing.=0A+            if ((len =3D recv(=
clnt_fd, buf, sizeof(buf), 0)) < 0)=0A+                die("recv");=0A+    =
    }=0A+=0A+        fprintf(stderr, "Received (and sent) %lu bytes in tota=
l\n", recv_len);=0A+=0A+        // Close client connection.=0A+        clos=
e(clnt_fd);=0A+=0A+        // Resume server loop to handle next client conn=
ection.=0A+    }=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    =
// Theoretically, if we want our server to handle graceful termination, we=
=0A+    // should also close() the server socket here too:=0A+    close(ser=
v_fd);=0A+=0A+    return 0;=0A+}=0A-- =0A2.34.1=0A=0A=0AFrom e0bfbf633d48c7=
dab909c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao=
2794@columbia.edu>=0ADate: Sat, 26 Nov 2022 21:41:13 -0500=0ASubject: [PATC=
H 02/10] Can parse the HTTP request now.=0A=0A---=0A part1/http-server.c | =
72 +++++++++++++++++++++++++++++++++++++++++++--=0A 1 file changed, 70 inse=
rtions(+), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/htt=
p-server.c=0Aindex dae362f..980293d 100644=0A--- a/part1/http-server.c=0A++=
+ b/part1/http-server.c=0A@@ -8,6 +8,7 @@=0A #include <sys/types.h>=0A #inc=
lude <unistd.h>=0A =0A+#define BUF_SIZE 4096=0A static void die(const char =
*msg)=0A {=0A     perror(msg);=0A@@ -95,9 +96,73 @@ int main(int argc, char=
 **argv)=0A         fprintf(stderr, "Accepted connection from %s\n",=0A    =
             inet_ntoa(clnt_addr.sin_addr));=0A =0A+        FILE *clnt_r =
=3D fdopen(clnt_fd, "rb");=0A+        FILE *clnt_w =3D fdopen(dup(clnt_fd),=
 "wb");=0A+        =0A         /*=0A-         * Handle client connection.=
=0A+         * Receive the HTTP response.=0A          */=0A+        =0A+   =
     char buf[BUF_SIZE];=0A+=0A+        // Read the first line=0A+        i=
f (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A+            fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A+            fclose=
(clnt_r); //if(fclose(clnt_r)){die("close");}=0A+            fclose(clnt_w)=
;=0A+            continue;=0A+        }=0A+=0A+        // If the initial re=
quest line is not complete=0A+        if(buf[strlen(buf)-1] !=3D '\n'){=0A+=
            fprintf(stderr, "Client connection terminated prematurely.\n");=
=0A+            fclose(clnt_r);=0A+            fclose(clnt_w);=0A+         =
   continue;=0A+        }=0A+=0A+=0A+        char *token_separators =3D "\t=
 \r\n"; // tab, space, new line=0A+        char *method =3D strtok(buf, tok=
en_separators);=0A+        char *requestURI =3D strtok(NULL, token_separato=
rs);=0A+        char *httpVersion =3D strtok(NULL, token_separators);=0A+  =
      =0A+        fprintf(stderr,=0A+            "This is method: %s\n"=0A+=
            "This is requestURI: %s\n"=0A+            "This is httpVersion:=
 %s\n"=0A+            ,method, requestURI, httpVersion);=0A+  =0A+=0A+     =
   // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP=
/1.1=0A+        if (strcmp("GET", method) !=3D 0 || strcmp("HTTP/1.0", http=
Version) !=3D 0 || strcmp("HTTP/1.1", httpVersion) !=3D 0) {=0A+           =
 fprintf(clnt_w,=0A+                "HTTP/1.0 501 Not Implemented\n\n"=0A+ =
               "<html><body><h1>501 Not Implemented</h1></body></html>\n");=
=0A+            fclose(clnt_r);=0A+            fclose(clnt_w);=0A+         =
   continue;=0A+        }=0A+        =0A+        // If URI doesn't start wi=
th '/' or there exists '..' in the URI=0A+        if (strncmp("/", requestU=
RI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A+            fpri=
ntf(clnt_w,=0A+                "HTTP/1.0 400 Bad Request\n\n"=0A+          =
      "<html><body><h1>400 Bad Request</h1></body></html>\n");=0A+         =
   fclose(clnt_r);=0A+            fclose(clnt_w);=0A+            continue;=
=0A+        } =0A+=0A+        fprintf(stderr,=0A+            "This is metho=
d: %s\n"=0A+            "This is requestURI: %s\n"=0A+            "This is =
httpVersion: %s\n"=0A+             ,method, requestURI, httpVersion);=0A+=
=0A+        /*        =0A+         * Handle client connection.=0A+        =
=0A =0A         // Keep track of how many bytes we've received.=0A         =
size_t recv_len =3D 0;=0A@@ -131,8 +196,11 @@ int main(int argc, char **arg=
v)=0A =0A         fprintf(stderr, "Received (and sent) %lu bytes in total\n=
", recv_len);=0A =0A+        */=0A+=0A         // Close client connection.=
=0A-        close(clnt_fd);=0A+        fclose(clnt_r);=0A+        fclose(cl=
nt_w);=0A =0A         // Resume server loop to handle next client connectio=
n.=0A     }=0A-- =0A2.34.1=0A=0A=0AFrom 5012829bc3c592d667c295a7da1bf207dc7=
745d1 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0A=
Date: Sat, 26 Nov 2022 22:32:29 -0500=0ASubject: [PATCH 03/10] Now I can se=
nd a file back, but it just sends the same=0A file now.=0A=0A---=0A part1/h=
ttp-server.c | 37 +++++++++++++++++++++++++++++++++++--=0A 1 file changed, =
35 insertions(+), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/pa=
rt1/http-server.c=0Aindex 980293d..f4afac9 100644=0A--- a/part1/http-server=
=2Ec=0A+++ b/part1/http-server.c=0A@@ -135,7 +135,7 @@ int main(int argc, c=
har **argv)=0A   =0A =0A         // If the request is not GET or the HTTP v=
ersion is not HTTP/1.0 or HTTP/1.1=0A-        if (strcmp("GET", method) !=
=3D 0 || strcmp("HTTP/1.0", httpVersion) !=3D 0 || strcmp("HTTP/1.1", httpV=
ersion) !=3D 0) {=0A+        if (strcmp("GET", method) !=3D 0 || !(strcmp("=
HTTP/1.0", httpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D =
0)) {=0A             fprintf(clnt_w,=0A                 "HTTP/1.0 501 Not I=
mplemented\n\n"=0A                 "<html><body><h1>501 Not Implemented</h1=
></body></html>\n");=0A@@ -152,7 +152,7 @@ int main(int argc, char **argv)=
=0A             fclose(clnt_r);=0A             fclose(clnt_w);=0A          =
   continue;=0A-        } =0A+        }=0A =0A         fprintf(stderr,=0A  =
           "This is method: %s\n"=0A@@ -160,6 +160,39 @@ int main(int argc,=
 char **argv)=0A             "This is httpVersion: %s\n"=0A              ,m=
ethod, requestURI, httpVersion);=0A =0A+        /*=0A+        * Read from t=
he file, and write out to file_name.=0A+        */=0A+=0A+        // Open u=
p file_name for reading.=0A+        FILE *file =3D fopen("file.txt", "rb");=
=0A+        if(file =3D=3D NULL)=0A+            die("fopen");=0A+=0A+      =
  char buf2[BUF_SIZE];=0A+        // Switch to fread()/fwrite() so that we =
can download binary files.=0A+        size_t n;=0A+        while ((n =3D fr=
ead(buf2, 1, sizeof(buf2), file)) > 0) {=0A+            if (fwrite(buf2, 1,=
 n, clnt_w) !=3D n) {=0A+                fprintf(stderr, "Encountered error=
 writing to client\n");=0A+                exit(1);=0A+            }=0A+   =
     }=0A+=0A+        /*=0A+        * All done, clean up.=0A+        */=0A+=
=0A+        // fread() returns 0 on EOF or on error, so we need to check fo=
r errors.=0A+        if (ferror(file)) {=0A+            fprintf(stderr, "En=
countered error reading from file.\n");=0A+            exit(1);=0A+        =
}=0A+=0A+        // Close FILE * for output file.=0A+        if (fclose(fil=
e))=0A+            die("close");=0A+=0A         /*        =0A          * Ha=
ndle client connection.=0A         =0A-- =0A2.34.1=0A=0A=0AFrom 10a38d9d157=
3ffab2631791ec2e2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan =
<ao2794@columbia.edu>=0ADate: Mon, 28 Nov 2022 01:07:19 -0500=0ASubject: [P=
ATCH 04/10] Now my program can send the file if it exists and send=0A 404 N=
ot Found when it doesn't.=0A=0A---=0A part1/http-server.c | 42 ++++++++++++=
+++++++++++++++---------------=0A 1 file changed, 27 insertions(+), 15 dele=
tions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Ainde=
x f4afac9..eb9a728 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-se=
rver.c=0A@@ -32,7 +32,7 @@ int main(int argc, char **argv)=0A         usage=
_and_exit(argv[0]);=0A =0A     char *server_port =3D argv[1];=0A-    //char=
 *web_root =3D argv[2];=0A+    char *web_root =3D argv[2];=0A =0A =0A     /=
*=0A@@ -137,8 +137,8 @@ int main(int argc, char **argv)=0A         // If th=
e request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A    =
     if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =
=3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A             fpr=
intf(clnt_w,=0A-                "HTTP/1.0 501 Not Implemented\n\n"=0A-     =
           "<html><body><h1>501 Not Implemented</h1></body></html>\n");=0A+=
                "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+                "=
<html><body><h1>501 Not Implemented</h1></body></html>");=0A             fc=
lose(clnt_r);=0A             fclose(clnt_w);=0A             continue;=0A@@ =
-147,30 +147,40 @@ int main(int argc, char **argv)=0A         // If URI doe=
sn't start with '/' or there exists '..' in the URI=0A         if (strncmp(=
"/", requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A    =
         fprintf(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\n\n"=
=0A-                "<html><body><h1>400 Bad Request</h1></body></html>\n")=
;=0A+                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                =
"<html><body><h1>400 Bad Request</h1></body></html>");=0A             fclos=
e(clnt_r);=0A             fclose(clnt_w);=0A             continue;=0A      =
   }=0A =0A-        fprintf(stderr,=0A-            "This is method: %s\n"=
=0A-            "This is requestURI: %s\n"=0A-            "This is httpVers=
ion: %s\n"=0A-             ,method, requestURI, httpVersion);=0A-=0A       =
  /*=0A         * Read from the file, and write out to file_name.=0A       =
  */=0A-=0A+        =0A+        char filename[1000] =3D {0};=0A+        =0A=
+        strcpy(filename, web_root);=0A+        strcat(filename, requestURI=
);=0A+        =0A+        printf("%s\n", filename);        =0A         // O=
pen up file_name for reading.=0A-        FILE *file =3D fopen("file.txt", "=
rb");=0A-        if(file =3D=3D NULL)=0A-            die("fopen");=0A+     =
   FILE *file =3D fopen(filename, "rb");=0A+        if(file =3D=3D NULL){=
=0A+            printf("File is not found\n");=0A+            fprintf(clnt_=
w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                    "<html><body><h1=
>404 Not Found</h1></body></html>");=0A+            fclose(clnt_w);=0A+    =
        fclose(clnt_r);=0A+            continue;=0A+        }=0A =0A       =
  char buf2[BUF_SIZE];=0A+       =0A         // Switch to fread()/fwrite() =
so that we can download binary files.=0A+=0A+        fprintf(clnt_w, "HTTP/=
1.0 200 OK\r\n\r\n");=0A+=0A         size_t n;=0A         while ((n =3D fre=
ad(buf2, 1, sizeof(buf2), file)) > 0) {=0A             if (fwrite(buf2, 1, =
n, clnt_w) !=3D n) {=0A@@ -189,6 +199,8 @@ int main(int argc, char **argv)=
=0A             exit(1);=0A         }=0A =0A+    =0A+=0A         // Close F=
ILE * for output file.=0A         if (fclose(file))=0A             die("clo=
se");=0A-- =0A2.34.1=0A=0A=0AFrom 9b98287beb7a42cd036eb343094128d736ca56df =
Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: =
Mon, 28 Nov 2022 02:34:29 -0500=0ASubject: [PATCH 05/10] Now I can send 301=
 Moved Permanently responses!=0A=0A---=0A part1/http-server.c | 28 ++++++++=
++++++++++++++++----=0A 1 file changed, 24 insertions(+), 4 deletions(-)=0A=
=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Aindex eb9a728..=
1c12a49 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=0A@@=
 -6,6 +6,7 @@=0A #include <string.h>=0A #include <sys/socket.h>=0A #include=
 <sys/types.h>=0A+#include <sys/stat.h>=0A #include <unistd.h>=0A =0A #defi=
ne BUF_SIZE 4096=0A@@ -153,7 +154,11 @@ int main(int argc, char **argv)=0A =
            fclose(clnt_w);=0A             continue;=0A         }=0A-=0A+  =
      =0A+        // If URI ends with '/', append "index.html" to the URI =
=0A+        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI)=
 - 1)  =3D=3D '/'){=0A+            strcat(requestURI, "index.html");=0A+   =
     }=0A         /*=0A         * Read from the file, and write out to file=
_name.=0A         */=0A@@ -162,12 +167,27 @@ int main(int argc, char **argv=
)=0A         =0A         strcpy(filename, web_root);=0A         strcat(file=
name, requestURI);=0A-        =0A-        printf("%s\n", filename);        =
=0A+=0A+        printf("Filename is: %s\n", filename);=0A+=0A+        struc=
t stat st;=0A+        if (stat(filename, &st) =3D=3D 0 && S_ISDIR(st.st_mod=
e)) {=0A+            printf("Path is a directory!\n");=0A+            fprin=
tf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=0A+                    "Loc=
ation: %s/\r\n\r\n"=0A+                    "<html><body>\r\n"=0A+          =
          "<h1>301 Moved Permanently</h1>\r\n"=0A+                    "<p>T=
he document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+             =
       "</body></html>", requestURI, requestURI);=0A+            fclose(cln=
t_w);=0A+            fclose(clnt_r);=0A+            continue;=0A+        }=
=0A+=0A         // Open up file_name for reading.=0A         FILE *file =3D=
 fopen(filename, "rb");=0A         if(file =3D=3D NULL){=0A-            pri=
ntf("File is not found\n");=0A+            printf("File is not found!\n");=
=0A             fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A        =
             "<html><body><h1>404 Not Found</h1></body></html>");=0A       =
      fclose(clnt_w);=0A-- =0A2.34.1=0A=0A=0AFrom 857918bf62df7d94d34eae5f4=
ecb64a8f9650c27 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columb=
ia.edu>=0ADate: Tue, 29 Nov 2022 05:18:47 -0500=0ASubject: [PATCH 06/10] Ma=
de a lot of changes, seperated the for loop and=0A client handling, also at=
tempted to make sure there is no memory leak, but I=0A have to spend more t=
ime on that.=0A=0A---=0A part1/http-server.c | 349 ++++++++++++++++++++++--=
--------------------=0A 1 file changed, 175 insertions(+), 174 deletions(-)=
=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Aindex 1c12a4=
9..cf244f2 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=
=0A@@ -8,6 +8,7 @@=0A #include <sys/types.h>=0A #include <sys/stat.h>=0A #i=
nclude <unistd.h>=0A+#include <signal.h>=0A =0A #define BUF_SIZE 4096=0A st=
atic void die(const char *msg)=0A@@ -23,8 +24,176 @@ static void usage_and_=
exit(char *argv0)=0A     exit(1);=0A }=0A =0A+static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A+        =0A+    FILE *clnt_=
r =3D fdopen(clnt_fd, "rb");=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "=
wb");=0A+     =0A+    /*=0A+     * Receive the HTTP response.=0A+     */=0A=
+        =0A+    char buf[BUF_SIZE];=0A+=0A+    // Read the first line=0A+ =
   if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A+        fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A+        fclose(cln=
t_r); //if(fclose(clnt_r)){die("close");}=0A+        fclose(clnt_w);=0A+   =
     return;=0A+    }=0A+=0A+    // If the initial request line is not comp=
lete=0A+    if(buf[strlen(buf)-1] !=3D '\n'){=0A+        fprintf(stderr, "C=
lient connection terminated prematurely.\n");=0A+        fclose(clnt_r);=0A=
+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A+=0A+    char *t=
oken_separators =3D "\t \r\n"; // tab, space, new line=0A+    char *method =
=3D strtok(buf, token_separators);=0A+    char *requestURI =3D strtok(NULL,=
 token_separators);=0A+    char *httpVersion =3D strtok(NULL, token_separat=
ors);=0A+        =0A+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa=
(clnt_addr.sin_addr), method, requestURI, httpVersion);=0A+=0A+     =0A+   =
         =0A+    fprintf(stderr, "This is method: %s\n"=0A+            "Thi=
s is requestURI: %s\n"=0A+            "This is httpVersion: %s\n"=0A+      =
      ,method, requestURI, httpVersion);=0A+  =0A+=0A+    // If the request=
 is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A+    if (strc=
mp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || s=
trcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+        fprintf(clnt_w,=0A+ =
           "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+            "<html><bo=
dy><h1>501 Not Implemented</h1></body></html>");=0A+        fprintf(stderr,=
 "%s \"%s %s %s\" 501 Not Implemented\n",=0A+                ip_address, me=
thod, requestURI, httpVersion);=0A+        fclose(clnt_r);=0A+        fclos=
e(clnt_w);=0A+        return;=0A+    }=0A+        =0A+    // If URI doesn't=
 start with '/' or there exists '..' in the URI=0A+    if (strncmp("/", req=
uestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A+        fpr=
intf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><=
body><h1>400 Bad Request</h1></body></html>");=0A+        fprintf(stderr, "=
%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, method, =
requestURI, httpVersion);=0A+        fclose(clnt_r);=0A+        fclose(clnt=
_w);=0A+        return;=0A+    }=0A+        =0A+        // If URI ends with=
 /, append index.html=0A+    if (strlen(requestURI) > 0 && (*(requestURI + =
strlen(requestURI) - 1))  =3D=3D '/'){=0A+            =0A+        fprintf(s=
tderr, "This is after appending: %s\n",requestURI);=0A+        fprintf(stde=
rr, "This is httpVersion: %s\n", httpVersion);=0A+        strcat(requestURI=
, "index.html");=0A+    }=0A+        =0A+        /*=0A+        * Read from =
the file, and write out to file_name.=0A+        */=0A+        =0A+        =
// char *filename; [strlen(web_root + strlen(requestURI)) + 1];=0A+        =
=0A+    strcat(web_root, requestURI);=0A+=0A+    fprintf(stderr, "Filename =
is: %s\n", web_root);=0A+=0A+    struct stat st;=0A+    if (stat(web_root, =
&st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+        printf("Path is a direct=
ory!\n");=0A+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=
=0A+                "Location: %s/\r\n\r\n"=0A+                "<html><body=
>\r\n"=0A+                "<h1>301 Moved Permanently</h1>\r\n"=0A+         =
       "<p>The document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+ =
               "</body></html>", requestURI, requestURI);=0A+        fprint=
f(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",=0A+                ip_=
address, method, requestURI, httpVersion);=0A+        fclose(clnt_w);=0A+  =
      fclose(clnt_r);=0A+        *(web_root + strlen(web_root) - strlen(req=
uestURI)) =3D '\0';=0A+        return; =0A+    }=0A+=0A+    // Open up file=
_name for reading.=0A+    FILE *file =3D fopen(web_root, "rb");=0A+    if(f=
ile =3D=3D NULL){=0A+        fprintf(stderr, "File is not found!\n");=0A+  =
      fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                "=
<html><body><h1>404 Not Found</h1></body></html>");=0A+        fprintf(stde=
rr, "This is URI: %s\n", requestURI);=0A+        fprintf(stderr, "This is h=
ttpVersion: %s\n", httpVersion);=0A+        fprintf(stderr, "%s \"%s %s %s\=
" 404 Not Found\n",=0A+                ip_address, method, requestURI, http=
Version);=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        =
*(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        re=
turn;=0A+    }=0A+=0A+    // Bring back web_root to its original content=0A=
+    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+    =
    =0A+    char buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() =
so that we can upload binary files.=0A+=0A+    fprintf(clnt_w, "HTTP/1.0 20=
0 OK\r\n\r\n");=0A+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",=0A+     =
       ip_address, method, requestURI, httpVersion);=0A+    size_t n;=0A+  =
  while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A+        if (f=
write(buf2, 1, n, clnt_w) !=3D n) {=0A+            fprintf(stderr, "Encount=
ered error while writing to client\n");=0A+            exit(1);=0A+        =
}=0A+    }=0A+=0A+    /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    =
// fread() returns 0 on EOF or on error, so we need to check for errors.=0A=
+    if (ferror(file)) {=0A+        fprintf(stderr, "Encountered error read=
ing from file.\n");=0A+        exit(1);=0A+    } =0A+=0A+    // Close FILE =
* for output file.=0A+    if (fclose(file))=0A+        die("close");       =
=0A+=0A+    // Close client connection.=0A+    fclose(clnt_r);=0A+    fclos=
e(clnt_w);=0A+=0A+    // Resume server loop to handle next client connectio=
n.=0A+    return;=0A+}=0A+=0A+=0A+=0A int main(int argc, char **argv)=0A {=
=0A+=0A+    struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));        =
 // Zero-initialize sigaction structure=0A+    sigemptyset(&sa.sa_mask);   =
        // Don't mask any signals=0A+    sa.sa_handler =3D SIG_IGN;        =
    // Ignore the signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+ =
       die("sigaction");=0A+=0A     /*=0A      * Parse arguments and determ=
ine output file name.=0A      */=0A@@ -92,182 +261,14 @@ int main(int argc,=
 char **argv)=0A                              &clnt_addr_len);=0A         i=
f (clnt_fd < 0)=0A             die("accept");=0A-=0A-        // clnt_addr i=
s now populated with information about the client.=0A-        fprintf(stder=
r, "Accepted connection from %s\n",=0A-                inet_ntoa(clnt_addr.=
sin_addr));=0A-=0A-        FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A-     =
   FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A-        =0A-        /*=
=0A-         * Receive the HTTP response.=0A-         */=0A-        =0A-   =
     char buf[BUF_SIZE];=0A-=0A-        // Read the first line=0A-        i=
f (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A-            fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A-            fclose=
(clnt_r); //if(fclose(clnt_r)){die("close");}=0A-            fclose(clnt_w)=
;=0A-            continue;=0A-        }=0A-=0A-        // If the initial re=
quest line is not complete=0A-        if(buf[strlen(buf)-1] !=3D '\n'){=0A-=
            fprintf(stderr, "Client connection terminated prematurely.\n");=
=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-         =
   continue;=0A-        }=0A-=0A-=0A-        char *token_separators =3D "\t=
 \r\n"; // tab, space, new line=0A-        char *method =3D strtok(buf, tok=
en_separators);=0A-        char *requestURI =3D strtok(NULL, token_separato=
rs);=0A-        char *httpVersion =3D strtok(NULL, token_separators);=0A-  =
      =0A-        fprintf(stderr,=0A-            "This is method: %s\n"=0A-=
            "This is requestURI: %s\n"=0A-            "This is httpVersion:=
 %s\n"=0A-            ,method, requestURI, httpVersion);=0A-  =0A-=0A-     =
   // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP=
/1.1=0A-        if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", ht=
tpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-    =
        fprintf(clnt_w,=0A-                "HTTP/1.0 501 Not Implemented\r\=
n\r\n"=0A-                "<html><body><h1>501 Not Implemented</h1></body><=
/html>");=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-=
            continue;=0A-        }=0A         =0A-        // If URI doesn't=
 start with '/' or there exists '..' in the URI=0A-        if (strncmp("/",=
 requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A-       =
     fprintf(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\r\n\r\n"=
=0A-                "<html><body><h1>400 Bad Request</h1></body></html>");=
=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-         =
   continue;=0A-        }=0A-        =0A-        // If URI ends with '/', a=
ppend "index.html" to the URI =0A-        if (strlen(requestURI) > 0 && *(r=
equestURI + strlen(requestURI) - 1)  =3D=3D '/'){=0A-            strcat(req=
uestURI, "index.html");=0A-        }=0A-        /*=0A-        * Read from t=
he file, and write out to file_name.=0A-        */=0A-        =0A-        c=
har filename[1000] =3D {0};=0A-        =0A-        strcpy(filename, web_roo=
t);=0A-        strcat(filename, requestURI);=0A-=0A-        printf("Filenam=
e is: %s\n", filename);=0A-=0A-        struct stat st;=0A-        if (stat(=
filename, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-            printf("Pa=
th is a directory!\n");=0A-            fprintf(clnt_w, "HTTP/1.0 301 Moved =
Permanently\r\n"=0A-                    "Location: %s/\r\n\r\n"=0A-        =
            "<html><body>\r\n"=0A-                    "<h1>301 Moved Perman=
ently</h1>\r\n"=0A-                    "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A-                    "</body></html>", requ=
estURI, requestURI);=0A-            fclose(clnt_w);=0A-            fclose(c=
lnt_r);=0A-            continue;=0A-        }=0A-=0A-        // Open up fil=
e_name for reading.=0A-        FILE *file =3D fopen(filename, "rb");=0A-   =
     if(file =3D=3D NULL){=0A-            printf("File is not found!\n");=
=0A-            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A-       =
             "<html><body><h1>404 Not Found</h1></body></html>");=0A-      =
      fclose(clnt_w);=0A-            fclose(clnt_r);=0A-            continu=
e;=0A-        }=0A-=0A-        char buf2[BUF_SIZE];=0A-       =0A-        /=
/ Switch to fread()/fwrite() so that we can download binary files.=0A-=0A- =
       fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=0A-=0A-        size_t n;=
=0A-        while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A-   =
         if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A-                fprint=
f(stderr, "Encountered error writing to client\n");=0A-                exit=
(1);=0A-            }=0A-        }=0A-=0A-        /*=0A-        * All done,=
 clean up.=0A-        */=0A-=0A-        // fread() returns 0 on EOF or on e=
rror, so we need to check for errors.=0A-        if (ferror(file)) {=0A-   =
         fprintf(stderr, "Encountered error reading from file.\n");=0A-    =
        exit(1);=0A-        }=0A-=0A-    =0A-=0A-        // Close FILE * fo=
r output file.=0A-        if (fclose(file))=0A-            die("close");=0A=
-=0A-        /*        =0A-         * Handle client connection.=0A-        =
=0A-=0A-        // Keep track of how many bytes we've received.=0A-        =
size_t recv_len =3D 0;=0A-=0A-        int len;=0A-        char buf[32];=0A-=
=0A-        // recv() is like read(), except there's an extra flags argumen=
t.=0A-        //=0A-        // Since we didn't pass any flags to recv(), th=
is is equivalent to=0A-        // read(clnt_fd, buf, sizeof(buf)).=0A-     =
   if ((len =3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A-            die=
("recv");=0A-=0A-        while (len > 0) {=0A-            // Book-keeping.=
=0A-            recv_len +=3D len;=0A-=0A-            // send() is like wri=
te(), except there's an extra flags argument.=0A-            //=0A-        =
    // Since we didn't pass any flags to send(), this is equivalent to=0A- =
           // write(clnt_fd, buf, len).=0A-            if (send(clnt_fd, bu=
f, len, 0) !=3D len)=0A-                die("send");=0A-=0A-            // =
recv() might not have read everything the client sent, so we need=0A-      =
      // to continue recv()ing.=0A-            if ((len =3D recv(clnt_fd, b=
uf, sizeof(buf), 0)) < 0)=0A-                die("recv");=0A-        }=0A-=
=0A-        fprintf(stderr, "Received (and sent) %lu bytes in total\n", rec=
v_len);=0A-=0A-        */=0A-=0A-        // Close client connection.=0A-   =
     fclose(clnt_r);=0A-        fclose(clnt_w);=0A+        char *ip_address=
 =3D inet_ntoa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr=
 is now populated with information about the client.=0A+        fprintf(std=
err, "Accepted connection from %s\n",ip_address);=0A =0A-        // Resume =
server loop to handle next client connection.=0A+        handle_client(clnt=
_fd, web_root, ip_address);=0A+          =0A     }=0A =0A     /*=0A-- =0A2.=
34.1=0A=0A=0AFrom 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00=
:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 2022=
 05:53:07 -0500=0ASubject: [PATCH 07/10] I noticed a mistake. I had assumed=
 that we won't be=0A given header lines, but that's not correct. So, I gene=
ralized it. Now it can=0A handle multiple header lines.=0A=0A---=0A part1/h=
ttp-server.c | 118 ++++++++++++++++++++++++++++----------------=0A 1 file c=
hanged, 75 insertions(+), 43 deletions(-)=0A=0Adiff --git a/part1/http-serv=
er.c b/part1/http-server.c=0Aindex cf244f2..f1194ac 100644=0A--- a/part1/ht=
tp-server.c=0A+++ b/part1/http-server.c=0A@@ -11,6 +11,7 @@=0A #include <si=
gnal.h>=0A =0A #define BUF_SIZE 4096=0A+=0A static void die(const char *msg=
)=0A {=0A     perror(msg);=0A@@ -29,51 +30,88 @@ static void handle_client(=
int clnt_fd, char *web_root, char *ip_address){=0A     FILE *clnt_r =3D fdo=
pen(clnt_fd, "rb");=0A     FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A =
     =0A-    /*=0A+     /*=0A      * Receive the HTTP response.=0A      */=
=0A-        =0A+    =0A+    char *method =3D NULL;=0A+    char *requestURI =
=3D NULL;=0A+    char *httpVersion =3D NULL;    =0A+    char *token_separat=
ors =3D "\t \r\n"; // tab, space, new line=0A+   =0A     char buf[BUF_SIZE]=
;=0A =0A     // Read the first line=0A-    if (fgets(buf, sizeof(buf), clnt=
_r) =3D=3D NULL) {=0A-        fprintf(stderr, "Client connection terminated=
 prematurely.\n");=0A+    if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) =
{       =0A+        method =3D strtok(buf, token_separators);=0A+        re=
questURI =3D strtok(NULL, token_separators);=0A+        httpVersion =3D str=
tok(NULL, token_separators);=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 B=
ad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1=
></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad =
Request\n",=0A+                ip_address, method, requestURI, httpVersion)=
;=0A+=0A+        fprintf(stderr, "Client connection terminated prematurely =
by the first if.\n");=0A+        buf[0] =3D '\0';=0A         fclose(clnt_r)=
; //if(fclose(clnt_r)){die("close");}=0A         fclose(clnt_w);=0A        =
 return;=0A     }=0A =0A-    // If the initial request line is not complete=
=0A-    if(buf[strlen(buf)-1] !=3D '\n'){=0A-        fprintf(stderr, "Clien=
t connection terminated prematurely.\n");=0A+    method =3D strtok(buf, tok=
en_separators);=0A+    requestURI =3D strtok(NULL, token_separators);=0A+  =
  httpVersion =3D strtok(NULL, token_separators);=0A+    char * extra =3D s=
trtok(NULL, token_separators);=0A+=0A+    fprintf(stderr, "%s \"%s %s %s\" =
", ip_address, method, requestURI, httpVersion);=0A+=0A+=0A+  // If the ini=
tial request line is not complete or there is an extra word at the end=0A+ =
   if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NU=
LL || extra !=3D NULL){=0A+       =0A+        fprintf(clnt_w, "HTTP/1.0 400=
 Bad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</=
h1></body></html>\r\n");=0A+        fprintf(stderr, "400 Bad Request\n");=
=0A+=0A+        fprintf(stderr, "Client connection terminated prematurely b=
y the third if.\n");=0A+        buf[0] =3D 0; =0A         fclose(clnt_r);=
=0A         fclose(clnt_w);=0A         return;=0A     }=0A =0A+    char buf=
3[BUF_SIZE];=0A =0A-    char *token_separators =3D "\t \r\n"; // tab, space=
, new line=0A-    char *method =3D strtok(buf, token_separators);=0A-    ch=
ar *requestURI =3D strtok(NULL, token_separators);=0A-    char *httpVersion=
 =3D strtok(NULL, token_separators);=0A-        =0A-        //fprintf(stder=
r,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, ht=
tpVersion);=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=
=3D NULL) {       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\=
n\r\n"=0A+                	    "<html><body><h1>400 Bad Request</h1></body>=
</html>\r\n");=0A+        	fprintf(stderr, "400 Bad Request\n");=0A =0A-   =
  =0A-            =0A-    fprintf(stderr, "This is method: %s\n"=0A-       =
     "This is requestURI: %s\n"=0A-            "This is httpVersion: %s\n"=
=0A-            ,method, requestURI, httpVersion);=0A+        	fprintf(stde=
rr, "There was an issue with header lines\n");=0A+        	buf[0] =3D 0;=0A=
+        	fclose(clnt_r);=0A+        	fclose(clnt_w);=0A+        	return;=
=0A+    	}=0A+=0A+=0A+	if(strlen(buf3) <=3D 2  && buf3[strlen(buf3)-1] =3D=
=3D '\n' )=0A+ 		break;=0A+=0A+    }=0A+=0A+    //From this point on, we ca=
n assume that HTTP request has correct structure=0A   =0A =0A     // If the=
 request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A     =
if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=
=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A         fprintf(cl=
nt_w,=0A             "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-            =
"<html><body><h1>501 Not Implemented</h1></body></html>");=0A-        fprin=
tf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",=0A-                ip_a=
ddress, method, requestURI, httpVersion);=0A+            "<html><body><h1>5=
01 Not Implemented</h1></body></html>\r\n");=0A+        fprintf(stderr, "50=
1 Not Implemented\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=
=0A         fclose(clnt_w);=0A         return;=0A@@ -82,21 +120,18 @@ stati=
c void handle_client(int clnt_fd, char *web_root, char *ip_address){=0A    =
 // If URI doesn't start with '/' or there exists '..' in the URI=0A     if=
 (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL =
) {=0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-      =
          "<html><body><h1>400 Bad Request</h1></body></html>");=0A-       =
 fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip=
_address, method, requestURI, httpVersion);=0A+                "<html><body=
><h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "=
400 Bad Request\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=0A=
         fclose(clnt_w);=0A         return;=0A     }=0A         =0A        =
 // If URI ends with /, append index.html=0A-    if (strlen(requestURI) > 0=
 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/'){=0A-            =
=0A-        fprintf(stderr, "This is after appending: %s\n",requestURI);=0A=
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);=0A+    =
if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=
=3D '/')         =0A         strcat(requestURI, "index.html");=0A-    }=0A+=
  =0A         =0A         /*=0A         * Read from the file, and write out=
 to file_name.=0A@@ -106,38 +141,34 @@ static void handle_client(int clnt_f=
d, char *web_root, char *ip_address){=0A         =0A     strcat(web_root, r=
equestURI);=0A =0A-    fprintf(stderr, "Filename is: %s\n", web_root);=0A+ =
   // fprintf(stderr, "Filename is: %s\n", web_root);=0A =0A     struct sta=
t st;=0A     if (stat(web_root, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-=
        printf("Path is a directory!\n");=0A         fprintf(clnt_w, "HTTP/=
1.0 301 Moved Permanently\r\n"=0A                 "Location: %s/\r\n\r\n"=
=0A                 "<html><body>\r\n"=0A                 "<h1>301 Moved Pe=
rmanently</h1>\r\n"=0A                 "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A-                "</body></html>", requestU=
RI, requestURI);=0A-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Perm=
anently\n",=0A-                ip_address, method, requestURI, httpVersion)=
;=0A+                "</body></html>\r\n", requestURI, requestURI);=0A+    =
    fprintf(stderr, "301 Moved Permanently\n");=0A         fclose(clnt_w);=
=0A         fclose(clnt_r);=0A         *(web_root + strlen(web_root) - strl=
en(requestURI)) =3D '\0';=0A+        buf[0] =3D 0;=0A         return; =0A  =
   }=0A =0A     // Open up file_name for reading.=0A     FILE *file =3D fop=
en(web_root, "rb");=0A     if(file =3D=3D NULL){=0A-        fprintf(stderr,=
 "File is not found!\n");=0A         fprintf(clnt_w, "HTTP/1.0 404 Not Foun=
d\r\n\r\n"=0A-                "<html><body><h1>404 Not Found</h1></body></h=
tml>");=0A-        fprintf(stderr, "This is URI: %s\n", requestURI);=0A-   =
     fprintf(stderr, "This is httpVersion: %s\n", httpVersion);=0A-        =
fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",=0A-                ip_ad=
dress, method, requestURI, httpVersion);=0A+                "<html><body><h=
1>404 Not Found</h1></body></html>\r\n");=0A+        fprintf(stderr, "404 N=
ot Found\n");=0A         fclose(clnt_w);=0A         fclose(clnt_r);=0A     =
    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+      =
  buf[0] =3D 0;=0A         return;=0A     }=0A =0A@@ -149,8 +180,7 @@ stati=
c void handle_client(int clnt_fd, char *web_root, char *ip_address){=0A    =
 // Use fread()/fwrite() so that we can upload binary files.=0A =0A     fpr=
intf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=0A-    fprintf(stderr, "%s \"%s %s=
 %s\" 200 OK\n",=0A-            ip_address, method, requestURI, httpVersion=
);=0A+    fprintf(stderr, "200 OK\n");=0A     size_t n;=0A     while ((n =
=3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A         if (fwrite(buf2, =
1, n, clnt_w) !=3D n) {=0A@@ -163,6 +193,8 @@ static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A     * All done, clean up.=
=0A     */=0A =0A+    buf[0] =3D 0;=0A+=0A     // fread() returns 0 on EOF =
or on error, so we need to check for errors.=0A     if (ferror(file)) {=0A =
        fprintf(stderr, "Encountered error reading from file.\n");=0A-- =0A=
2.34.1=0A=0A=0AFrom 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:=
00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 20=
22 18:26:54 -0500=0ASubject: [PATCH 08/10] Wrote part2, but will probably n=
eed some changes.=0A=0A---=0A part1/http-server.c       |  96 ++++++-----=
=0A part2/Makefile            |  16 ++=0A part2/multi-http-server.c | 354 +=
+++++++++++++++++++++++++++++++++++++=0A 3 files changed, 423 insertions(+)=
, 43 deletions(-)=0A create mode 100644 part2/Makefile=0A create mode 10064=
4 part2/multi-http-server.c=0A=0Adiff --git a/part1/http-server.c b/part1/h=
ttp-server.c=0Aindex f1194ac..3e500eb 100644=0A--- a/part1/http-server.c=0A=
+++ b/part1/http-server.c=0A@@ -41,7 +41,8 @@ static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A    =0A     char buf[BUF_SIZ=
E];=0A =0A-    // Read the first line=0A+    // Read the first line CHECK I=
F IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTER THIS=0A  =
   if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A         met=
hod =3D strtok(buf, token_separators);=0A         requestURI =3D strtok(NUL=
L, token_separators);=0A@@ -64,15 +65,14 @@ static void handle_client(int c=
lnt_fd, char *web_root, char *ip_address){=0A     httpVersion =3D strtok(NU=
LL, token_separators);=0A     char * extra =3D strtok(NULL, token_separator=
s);=0A =0A-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requ=
estURI, httpVersion);=0A-=0A =0A-  // If the initial request line is not co=
mplete or there is an extra word at the end=0A+    // If the initial reques=
t line is not complete or there is an extra word at the end=0A     if(metho=
d =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL || extra=
 !=3D NULL){=0A        =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Reques=
t\r\n\r\n"=0A                 "<html><body><h1>400 Bad Request</h1></body><=
/html>\r\n");=0A-        fprintf(stderr, "400 Bad Request\n");=0A+        f=
printf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_a=
ddress, method, requestURI, httpVersion);=0A =0A         fprintf(stderr, "C=
lient connection terminated prematurely by the third if.\n");=0A         bu=
f[0] =3D 0; =0A@@ -81,13 +81,39 @@ static void handle_client(int clnt_fd, c=
har *web_root, char *ip_address){=0A         return;=0A     }=0A =0A+    //=
 If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=
=0A+    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersio=
n) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+        fpri=
ntf(clnt_w,=0A+            "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+      =
      "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");=0A+   =
     fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",=0A+          =
     ip_address, method, requestURI, httpVersion);=0A+        buf[0] =3D 0;=
=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        return;=
=0A+    }=0A+        =0A+    // If URI doesn't start with '/' or there exis=
ts '..' in the URI=0A+    if (strncmp("/", requestURI, 1) !=3D 0 || strstr(=
requestURI, "/..") !=3D NULL ) {=0A+        fprintf(clnt_w, "HTTP/1.0 400 B=
ad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1=
></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad =
Request\n",=0A+                ip_address, method, requestURI, httpVersion)=
;=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(cln=
t_w);=0A+        return;=0A+    }=0A+=0A     char buf3[BUF_SIZE];=0A =0A   =
  while(1){=0A 	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {      =
 =0A        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A        =
         	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A=
-        	fprintf(stderr, "400 Bad Request\n");=0A+        	fprintf(stderr,=
 "%s \"%s %s %s\" 400 Bad Request\n",=0A+                        ip_address=
, method, requestURI, httpVersion);=0A =0A         	fprintf(stderr, "There =
was an issue with header lines\n");=0A         	buf[0] =3D 0;=0A@@ -104,31 =
+130,10 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_=
address){=0A =0A     //From this point on, we can assume that HTTP request =
has correct structure=0A   =0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_a=
ddress, method, requestURI, httpVersion);=0A+    buf[0] =3D 0;=0A =0A-    /=
/ If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=
=0A-    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersio=
n) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-        fpri=
ntf(clnt_w,=0A-            "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-      =
      "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");=0A-   =
     fprintf(stderr, "501 Not Implemented\n");=0A-        buf[0] =3D 0;=0A-=
        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-        return;=0A-  =
  }=0A-        =0A-    // If URI doesn't start with '/' or there exists '..=
' in the URI=0A-    if (strncmp("/", requestURI, 1) !=3D 0 || strstr(reques=
tURI, "..") !=3D NULL ) {=0A-        fprintf(clnt_w, "HTTP/1.0 400 Bad Requ=
est\r\n\r\n"=0A-                "<html><body><h1>400 Bad Request</h1></body=
></html>\r\n");=0A-        fprintf(stderr, "400 Bad Request\n");=0A-       =
 buf[0] =3D 0;=0A-        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-   =
     return;=0A-    }=0A-        =0A-        // If URI ends with /, append =
index.html=0A+    // If URI ends with /, append index.html=0A     if (strle=
n(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/') =
        =0A         strcat(requestURI, "index.html");=0A   =0A@@ -155,7 +16=
0,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_addr=
ess){=0A         fclose(clnt_w);=0A         fclose(clnt_r);=0A         *(we=
b_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A-        buf[0]=
 =3D 0;=0A         return; =0A     }=0A =0A@@ -168,7 +172,6 @@ static void =
handle_client(int clnt_fd, char *web_root, char *ip_address){=0A         fc=
lose(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root + strlen(web=
_root) - strlen(requestURI)) =3D '\0';=0A-        buf[0] =3D 0;=0A         =
return;=0A     }=0A =0A@@ -179,28 +182,35 @@ static void handle_client(int =
clnt_fd, char *web_root, char *ip_address){=0A        =0A     // Use fread(=
)/fwrite() so that we can upload binary files.=0A =0A+=0A     fprintf(clnt_=
w, "HTTP/1.0 200 OK\r\n\r\n");=0A     fprintf(stderr, "200 OK\n");=0A     s=
ize_t n;=0A-    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A=
+    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(fil=
e)) ) {=0A         if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A-            =
fprintf(stderr, "Encountered error while writing to client\n");=0A-        =
    exit(1);=0A+            // Don't crash the server and move to the next =
client.=0A+            fclose(clnt_w);=0A+            fclose(clnt_r);=0A+  =
          perror("send bytes to client");=0A+            return;=0A        =
 }=0A     }=0A =0A-    /*=0A-    * All done, clean up.=0A-    */=0A-=0A-   =
 buf[0] =3D 0;=0A =0A     // fread() returns 0 on EOF or on error, so we ne=
ed to check for errors.=0A     if (ferror(file)) {=0A-        fprintf(stder=
r, "Encountered error reading from file.\n");=0A-        exit(1);=0A+      =
  // Don't crash the server and move to the next client.=0A+        fclose(=
clnt_w);=0A+        fclose(clnt_r);=0A+        perror("read from the file r=
equested");=0A+        return;=0A     } =0A =0A+=0A+    /*=0A+    * All don=
e, clean up.=0A+    */=0A+=0A     // Close FILE * for output file.=0A     i=
f (fclose(file))=0A         die("close");       =0A@@ -297,7 +307,7 @@ int =
main(int argc, char **argv)=0A         char *ip_address =3D inet_ntoa(clnt_=
addr.sin_addr);=0A             =0A         // clnt_addr is now populated wi=
th information about the client.=0A-        fprintf(stderr, "Accepted conne=
ction from %s\n",ip_address);=0A+        //fprintf(stderr, "Accepted connec=
tion from %s\n",ip_address);=0A =0A         handle_client(clnt_fd, web_root=
, ip_address);=0A           =0Adiff --git a/part2/Makefile b/part2/Makefile=
=0Anew file mode 100644=0Aindex 0000000..9be1e81=0A--- /dev/null=0A+++ b/pa=
rt2/Makefile=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpeda=
ntic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+defa=
ult: multi-http-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=
=0A+	rm -rf a.out *.o multi-http-server=0A+=0A+.PHONY: all=0A+all: clean mu=
lti-http-server=0Adiff --git a/part2/multi-http-server.c b/part2/multi-http=
-server.c=0Anew file mode 100644=0Aindex 0000000..929e9f7=0A--- /dev/null=
=0A+++ b/part2/multi-http-server.c=0A@@ -0,0 +1,354 @@=0A+#define _GNU_SOUR=
CE=0A+#include <arpa/inet.h>=0A+#include <netdb.h>=0A+#include <stdio.h>=0A=
+#include <stdlib.h>=0A+#include <string.h>=0A+#include <sys/socket.h>=0A+#=
include <sys/types.h>=0A+#include <sys/stat.h>=0A+#include <unistd.h>=0A+#i=
nclude <signal.h>=0A+#include <sys/wait.h>=0A+=0A+#define BUF_SIZE 4096=0A+=
=0A+static void die(const char *msg)=0A+{=0A+    perror(msg);=0A+    exit(1=
);=0A+}=0A+=0A+static void usage_and_exit(char *argv0)=0A+{=0A+    fprintf(=
stderr, "usage: %s <server-port> <web-root>\n", argv0);=0A+    fprintf(stde=
rr, "   ex) %s 8888 ~/html\n", argv0);=0A+    exit(1);=0A+}=0A+=0A+void rea=
p_children(int sig){=0A+    while (waitpid(-1, NULL, WNOHANG) > 0)=0A+     =
   ;=0A+}=0A+=0A+static void handle_client(int clnt_fd, char *web_root, cha=
r *ip_address, pid_t pid){=0A+        =0A+    FILE *clnt_r =3D fdopen(clnt_=
fd, "rb");=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A+     =0A+=
     /*=0A+     * Receive the HTTP response.=0A+     */=0A+    =0A+    char=
 *method =3D NULL;=0A+    char *requestURI =3D NULL;=0A+    char *httpVersi=
on =3D NULL;    =0A+    char *token_separators =3D "\t \r\n"; // tab, space=
, new line=0A+   =0A+    char buf[BUF_SIZE];=0A+=0A+    // Read the first l=
ine CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTE=
R THIS=0A+    if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A+=
        method =3D strtok(buf, token_separators);=0A+        requestURI =3D=
 strtok(NULL, token_separators);=0A+        httpVersion =3D strtok(NULL, to=
ken_separators);=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r=
\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1></body></ht=
ml>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=
=0A+                ip_address, method, requestURI, httpVersion);=0A+=0A+  =
      fprintf(stderr, "Client connection terminated prematurely by the firs=
t if.\n");=0A+        buf[0] =3D '\0';=0A+        fclose(clnt_r); //if(fclo=
se(clnt_r)){die("close");}=0A+        fclose(clnt_w);=0A+        return;=0A=
+    }=0A+=0A+    method =3D strtok(buf, token_separators);=0A+    requestU=
RI =3D strtok(NULL, token_separators);=0A+    httpVersion =3D strtok(NULL, =
token_separators);=0A+    char * extra =3D strtok(NULL, token_separators);=
=0A+=0A+=0A+    // If the initial request line is not complete or there is =
an extra word at the end=0A+    if(method =3D=3D NULL || requestURI =3D=3D =
NULL || httpVersion =3D=3D NULL || extra !=3D NULL){=0A+       =0A+        =
fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<htm=
l><body><h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(st=
derr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, m=
ethod, requestURI, httpVersion);=0A+=0A+        fprintf(stderr, "Client con=
nection terminated prematurely by the third if.\n");=0A+        buf[0] =3D =
0; =0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        return=
;=0A+    }=0A+=0A+    // If the request is not GET or the HTTP version is n=
ot HTTP/1.0 or HTTP/1.1=0A+    if (strcmp("GET", method) !=3D 0 || !(strcmp=
("HTTP/1.0", httpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=
=3D 0)) {=0A+        fprintf(clnt_w,=0A+            "HTTP/1.0 501 Not Imple=
mented\r\n\r\n"=0A+            "<html><body><h1>501 Not Implemented</h1></b=
ody></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Impl=
emented\n",=0A+               ip_address, method, requestURI, httpVersion);=
=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(clnt=
_w);=0A+        return;=0A+    }=0A+        =0A+    // If URI doesn't start=
 with '/' or there exists '..' in the URI=0A+    if (strncmp("/", requestUR=
I, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL ) {=0A+        fprintf(=
clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><body>=
<h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "%=
s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, method, r=
equestURI, httpVersion);=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r)=
;=0A+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A+    char bu=
f3[BUF_SIZE];=0A+=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_=
r) =3D=3D NULL) {       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Requ=
est\r\n\r\n"=0A+                	    "<html><body><h1>400 Bad Request</h1><=
/body></html>\r\n");=0A+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad R=
equest\n",=0A+                        ip_address, method, requestURI, httpV=
ersion);=0A+=0A+        	fprintf(stderr, "There was an issue with header li=
nes\n");=0A+        	buf[0] =3D 0;=0A+        	fclose(clnt_r);=0A+        	=
fclose(clnt_w);=0A+        	return;=0A+    	}=0A+=0A+=0A+	if(strlen(buf3) <=
=3D 2  && buf3[strlen(buf3)-1] =3D=3D '\n' )=0A+ 		break;=0A+=0A+    }=0A+=
=0A+    //From this point on, we can assume that HTTP request has correct s=
tructure=0A+  =0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, metho=
d, requestURI, httpVersion);=0A+    buf[0] =3D 0;=0A+=0A+    // If URI ends=
 with /, append index.html=0A+    if (strlen(requestURI) > 0 && (*(requestU=
RI + strlen(requestURI) - 1))  =3D=3D '/')         =0A+        strcat(reque=
stURI, "index.html");=0A+  =0A+        =0A+        /*=0A+        * Read fro=
m the file, and write out to file_name.=0A+        */=0A+        =0A+      =
  // char *filename; [strlen(web_root + strlen(requestURI)) + 1];=0A+      =
  =0A+    strcat(web_root, requestURI);=0A+=0A+    // fprintf(stderr, "File=
name is: %s\n", web_root);=0A+=0A+    struct stat st;=0A+    if (stat(web_r=
oot, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+        fprintf(clnt_w, "HT=
TP/1.0 301 Moved Permanently\r\n"=0A+                "Location: %s/\r\n\r\n=
"=0A+                "<html><body>\r\n"=0A+                "<h1>301 Moved P=
ermanently</h1>\r\n"=0A+                "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A+                "</body></html>\r\n", requ=
estURI, requestURI);=0A+        fprintf(stderr, "301 Moved Permanently\n");=
=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *(web_roo=
t + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        return; =0A=
+    }=0A+=0A+    // Open up file_name for reading.=0A+    FILE *file =3D f=
open(web_root, "rb");=0A+    if(file =3D=3D NULL){=0A+        fprintf(clnt_=
w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>404=
 Not Found</h1></body></html>\r\n");=0A+        fprintf(stderr, "404 Not Fo=
und\n");=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *=
(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        ret=
urn;=0A+    }=0A+=0A+    // Bring back web_root to its original content=0A+=
    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+     =
   =0A+    char buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() s=
o that we can upload binary files.=0A+=0A+=0A+    fprintf(clnt_w, "HTTP/1.0=
 200 OK\r\n\r\n");=0A+    fprintf(stderr, "200 OK\n");=0A+    size_t n;=0A+=
    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file=
)) ) {=0A+        if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A+            /=
/ Don't crash the server and move to the next client.=0A+            fclose=
(clnt_w);=0A+            fclose(clnt_r);=0A+            perror("send bytes =
to client");=0A+            return;=0A+        }=0A+    }=0A+=0A+=0A+    //=
 fread() returns 0 on EOF or on error, so we need to check for errors.=0A+ =
   if (ferror(file)) {=0A+        // Don't crash the server and move to the=
 next client.=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+    =
    perror("read from the file requested");=0A+        return;=0A+    } =0A=
+=0A+=0A+    /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    // Close =
FILE * for output file.=0A+    if (fclose(file))=0A+        die("close");  =
     =0A+=0A+    // Close client connection.=0A+    fclose(clnt_r);=0A+    =
fclose(clnt_w);=0A+=0A+    // Resume server loop to handle next client conn=
ection.=0A+    return;=0A+}=0A+=0A+=0A+=0A+int main(int argc, char **argv)=
=0A+{=0A+=0A+    struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));   =
      // Zero-initialize sigaction structure=0A+    sigemptyset(&sa.sa_mask=
);           // Don't mask any signals=0A+    sa.sa_handler =3D SIG_IGN;   =
         // Ignore the signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=
=0A+        die("sigaction");=0A+=0A+    /*=0A+     * Parse arguments and d=
etermine output file name.=0A+     */=0A+=0A+    if (argc !=3D 3)=0A+      =
  usage_and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv[1];=0A+   =
 char *web_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtain socket addr=
ess structure from server name and port number.=0A+     */=0A+=0A+    struc=
t addrinfo hints, *info;=0A+    memset(&hints, 0, sizeof(hints));=0A+=0A+  =
  hints.ai_family =3D AF_INET;       // Only accept IPv4 addresses=0A+    h=
ints.ai_socktype =3D SOCK_STREAM; // Stream socket for TCP connections=0A+ =
   hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints.ai_flags=
 =3D AI_PASSIVE;     // Construct socket address for bind()ing=0A+=0A+    i=
nt aerr;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &hints, &info)=
) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(ae=
rr));=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Create a socket(=
), bind() it to the server, and wrap in FILE *s.=0A+     */=0A+=0A+    int =
serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=
=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    if (bind(serv=
_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+   =
=0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for connections=
 on this socket, maintaining a queue of=0A+    // at most 8 pending connect=
ions.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=0A+=
=0A+     /*=0A+     * Server loop runs forever (writing "for (;;)" is the s=
ame as "while(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=0A+      =
   * accept() connection from client.=0A+         */=0A+=0A+        // Defi=
ne space to receive client address info.=0A+        struct sockaddr_in clnt=
_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+   =
     // accept() blocks until a client connects with the server, and return=
s=0A+        // a NEW socket file descriptor for interacting with the clien=
t.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &clnt_add=
r,=0A+                             &clnt_addr_len);=0A+        if (clnt_fd =
< 0)=0A+            die("accept");=0A+        =0A+        char *ip_address =
=3D inet_ntoa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr =
is now populated with information about the client.=0A+        //fprintf(st=
derr, "Accepted connection from %s\n",ip_address);=0A+=0A+        pid_t pid=
 =3D fork();=0A+=0A+        // Both the parent and child will resume execut=
ion here.=0A+        if (pid =3D=3D 0){=0A+            =0A+            // C=
hild process=0A+            close(serv_fd);=0A+            handle_client(cl=
nt_fd, web_root, ip_address, getpid());=0A+            exit(0);=0A+=0A+    =
    }else{=0A+            =0A+            close(clnt_fd);=0A+            //=
 Parent process=0A+            struct sigaction sa2;=0A+            memset(=
&sa2, 0, sizeof(sa2));         // Zero-initialize sigaction structure=0A+  =
          sigemptyset(&sa2.sa_mask);           // Don't mask any signals=0A=
+            sa.sa_flags =3D SA_RESTART;             // Restart interrupted=
 system calls=0A+            sa.sa_handler =3D &reap_children;      // Reap=
 children upon receiving signal=0A+=0A+            if (sigaction(SIGCHLD, &=
sa, NULL))=0A+                die("sigaction");=0A+        }=0A+         =
=0A+    }=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    // Theo=
retically, if we want our server to handle graceful termination, we=0A+    =
// should also close() the server socket here too:=0A+    close(serv_fd);=
=0A+=0A+    return 0;=0A+}=0A+=0A-- =0A2.34.1=0A=0A=0AFrom 5161264295a97a29=
0b1442fd240cde6ea9372bcc Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao27=
94@columbia.edu>=0ADate: Wed, 30 Nov 2022 18:28:11 -0500=0ASubject: [PATCH =
09/10] Made a change to README.=0A=0A---=0A README.txt | 8 ++++----=0A 1 fi=
le changed, 4 insertions(+), 4 deletions(-)=0A=0Adiff --git a/README.txt b/=
README.txt=0Aindex 49c4472..b6c6f1c 100644=0A--- a/README.txt=0A+++ b/READM=
E.txt=0A@@ -1,9 +1,9 @@=0A This file should contain:=0A =0A-  - your name=
=0A-  - your UNI=0A-  - lab assignment number=0A-  - description for each p=
art=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab6=0A+  - It should work!=0A =
=0A The description should indicate whether your solution for the part is=
=0A working or not.  You may also want to include anything else you would=
=0A-- =0A2.34.1=0A=0A=0AFrom ad8500bd591cd6d51ecbe9b7ce004e6faa945c01 Mon S=
ep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, =
30 Nov 2022 23:55:45 -0500=0ASubject: [PATCH 10/10] Final commit.=0A=0A---=
=0A README.txt                | 72 ++++++++++++++++++++++++++++++++-=0A par=
t1/http-server.c       | 53 ++++++++----------------=0A part2/multi-http-se=
rver.c | 85 ++++++++++++++++-----------------------=0A 3 files changed, 122=
 insertions(+), 88 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=
=0Aindex b6c6f1c..e0816e8 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@=
 -3,9 +3,79 @@ This file should contain:=0A   - Arman Ozcan=0A   - ao2794=
=0A   - lab6=0A-  - It should work!=0A+  - It should work! And I set up my =
web page.=0A =0A The description should indicate whether your solution for =
the part is=0A working or not.  You may also want to include anything else =
you would=0A like to communicate to the grader such as extra functionalitie=
s you=0A implemented or how you tried to fix your non-working code.=0A+=3D=
=3D68827=3D=3D Memcheck, a memory error detector=0A+=3D=3D68827=3D=3D Copyr=
ight (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D68827=
=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info=
=0A+=3D=3D68827=3D=3D Command: ./http-server 10125 /mnt/disks/students229/a=
o2794/html=0A+=3D=3D68827=3D=3D =0A+34.145.159.110 "GET /cs3157/ HTTP/1.0" =
200 OK=0A+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented=0A+34.=
145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented=0A+34.145.159.110 "=
GET /cs3157 HTTP/1.1" 301 Moved Permanently=0A+=3D=3D68827=3D=3D =0A+=3D=3D=
68827=3D=3D Process terminating with default action of signal 2 (SIGINT)=0A=
+=3D=3D68827=3D=3D    at 0x498A5D7: accept (accept.c:26)=0A+=3D=3D68827=3D=
=3D    by 0x10A1AF: main (http-server.c:283)=0A+=3D=3D68827=3D=3D =0A+=3D=
=3D68827=3D=3D HEAP SUMMARY:=0A+=3D=3D68827=3D=3D     in use at exit: 0 byt=
es in 0 blocks=0A+=3D=3D68827=3D=3D   total heap usage: 19 allocs, 19 frees=
, 37,592 bytes allocated=0A+=3D=3D68827=3D=3D =0A+=3D=3D68827=3D=3D All hea=
p blocks were freed -- no leaks are possible=0A+=3D=3D68827=3D=3D =0A+=3D=
=3D68827=3D=3D For lists of detected and suppressed errors, rerun with: -s=
=0A+=3D=3D68827=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: =
0 from 0)=0A+=3D=3D115292=3D=3D Memcheck, a memory error detector=0A+=3D=3D=
115292=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al=
=2E=0A+=3D=3D115292=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h f=
or copyright info=0A+=3D=3D115292=3D=3D Command: ./multi-http-server 10129 =
/mnt/disks/students229/ao2794/html=0A+=3D=3D115292=3D=3D =0A+34.145.159.110=
 (116118) "GET /cs3157/photos.jpg HTTP/1.1" 404 Not Found=0A+=3D=3D116118=
=3D=3D =0A+=3D=3D116118=3D=3D HEAP SUMMARY:=0A+=3D=3D116118=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D116118=3D=3D   total heap usage: 6 =
allocs, 6 frees, 9,672 bytes allocated=0A+=3D=3D116118=3D=3D =0A+=3D=3D1161=
18=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D11611=
8=3D=3D =0A+=3D=3D116118=3D=3D For lists of detected and suppressed errors,=
 rerun with: -s=0A+=3D=3D116118=3D=3D ERROR SUMMARY: 0 errors from 0 contex=
ts (suppressed: 0 from 0)=0A+34.145.159.110 (117352) "GET /cs3157/images/ph=
otos.jpg HTTP/1.1" 404 Not Found=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=3D=
=3D HEAP SUMMARY:=0A+=3D=3D117352=3D=3D     in use at exit: 0 bytes in 0 bl=
ocks=0A+=3D=3D117352=3D=3D   total heap usage: 6 allocs, 6 frees, 9,672 byt=
es allocated=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=3D=3D All heap blocks w=
ere freed -- no leaks are possible=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=
=3D=3D For lists of detected and suppressed errors, rerun with: -s=0A+=3D=
=3D117352=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from=
 0)=0A+34.145.159.110 (117760) "GET /cs3157/images/photo.jpg HTTP/1.1" 200 =
OK=0A+=3D=3D117760=3D=3D =0A+=3D=3D117760=3D=3D HEAP SUMMARY:=0A+=3D=3D1177=
60=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D117760=3D=3D   to=
tal heap usage: 7 allocs, 7 frees, 17,864 bytes allocated=0A+=3D=3D117760=
=3D=3D =0A+=3D=3D117760=3D=3D All heap blocks were freed -- no leaks are po=
ssible=0A+=3D=3D117760=3D=3D =0A+=3D=3D117760=3D=3D For lists of detected a=
nd suppressed errors, rerun with: -s=0A+=3D=3D117760=3D=3D ERROR SUMMARY: 0=
 errors from 0 contexts (suppressed: 0 from 0)=0A+=3D=3D115292=3D=3D =0A+=
=3D=3D115292=3D=3D Process terminating with default action of signal 2 (SIG=
INT)=0A+=3D=3D115292=3D=3D    at 0x498A5D7: accept (accept.c:26)=0A+=3D=3D1=
15292=3D=3D    by 0x10A2A7: main (multi-http-server.c:291)=0A+=3D=3D115292=
=3D=3D =0A+=3D=3D115292=3D=3D HEAP SUMMARY:=0A+=3D=3D115292=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D115292=3D=3D   total heap usage: 1 =
allocs, 1 frees, 64 bytes allocated=0A+=3D=3D115292=3D=3D =0A+=3D=3D115292=
=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D115292=
=3D=3D =0A+=3D=3D115292=3D=3D For lists of detected and suppressed errors, =
rerun with: -s=0A+=3D=3D115292=3D=3D ERROR SUMMARY: 0 errors from 0 context=
s (suppressed: 0 from 0)=0Adiff --git a/part1/http-server.c b/part1/http-se=
rver.c=0Aindex 3e500eb..5923fd2 100644=0A--- a/part1/http-server.c=0A+++ b/=
part1/http-server.c=0A@@ -41,8 +41,7 @@ static void handle_client(int clnt_=
fd, char *web_root, char *ip_address){=0A    =0A     char buf[BUF_SIZE];=0A=
 =0A-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE ST=
RUCTURE=0A-    // CHECK AFTER THIS=0A+    // Reads the initial request line=
=2E=0A     if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A    =
     method =3D strtok(buf, token_separators);=0A         requestURI =3D st=
rtok(NULL, token_separators);=0A@@ -53,9 +52,8 @@ static void handle_client=
(int clnt_fd, char *web_root, char *ip_address){=0A         fprintf(stderr,=
 "%s \"%s %s %s\" 400 Bad Request\n",=0A                 ip_address, method=
, requestURI, httpVersion);=0A =0A-        fprintf(stderr, "Client connecti=
on terminated prematurely by the first if.\n");=0A-        buf[0] =3D '\0';=
=0A-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}=0A+        =
buf[0] =3D 0;=0A+        fclose(clnt_r);=0A         fclose(clnt_w);=0A     =
    return;=0A     }=0A@@ -67,14 +65,14 @@ static void handle_client(int cl=
nt_fd, char *web_root, char *ip_address){=0A =0A =0A     // If the initial =
request line is not complete or there is an extra word at the end=0A-    if=
(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL ||=
 extra !=3D NULL){=0A+    // Or the URI doesn't start with '/' or there exi=
sts =0A+    if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =
=3D=3D NULL || extra !=3D NULL || strncmp("/", requestURI, 1) !=3D 0 || str=
str(requestURI, "/../") !=3D NULL  || ( (strlen(requestURI) >=3D 3) && *(re=
questURI + strlen(requestURI) - 1) =3D=3D '.' && *(requestURI + strlen(requ=
estURI) - 2) =3D=3D '.' && *(requestURI + strlen(requestURI) - 3) =3D=3D '/=
') ){=0A        =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r=
\n"=0A                 "<html><body><h1>400 Bad Request</h1></body></html>\=
r\n");=0A         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A  =
               ip_address, method, requestURI, httpVersion);=0A =0A-       =
 fprintf(stderr, "Client connection terminated prematurely by the third if.=
\n");=0A         buf[0] =3D 0; =0A         fclose(clnt_r);=0A         fclos=
e(clnt_w);=0A@@ -88,41 +86,28 @@ static void handle_client(int clnt_fd, cha=
r *web_root, char *ip_address){=0A             "<html><body><h1>501 Not Imp=
lemented</h1></body></html>\r\n");=0A         fprintf(stderr, "%s \"%s %s %=
s\" 501 Not Implemented\n",=0A                ip_address, method, requestUR=
I, httpVersion);=0A+    =0A         buf[0] =3D 0;=0A         fclose(clnt_r)=
;=0A         fclose(clnt_w);=0A         return;=0A     }=0A         =0A-   =
 // If URI doesn't start with '/' or there exists '..' in the URI=0A-    if=
 (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL=
 ) {=0A-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-     =
           "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-  =
      fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-             =
   ip_address, method, requestURI, httpVersion);=0A-        buf[0] =3D 0;=
=0A-        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-        return;=
=0A-    }=0A-=0A     char buf3[BUF_SIZE];=0A-=0A+    =0A     while(1){=0A 	=
 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {       =0A        		fp=
rintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A                 	    "<=
html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A         	fprint=
f(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A                         i=
p_address, method, requestURI, httpVersion);=0A-=0A-        	fprintf(stderr=
, "There was an issue with header lines\n");=0A-        	buf[0] =3D 0;=0A+ =
=0A+                buf[0] =3D 0;=0A         	fclose(clnt_r);=0A         	f=
close(clnt_w);=0A         	return;=0A     	}=0A =0A-=0A 	if(strlen(buf3) <=
=3D 2  && buf3[strlen(buf3)-1] =3D=3D '\n' )=0A  		break;=0A =0A@@ -135,19 =
+120,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_=
address){=0A =0A     // If URI ends with /, append index.html=0A     if (st=
rlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/=
')         =0A-        strcat(requestURI, "index.html");=0A-  =0A-        =
=0A-        /*=0A-        * Read from the file, and write out to file_name.=
=0A-        */=0A-        =0A-        // char *filename; [strlen(web_root +=
 strlen(requestURI)) + 1];=0A+        strcat(requestURI, "index.html"); =0A=
+         =0A         =0A     strcat(web_root, requestURI);=0A =0A-    // f=
printf(stderr, "Filename is: %s\n", web_root);=0A-=0A     struct stat st;=
=0A     if (stat(web_root, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A      =
   fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=0A@@ -157,6 +134,7 =
@@ static void handle_client(int clnt_fd, char *web_root, char *ip_address)=
{=0A                 "<p>The document has moved <a href=3D\"%s/\">here</a>.=
</p>\r\n"=0A                 "</body></html>\r\n", requestURI, requestURI);=
=0A         fprintf(stderr, "301 Moved Permanently\n");=0A+       =0A      =
   fclose(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root + strle=
n(web_root) - strlen(requestURI)) =3D '\0';=0A@@ -169,6 +147,7 @@ static vo=
id handle_client(int clnt_fd, char *web_root, char *ip_address){=0A        =
 fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A                 "<html=
><body><h1>404 Not Found</h1></body></html>\r\n");=0A         fprintf(stder=
r, "404 Not Found\n");=0A+       =0A         fclose(clnt_w);=0A         fcl=
ose(clnt_r);=0A         *(web_root + strlen(web_root) - strlen(requestURI))=
 =3D '\0';=0A@@ -191,9 +170,11 @@ static void handle_client(int clnt_fd, ch=
ar *web_root, char *ip_address){=0A             // Don't crash the server a=
nd move to the next client.=0A             fclose(clnt_w);=0A             f=
close(clnt_r);=0A+            fclose(file);=0A             perror("send byt=
es to client");=0A             return;=0A         }=0A+        fflush(clnt_=
w);=0A     }=0A =0A =0A@@ -202,6 +183,7 @@ static void handle_client(int cl=
nt_fd, char *web_root, char *ip_address){=0A         // Don't crash the ser=
ver and move to the next client.=0A         fclose(clnt_w);=0A         fclo=
se(clnt_r);=0A+        fclose(file);=0A         perror("read from the file =
requested");=0A         return;=0A     } =0A@@ -212,8 +194,7 @@ static void=
 handle_client(int clnt_fd, char *web_root, char *ip_address){=0A     */=0A=
 =0A     // Close FILE * for output file.=0A-    if (fclose(file))=0A-     =
   die("close");       =0A+    fclose(file);       =0A =0A     // Close cli=
ent connection.=0A     fclose(clnt_r);=0Adiff --git a/part2/multi-http-serv=
er.c b/part2/multi-http-server.c=0Aindex 929e9f7..4eb8018 100644=0A--- a/pa=
rt2/multi-http-server.c=0A+++ b/part2/multi-http-server.c=0A@@ -31,11 +31,1=
2 @@ void reap_children(int sig){=0A         ;=0A }=0A =0A-static void hand=
le_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){=0A-   =
     =0A+static void handle_client(int clnt_fd, char *web_root, char *ip_ad=
dress){=0A+=0A     FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A     FILE *cln=
t_w =3D fdopen(dup(clnt_fd), "wb");=0A-     =0A+    int pid =3D (int) getpi=
d();=0A+=0A      /*=0A      * Receive the HTTP response.=0A      */=0A@@ -4=
7,8 +48,7 @@ static void handle_client(int clnt_fd, char *web_root, char *i=
p_address, pid_t p=0A    =0A     char buf[BUF_SIZE];=0A =0A-    // Read the=
 first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A-    // CH=
ECK AFTER THIS=0A+    // Reads the initial request line.=0A     if (fgets(b=
uf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A         method =3D strtok=
(buf, token_separators);=0A         requestURI =3D strtok(NULL, token_separ=
ators);=0A@@ -56,12 +56,11 @@ static void handle_client(int clnt_fd, char *=
web_root, char *ip_address, pid_t p=0A =0A         fprintf(clnt_w, "HTTP/1.=
0 400 Bad Request\r\n\r\n"=0A                 "<html><body><h1>400 Bad Requ=
est</h1></body></html>\r\n");=0A-        fprintf(stderr, "%s \"%s %s %s\" 4=
00 Bad Request\n",=0A-                ip_address, method, requestURI, httpV=
ersion);=0A+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n=
",=0A+                ip_address, pid, method, requestURI, httpVersion);=0A=
 =0A-        fprintf(stderr, "Client connection terminated prematurely by t=
he first if.\n");=0A-        buf[0] =3D '\0';=0A-        fclose(clnt_r); //=
if(fclose(clnt_r)){die("close");}=0A+        buf[0] =3D 0;=0A+        fclos=
e(clnt_r);=0A         fclose(clnt_w);=0A         return;=0A     }=0A@@ -73,=
14 +72,14 @@ static void handle_client(int clnt_fd, char *web_root, char *i=
p_address, pid_t p=0A =0A =0A     // If the initial request line is not com=
plete or there is an extra word at the end=0A-    if(method =3D=3D NULL || =
requestURI =3D=3D NULL || httpVersion =3D=3D NULL || extra !=3D NULL){=0A- =
      =0A+    // Or the URI doesn't start with '/' or there exists =0A+    =
if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL =
|| extra !=3D NULL || strncmp("/", requestURI, 1) !=3D 0 || strstr(requestU=
RI, "/../") !=3D NULL  || ( (strlen(requestURI) >=3D 3) && *(requestURI + s=
trlen(requestURI) - 1) =3D=3D '.' && *(requestURI + strlen(requestURI) - 2)=
 =3D=3D '.' && *(requestURI + strlen(requestURI) - 3) =3D=3D '/') ){=0A+=0A=
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A             =
    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-        f=
printf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip_a=
ddress, method, requestURI, httpVersion);=0A+        fprintf(stderr, "%s (%=
d) \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, pid, met=
hod, requestURI, httpVersion);=0A =0A-        fprintf(stderr, "Client conne=
ction terminated prematurely by the third if.\n");=0A         buf[0] =3D 0;=
 =0A         fclose(clnt_r);=0A         fclose(clnt_w);=0A@@ -92,43 +91,30 =
@@ static void handle_client(int clnt_fd, char *web_root, char *ip_address,=
 pid_t p=0A         fprintf(clnt_w,=0A             "HTTP/1.0 501 Not Implem=
ented\r\n\r\n"=0A             "<html><body><h1>501 Not Implemented</h1></bo=
dy></html>\r\n");=0A-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Imple=
mented\n",=0A-               ip_address, method, requestURI, httpVersion);=
=0A+        fprintf(stderr, "%s (%d) \"%s %s %s\" 501 Not Implemented\n",=
=0A+               ip_address, pid, method, requestURI, httpVersion);=0A+  =
  =0A         buf[0] =3D 0;=0A         fclose(clnt_r);=0A         fclose(cl=
nt_w);=0A         return;=0A     }=0A         =0A-    // If URI doesn't sta=
rt with '/' or there exists '..' in the URI=0A-    if (strncmp("/", request=
URI, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL ) {=0A-        fprint=
f(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-                "<html><bod=
y><h1>400 Bad Request</h1></body></html>\r\n");=0A-        fprintf(stderr, =
"%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip_address, method,=
 requestURI, httpVersion);=0A-        buf[0] =3D 0;=0A-        fclose(clnt_=
r);=0A-        fclose(clnt_w);=0A-        return;=0A-    }=0A-=0A     char =
buf3[BUF_SIZE];=0A-=0A+    =0A     while(1){=0A 	 if (fgets(buf3, sizeof(bu=
f3), clnt_r) =3D=3D NULL) {       =0A        		fprintf(clnt_w, "HTTP/1.0 40=
0 Bad Request\r\n\r\n"=0A                 	    "<html><body><h1>400 Bad Req=
uest</h1></body></html>\r\n");=0A-        	fprintf(stderr, "%s \"%s %s %s\"=
 400 Bad Request\n",=0A-                        ip_address, method, request=
URI, httpVersion);=0A-=0A-        	fprintf(stderr, "There was an issue with=
 header lines\n");=0A-        	buf[0] =3D 0;=0A+        	fprintf(stderr, "%=
s (%d) \"%s %s %s\" 400 Bad Request\n",=0A+                        ip_addre=
ss, pid, method, requestURI, httpVersion);=0A+ =0A+                buf[0] =
=3D 0;=0A         	fclose(clnt_r);=0A         	fclose(clnt_w);=0A         	=
return;=0A     	}=0A =0A-=0A 	if(strlen(buf3) <=3D 2  && buf3[strlen(buf3)-=
1] =3D=3D '\n' )=0A  		break;=0A =0A@@ -136,33 +122,26 @@ static void handl=
e_client(int clnt_fd, char *web_root, char *ip_address, pid_t p=0A =0A     =
//From this point on, we can assume that HTTP request has correct structure=
=0A   =0A-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, reque=
stURI, httpVersion);=0A+    fprintf(stderr, "%s (%d) \"%s %s %s\" ", ip_add=
ress, pid, method, requestURI, httpVersion);=0A     buf[0] =3D 0;=0A =0A   =
  // If URI ends with /, append index.html=0A     if (strlen(requestURI) > =
0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/')         =0A-    =
    strcat(requestURI, "index.html");=0A-  =0A-        =0A-        /*=0A-  =
      * Read from the file, and write out to file_name.=0A-        */=0A-  =
      =0A-        // char *filename; [strlen(web_root + strlen(requestURI))=
 + 1];=0A+        strcat(requestURI, "index.html"); =0A+         =0A       =
  =0A     strcat(web_root, requestURI);=0A =0A-    // fprintf(stderr, "File=
name is: %s\n", web_root);=0A-=0A     struct stat st;=0A     if (stat(web_r=
oot, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A         fprintf(clnt_w, "HT=
TP/1.0 301 Moved Permanently\r\n"=0A-                "Location: %s/\r\n\r\n=
"=0A+                "Location: %s/\r\n\r\n" =0A                 "<html><bo=
dy>\r\n"=0A                 "<h1>301 Moved Permanently</h1>\r\n"=0A        =
         "<p>The document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A=
                 "</body></html>\r\n", requestURI, requestURI);=0A         =
fprintf(stderr, "301 Moved Permanently\n");=0A+       =0A         fclose(cl=
nt_w);=0A         fclose(clnt_r);=0A         *(web_root + strlen(web_root) =
- strlen(requestURI)) =3D '\0';=0A@@ -175,6 +154,7 @@ static void handle_cl=
ient(int clnt_fd, char *web_root, char *ip_address, pid_t p=0A         fpri=
ntf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A                 "<html><bod=
y><h1>404 Not Found</h1></body></html>\r\n");=0A         fprintf(stderr, "4=
04 Not Found\n");=0A+       =0A         fclose(clnt_w);=0A         fclose(c=
lnt_r);=0A         *(web_root + strlen(web_root) - strlen(requestURI)) =3D =
'\0';=0A@@ -197,9 +177,11 @@ static void handle_client(int clnt_fd, char *w=
eb_root, char *ip_address, pid_t p=0A             // Don't crash the server=
 and move to the next client.=0A             fclose(clnt_w);=0A            =
 fclose(clnt_r);=0A+            fclose(file);=0A             perror("send b=
ytes to client");=0A             return;=0A         }=0A+        fflush(cln=
t_w);=0A     }=0A =0A =0A@@ -208,6 +190,7 @@ static void handle_client(int =
clnt_fd, char *web_root, char *ip_address, pid_t p=0A         // Don't cras=
h the server and move to the next client.=0A         fclose(clnt_w);=0A    =
     fclose(clnt_r);=0A+        fclose(file);=0A         perror("read from =
the file requested");=0A         return;=0A     } =0A@@ -218,8 +201,7 @@ st=
atic void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_=
t p=0A     */=0A =0A     // Close FILE * for output file.=0A-    if (fclose=
(file))=0A-        die("close");       =0A+    fclose(file);       =0A =0A =
    // Close client connection.=0A     fclose(clnt_r);=0A@@ -227,6 +209,7 @=
@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, =
pid_t p=0A =0A     // Resume server loop to handle next client connection.=
=0A     return;=0A+=0A }=0A =0A =0A@@ -322,7 +305,7 @@ int main(int argc, c=
har **argv)=0A             =0A             // Child process=0A             =
close(serv_fd);=0A-            handle_client(clnt_fd, web_root, ip_address,=
 getpid());=0A+            handle_client(clnt_fd, web_root, ip_address);=0A=
             exit(0);=0A =0A         }else{=0A-- =0A2.34.1=0A=0A
--AGhc5L19TJqsTzL+--

From do.not.reply@cloud.cs.columbia.edu Thu Dec  1 00:23:38 2022
Date: Thu, 1 Dec 2022 00:23:38 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab6.mbox
Message-ID: <Y4g6WZjN6rPH1zYA@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="RM7gcjQxE9obSeaN"
Content-Disposition: inline
Status: RO
Content-Length: 168259
Lines: 3458


--RM7gcjQxE9obSeaN
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 17:01:52 -0500
Subject: [PATCH 01/11] I created a Makefile and http-server.c with skeletal
 code.

---
 part1/Makefile      |  16 +++++
 part1/http-server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 165 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/http-server.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..564dbfd
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o http-server
+
+.PHONY: all
+all: clean http-server
diff --git a/part1/http-server.c b/part1/http-server.c
new file mode 100644
index 0000000..dae362f
--- /dev/null
+++ b/part1/http-server.c
@@ -0,0 +1,149 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+int main(int argc, char **argv)
+{
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    //char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        /*
+         * Handle client connection.
+         */
+
+        // Keep track of how many bytes we've received.
+        size_t recv_len = 0;
+
+        int len;
+        char buf[32];
+
+        // recv() is like read(), except there's an extra flags argument.
+        //
+        // Since we didn't pass any flags to recv(), this is equivalent to
+        // read(clnt_fd, buf, sizeof(buf)).
+        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+            die("recv");
+
+        while (len > 0) {
+            // Book-keeping.
+            recv_len += len;
+
+            // send() is like write(), except there's an extra flags argument.
+            //
+            // Since we didn't pass any flags to send(), this is equivalent to
+            // write(clnt_fd, buf, len).
+            if (send(clnt_fd, buf, len, 0) != len)
+                die("send");
+
+            // recv() might not have read everything the client sent, so we need
+            // to continue recv()ing.
+            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
+                die("recv");
+        }
+
+        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
+
+        // Close client connection.
+        close(clnt_fd);
+
+        // Resume server loop to handle next client connection.
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
-- 
2.34.1


From e0bfbf633d48c7dab909c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 21:41:13 -0500
Subject: [PATCH 02/11] Can parse the HTTP request now.

---
 part1/http-server.c | 72 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 70 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index dae362f..980293d 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#define BUF_SIZE 4096
 static void die(const char *msg)
 {
     perror(msg);
@@ -95,9 +96,73 @@ int main(int argc, char **argv)
         fprintf(stderr, "Accepted connection from %s\n",
                 inet_ntoa(clnt_addr.sin_addr));
 
+        FILE *clnt_r = fdopen(clnt_fd, "rb");
+        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+        
         /*
-         * Handle client connection.
+         * Receive the HTTP response.
          */
+        
+        char buf[BUF_SIZE];
+
+        // Read the first line
+        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+            fclose(clnt_w);
+            continue;
+        }
+
+        // If the initial request line is not complete
+        if(buf[strlen(buf)-1] != '\n'){
+            fprintf(stderr, "Client connection terminated prematurely.\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+
+
+        char *token_separators = "\t \r\n"; // tab, space, new line
+        char *method = strtok(buf, token_separators);
+        char *requestURI = strtok(NULL, token_separators);
+        char *httpVersion = strtok(NULL, token_separators);
+        
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+            fprintf(clnt_w,
+                "HTTP/1.0 501 Not Implemented\n\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        }
+        
+        // If URI doesn't start with '/' or there exists '..' in the URI
+        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+            fprintf(clnt_w,
+                "HTTP/1.0 400 Bad Request\n\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+            fclose(clnt_r);
+            fclose(clnt_w);
+            continue;
+        } 
+
+        fprintf(stderr,
+            "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+             ,method, requestURI, httpVersion);
+
+        /*        
+         * Handle client connection.
+        
 
         // Keep track of how many bytes we've received.
         size_t recv_len = 0;
@@ -131,8 +196,11 @@ int main(int argc, char **argv)
 
         fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
 
+        */
+
         // Close client connection.
-        close(clnt_fd);
+        fclose(clnt_r);
+        fclose(clnt_w);
 
         // Resume server loop to handle next client connection.
     }
-- 
2.34.1


From 5012829bc3c592d667c295a7da1bf207dc7745d1 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 26 Nov 2022 22:32:29 -0500
Subject: [PATCH 03/11] Now I can send a file back, but it just sends the same
 file now.

---
 part1/http-server.c | 37 +++++++++++++++++++++++++++++++++++--
 1 file changed, 35 insertions(+), 2 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 980293d..f4afac9 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -135,7 +135,7 @@ int main(int argc, char **argv)
   
 
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || strcmp("HTTP/1.0", httpVersion) != 0 || strcmp("HTTP/1.1", httpVersion) != 0) {
+        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
                 "HTTP/1.0 501 Not Implemented\n\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>\n");
@@ -152,7 +152,7 @@ int main(int argc, char **argv)
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
-        } 
+        }
 
         fprintf(stderr,
             "This is method: %s\n"
@@ -160,6 +160,39 @@ int main(int argc, char **argv)
             "This is httpVersion: %s\n"
              ,method, requestURI, httpVersion);
 
+        /*
+        * Read from the file, and write out to file_name.
+        */
+
+        // Open up file_name for reading.
+        FILE *file = fopen("file.txt", "rb");
+        if(file == NULL)
+            die("fopen");
+
+        char buf2[BUF_SIZE];
+        // Switch to fread()/fwrite() so that we can download binary files.
+        size_t n;
+        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+            if (fwrite(buf2, 1, n, clnt_w) != n) {
+                fprintf(stderr, "Encountered error writing to client\n");
+                exit(1);
+            }
+        }
+
+        /*
+        * All done, clean up.
+        */
+
+        // fread() returns 0 on EOF or on error, so we need to check for errors.
+        if (ferror(file)) {
+            fprintf(stderr, "Encountered error reading from file.\n");
+            exit(1);
+        }
+
+        // Close FILE * for output file.
+        if (fclose(file))
+            die("close");
+
         /*        
          * Handle client connection.
         
-- 
2.34.1


From 10a38d9d1573ffab2631791ec2e2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 01:07:19 -0500
Subject: [PATCH 04/11] Now my program can send the file if it exists and send
 404 Not Found when it doesn't.

---
 part1/http-server.c | 42 +++++++++++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 15 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index f4afac9..eb9a728 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -32,7 +32,7 @@ int main(int argc, char **argv)
         usage_and_exit(argv[0]);
 
     char *server_port = argv[1];
-    //char *web_root = argv[2];
+    char *web_root = argv[2];
 
 
     /*
@@ -137,8 +137,8 @@ int main(int argc, char **argv)
         // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
         if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
             fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\n\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>\n");
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
@@ -147,30 +147,40 @@ int main(int argc, char **argv)
         // If URI doesn't start with '/' or there exists '..' in the URI
         if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
             fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\n\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\n");
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
             fclose(clnt_r);
             fclose(clnt_w);
             continue;
         }
 
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-             ,method, requestURI, httpVersion);
-
         /*
         * Read from the file, and write out to file_name.
         */
-
+        
+        char filename[1000] = {0};
+        
+        strcpy(filename, web_root);
+        strcat(filename, requestURI);
+        
+        printf("%s\n", filename);        
         // Open up file_name for reading.
-        FILE *file = fopen("file.txt", "rb");
-        if(file == NULL)
-            die("fopen");
+        FILE *file = fopen(filename, "rb");
+        if(file == NULL){
+            printf("File is not found\n");
+            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                    "<html><body><h1>404 Not Found</h1></body></html>");
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
 
         char buf2[BUF_SIZE];
+       
         // Switch to fread()/fwrite() so that we can download binary files.
+
+        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+
         size_t n;
         while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
             if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -189,6 +199,8 @@ int main(int argc, char **argv)
             exit(1);
         }
 
+    
+
         // Close FILE * for output file.
         if (fclose(file))
             die("close");
-- 
2.34.1


From 9b98287beb7a42cd036eb343094128d736ca56df Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Mon, 28 Nov 2022 02:34:29 -0500
Subject: [PATCH 05/11] Now I can send 301 Moved Permanently responses!

---
 part1/http-server.c | 28 ++++++++++++++++++++++++----
 1 file changed, 24 insertions(+), 4 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index eb9a728..1c12a49 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -6,6 +6,7 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <unistd.h>
 
 #define BUF_SIZE 4096
@@ -153,7 +154,11 @@ int main(int argc, char **argv)
             fclose(clnt_w);
             continue;
         }
-
+        
+        // If URI ends with '/', append "index.html" to the URI 
+        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
+            strcat(requestURI, "index.html");
+        }
         /*
         * Read from the file, and write out to file_name.
         */
@@ -162,12 +167,27 @@ int main(int argc, char **argv)
         
         strcpy(filename, web_root);
         strcat(filename, requestURI);
-        
-        printf("%s\n", filename);        
+
+        printf("Filename is: %s\n", filename);
+
+        struct stat st;
+        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
+            printf("Path is a directory!\n");
+            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                    "Location: %s/\r\n\r\n"
+                    "<html><body>\r\n"
+                    "<h1>301 Moved Permanently</h1>\r\n"
+                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                    "</body></html>", requestURI, requestURI);
+            fclose(clnt_w);
+            fclose(clnt_r);
+            continue;
+        }
+
         // Open up file_name for reading.
         FILE *file = fopen(filename, "rb");
         if(file == NULL){
-            printf("File is not found\n");
+            printf("File is not found!\n");
             fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                     "<html><body><h1>404 Not Found</h1></body></html>");
             fclose(clnt_w);
-- 
2.34.1


From 857918bf62df7d94d34eae5f4ecb64a8f9650c27 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Tue, 29 Nov 2022 05:18:47 -0500
Subject: [PATCH 06/11] Made a lot of changes, seperated the for loop and
 client handling, also attempted to make sure there is no memory leak, but I
 have to spend more time on that.

---
 part1/http-server.c | 349 ++++++++++++++++++++++----------------------
 1 file changed, 175 insertions(+), 174 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 1c12a49..cf244f2 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <signal.h>
 
 #define BUF_SIZE 4096
 static void die(const char *msg)
@@ -23,8 +24,176 @@ static void usage_and_exit(char *argv0)
     exit(1);
 }
 
+static void handle_client(int clnt_fd, char *web_root, char *ip_address){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+    /*
+     * Receive the HTTP response.
+     */
+        
+    char buf[BUF_SIZE];
+
+    // Read the first line
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the initial request line is not complete
+    if(buf[strlen(buf)-1] != '\n'){
+        fprintf(stderr, "Client connection terminated prematurely.\n");
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+
+    char *token_separators = "\t \r\n"; // tab, space, new line
+    char *method = strtok(buf, token_separators);
+    char *requestURI = strtok(NULL, token_separators);
+    char *httpVersion = strtok(NULL, token_separators);
+        
+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+
+     
+            
+    fprintf(stderr, "This is method: %s\n"
+            "This is requestURI: %s\n"
+            "This is httpVersion: %s\n"
+            ,method, requestURI, httpVersion);
+  
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+        // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
+            
+        fprintf(stderr, "This is after appending: %s\n",requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        strcat(requestURI, "index.html");
+    }
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        printf("Path is a directory!\n");
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>", requestURI, requestURI);
+        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(stderr, "File is not found!\n");
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>");
+        fprintf(stderr, "This is URI: %s\n", requestURI);
+        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
+                ip_address, method, requestURI, httpVersion);
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
+            ip_address, method, requestURI, httpVersion);
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            fprintf(stderr, "Encountered error while writing to client\n");
+            exit(1);
+        }
+    }
+
+    /*
+    * All done, clean up.
+    */
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        fprintf(stderr, "Encountered error reading from file.\n");
+        exit(1);
+    } 
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
 int main(int argc, char **argv)
 {
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
     /*
      * Parse arguments and determine output file name.
      */
@@ -92,182 +261,14 @@ int main(int argc, char **argv)
                              &clnt_addr_len);
         if (clnt_fd < 0)
             die("accept");
-
-        // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",
-                inet_ntoa(clnt_addr.sin_addr));
-
-        FILE *clnt_r = fdopen(clnt_fd, "rb");
-        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
-        
-        /*
-         * Receive the HTTP response.
-         */
-        
-        char buf[BUF_SIZE];
-
-        // Read the first line
-        if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
-            fclose(clnt_w);
-            continue;
-        }
-
-        // If the initial request line is not complete
-        if(buf[strlen(buf)-1] != '\n'){
-            fprintf(stderr, "Client connection terminated prematurely.\n");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-
-
-        char *token_separators = "\t \r\n"; // tab, space, new line
-        char *method = strtok(buf, token_separators);
-        char *requestURI = strtok(NULL, token_separators);
-        char *httpVersion = strtok(NULL, token_separators);
-        
-        fprintf(stderr,
-            "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
-  
-
-        // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-        if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-            fprintf(clnt_w,
-                "HTTP/1.0 501 Not Implemented\r\n\r\n"
-                "<html><body><h1>501 Not Implemented</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
         
-        // If URI doesn't start with '/' or there exists '..' in the URI
-        if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-            fprintf(clnt_w,
-                "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-            fclose(clnt_r);
-            fclose(clnt_w);
-            continue;
-        }
-        
-        // If URI ends with '/', append "index.html" to the URI 
-        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI) - 1)  == '/'){
-            strcat(requestURI, "index.html");
-        }
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        char filename[1000] = {0};
-        
-        strcpy(filename, web_root);
-        strcat(filename, requestURI);
-
-        printf("Filename is: %s\n", filename);
-
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            printf("Path is a directory!\n");
-            fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
-                    "Location: %s/\r\n\r\n"
-                    "<html><body>\r\n"
-                    "<h1>301 Moved Permanently</h1>\r\n"
-                    "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                    "</body></html>", requestURI, requestURI);
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        // Open up file_name for reading.
-        FILE *file = fopen(filename, "rb");
-        if(file == NULL){
-            printf("File is not found!\n");
-            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                    "<html><body><h1>404 Not Found</h1></body></html>");
-            fclose(clnt_w);
-            fclose(clnt_r);
-            continue;
-        }
-
-        char buf2[BUF_SIZE];
-       
-        // Switch to fread()/fwrite() so that we can download binary files.
-
-        fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-
-        size_t n;
-        while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
-            if (fwrite(buf2, 1, n, clnt_w) != n) {
-                fprintf(stderr, "Encountered error writing to client\n");
-                exit(1);
-            }
-        }
-
-        /*
-        * All done, clean up.
-        */
-
-        // fread() returns 0 on EOF or on error, so we need to check for errors.
-        if (ferror(file)) {
-            fprintf(stderr, "Encountered error reading from file.\n");
-            exit(1);
-        }
-
-    
-
-        // Close FILE * for output file.
-        if (fclose(file))
-            die("close");
-
-        /*        
-         * Handle client connection.
-        
-
-        // Keep track of how many bytes we've received.
-        size_t recv_len = 0;
-
-        int len;
-        char buf[32];
-
-        // recv() is like read(), except there's an extra flags argument.
-        //
-        // Since we didn't pass any flags to recv(), this is equivalent to
-        // read(clnt_fd, buf, sizeof(buf)).
-        if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-            die("recv");
-
-        while (len > 0) {
-            // Book-keeping.
-            recv_len += len;
-
-            // send() is like write(), except there's an extra flags argument.
-            //
-            // Since we didn't pass any flags to send(), this is equivalent to
-            // write(clnt_fd, buf, len).
-            if (send(clnt_fd, buf, len, 0) != len)
-                die("send");
-
-            // recv() might not have read everything the client sent, so we need
-            // to continue recv()ing.
-            if ((len = recv(clnt_fd, buf, sizeof(buf), 0)) < 0)
-                die("recv");
-        }
-
-        fprintf(stderr, "Received (and sent) %lu bytes in total\n", recv_len);
-
-        */
-
-        // Close client connection.
-        fclose(clnt_r);
-        fclose(clnt_w);
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
-        // Resume server loop to handle next client connection.
+        handle_client(clnt_fd, web_root, ip_address);
+          
     }
 
     /*
-- 
2.34.1


From 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 05:53:07 -0500
Subject: [PATCH 07/11] I noticed a mistake. I had assumed that we won't be
 given header lines, but that's not correct. So, I generalized it. Now it can
 handle multiple header lines.

---
 part1/http-server.c | 118 ++++++++++++++++++++++++++++----------------
 1 file changed, 75 insertions(+), 43 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index cf244f2..f1194ac 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -11,6 +11,7 @@
 #include <signal.h>
 
 #define BUF_SIZE 4096
+
 static void die(const char *msg)
 {
     perror(msg);
@@ -29,51 +30,88 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     FILE *clnt_r = fdopen(clnt_fd, "rb");
     FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
      
-    /*
+     /*
      * Receive the HTTP response.
      */
-        
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
     char buf[BUF_SIZE];
 
     // Read the first line
-    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
         fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
         fclose(clnt_w);
         return;
     }
 
-    // If the initial request line is not complete
-    if(buf[strlen(buf)-1] != '\n'){
-        fprintf(stderr, "Client connection terminated prematurely.\n");
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+
+
+  // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
 
+    char buf3[BUF_SIZE];
 
-    char *token_separators = "\t \r\n"; // tab, space, new line
-    char *method = strtok(buf, token_separators);
-    char *requestURI = strtok(NULL, token_separators);
-    char *httpVersion = strtok(NULL, token_separators);
-        
-        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, httpVersion);
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "400 Bad Request\n");
 
-     
-            
-    fprintf(stderr, "This is method: %s\n"
-            "This is requestURI: %s\n"
-            "This is httpVersion: %s\n"
-            ,method, requestURI, httpVersion);
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
   
 
     // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
     if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
         fprintf(clnt_w,
             "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
-                ip_address, method, requestURI, httpVersion);
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "501 Not Implemented\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
@@ -82,21 +120,18 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // If URI doesn't start with '/' or there exists '..' in the URI
     if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "400 Bad Request\n");
+        buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
         // If URI ends with /, append index.html
-    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/'){
-            
-        fprintf(stderr, "This is after appending: %s\n",requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
-    }
+  
         
         /*
         * Read from the file, and write out to file_name.
@@ -106,38 +141,34 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         
     strcat(web_root, requestURI);
 
-    fprintf(stderr, "Filename is: %s\n", web_root);
+    // fprintf(stderr, "Filename is: %s\n", web_root);
 
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
-        printf("Path is a directory!\n");
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
                 "Location: %s/\r\n\r\n"
                 "<html><body>\r\n"
                 "<h1>301 Moved Permanently</h1>\r\n"
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
-                "</body></html>", requestURI, requestURI);
-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",
-                ip_address, method, requestURI, httpVersion);
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return; 
     }
 
     // Open up file_name for reading.
     FILE *file = fopen(web_root, "rb");
     if(file == NULL){
-        fprintf(stderr, "File is not found!\n");
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
-                "<html><body><h1>404 Not Found</h1></body></html>");
-        fprintf(stderr, "This is URI: %s\n", requestURI);
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);
-        fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",
-                ip_address, method, requestURI, httpVersion);
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        buf[0] = 0;
         return;
     }
 
@@ -149,8 +180,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     // Use fread()/fwrite() so that we can upload binary files.
 
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
-    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",
-            ip_address, method, requestURI, httpVersion);
+    fprintf(stderr, "200 OK\n");
     size_t n;
     while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
@@ -163,6 +193,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     * All done, clean up.
     */
 
+    buf[0] = 0;
+
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
         fprintf(stderr, "Encountered error reading from file.\n");
-- 
2.34.1


From 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:26:54 -0500
Subject: [PATCH 08/11] Wrote part2, but will probably need some changes.

---
 part1/http-server.c       |  96 ++++++-----
 part2/Makefile            |  16 ++
 part2/multi-http-server.c | 354 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 423 insertions(+), 43 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/multi-http-server.c

diff --git a/part1/http-server.c b/part1/http-server.c
index f1194ac..3e500eb 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -41,7 +41,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
    
     char buf[BUF_SIZE];
 
-    // Read the first line
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -64,15 +65,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     httpVersion = strtok(NULL, token_separators);
     char * extra = strtok(NULL, token_separators);
 
-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
-
 
-  // If the initial request line is not complete or there is an extra word at the end
+    // If the initial request line is not complete or there is an extra word at the end
     if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
 
         fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
@@ -81,13 +81,39 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         return;
     }
 
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
     char buf3[BUF_SIZE];
 
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        	fprintf(stderr, "400 Bad Request\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
 
         	fprintf(stderr, "There was an issue with header lines\n");
         	buf[0] = 0;
@@ -104,31 +130,10 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     //From this point on, we can assume that HTTP request has correct structure
   
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
 
-    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
-    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
-        fprintf(clnt_w,
-            "HTTP/1.0 501 Not Implemented\r\n\r\n"
-            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
-        fprintf(stderr, "501 Not Implemented\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "400 Bad Request\n");
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-        
-        // If URI ends with /, append index.html
+    // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
         strcat(requestURI, "index.html");
   
@@ -155,7 +160,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return; 
     }
 
@@ -168,7 +172,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
-        buf[0] = 0;
         return;
     }
 
@@ -179,28 +182,35 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
        
     // Use fread()/fwrite() so that we can upload binary files.
 
+
     fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
     fprintf(stderr, "200 OK\n");
     size_t n;
-    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0) {
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
         if (fwrite(buf2, 1, n, clnt_w) != n) {
-            fprintf(stderr, "Encountered error while writing to client\n");
-            exit(1);
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
         }
     }
 
-    /*
-    * All done, clean up.
-    */
-
-    buf[0] = 0;
 
     // fread() returns 0 on EOF or on error, so we need to check for errors.
     if (ferror(file)) {
-        fprintf(stderr, "Encountered error reading from file.\n");
-        exit(1);
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
     } 
 
+
+    /*
+    * All done, clean up.
+    */
+
     // Close FILE * for output file.
     if (fclose(file))
         die("close");       
@@ -297,7 +307,7 @@ int main(int argc, char **argv)
         char *ip_address = inet_ntoa(clnt_addr.sin_addr);
             
         // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",ip_address);
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
 
         handle_client(clnt_fd, web_root, ip_address);
           
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..9be1e81
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,16 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+.PHONY: default
+default: multi-http-server
+
+http-server:
+
+.PHONY: clean
+clean:
+	rm -rf a.out *.o multi-http-server
+
+.PHONY: all
+all: clean multi-http-server
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
new file mode 100644
index 0000000..929e9f7
--- /dev/null
+++ b/part2/multi-http-server.c
@@ -0,0 +1,354 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/wait.h>
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg)
+{
+    perror(msg);
+    exit(1);
+}
+
+static void usage_and_exit(char *argv0)
+{
+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);
+    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);
+    exit(1);
+}
+
+void reap_children(int sig){
+    while (waitpid(-1, NULL, WNOHANG) > 0)
+        ;
+}
+
+static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){
+        
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+     
+     /*
+     * Receive the HTTP response.
+     */
+    
+    char *method = NULL;
+    char *requestURI = NULL;
+    char *httpVersion = NULL;    
+    char *token_separators = "\t \r\n"; // tab, space, new line
+   
+    char buf[BUF_SIZE];
+
+    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
+    // CHECK AFTER THIS
+    if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
+        method = strtok(buf, token_separators);
+        requestURI = strtok(NULL, token_separators);
+        httpVersion = strtok(NULL, token_separators);
+
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
+        buf[0] = '\0';
+        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        fclose(clnt_w);
+        return;
+    }
+
+    method = strtok(buf, token_separators);
+    requestURI = strtok(NULL, token_separators);
+    httpVersion = strtok(NULL, token_separators);
+    char * extra = strtok(NULL, token_separators);
+
+
+    // If the initial request line is not complete or there is an extra word at the end
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+       
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+
+        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
+        buf[0] = 0; 
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1
+    if (strcmp("GET", method) != 0 || !(strcmp("HTTP/1.0", httpVersion) == 0 || strcmp("HTTP/1.1", httpVersion) == 0)) {
+        fprintf(clnt_w,
+            "HTTP/1.0 501 Not Implemented\r\n\r\n"
+            "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+        
+    // If URI doesn't start with '/' or there exists '..' in the URI
+    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                ip_address, method, requestURI, httpVersion);
+        buf[0] = 0;
+        fclose(clnt_r);
+        fclose(clnt_w);
+        return;
+    }
+
+    char buf3[BUF_SIZE];
+
+    while(1){
+	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
+                	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, method, requestURI, httpVersion);
+
+        	fprintf(stderr, "There was an issue with header lines\n");
+        	buf[0] = 0;
+        	fclose(clnt_r);
+        	fclose(clnt_w);
+        	return;
+    	}
+
+
+	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
+ 		break;
+
+    }
+
+    //From this point on, we can assume that HTTP request has correct structure
+  
+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    buf[0] = 0;
+
+    // If URI ends with /, append index.html
+    if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
+        strcat(requestURI, "index.html");
+  
+        
+        /*
+        * Read from the file, and write out to file_name.
+        */
+        
+        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        
+    strcat(web_root, requestURI);
+
+    // fprintf(stderr, "Filename is: %s\n", web_root);
+
+    struct stat st;
+    if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
+                "Location: %s/\r\n\r\n"
+                "<html><body>\r\n"
+                "<h1>301 Moved Permanently</h1>\r\n"
+                "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
+                "</body></html>\r\n", requestURI, requestURI);
+        fprintf(stderr, "301 Moved Permanently\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return; 
+    }
+
+    // Open up file_name for reading.
+    FILE *file = fopen(web_root, "rb");
+    if(file == NULL){
+        fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>\r\n");
+        fprintf(stderr, "404 Not Found\n");
+        fclose(clnt_w);
+        fclose(clnt_r);
+        *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
+        return;
+    }
+
+    // Bring back web_root to its original content
+    *(web_root + strlen(web_root) - strlen(requestURI)) = '\0'; 
+        
+    char buf2[BUF_SIZE];
+       
+    // Use fread()/fwrite() so that we can upload binary files.
+
+
+    fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");
+    fprintf(stderr, "200 OK\n");
+    size_t n;
+    while ((n = fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file)) ) {
+        if (fwrite(buf2, 1, n, clnt_w) != n) {
+            // Don't crash the server and move to the next client.
+            fclose(clnt_w);
+            fclose(clnt_r);
+            perror("send bytes to client");
+            return;
+        }
+    }
+
+
+    // fread() returns 0 on EOF or on error, so we need to check for errors.
+    if (ferror(file)) {
+        // Don't crash the server and move to the next client.
+        fclose(clnt_w);
+        fclose(clnt_r);
+        perror("read from the file requested");
+        return;
+    } 
+
+
+    /*
+    * All done, clean up.
+    */
+
+    // Close FILE * for output file.
+    if (fclose(file))
+        die("close");       
+
+    // Close client connection.
+    fclose(clnt_r);
+    fclose(clnt_w);
+
+    // Resume server loop to handle next client connection.
+    return;
+}
+
+
+
+int main(int argc, char **argv)
+{
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));         // Zero-initialize sigaction structure
+    sigemptyset(&sa.sa_mask);           // Don't mask any signals
+    sa.sa_handler = SIG_IGN;            // Ignore the signal
+
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction");
+
+    /*
+     * Parse arguments and determine output file name.
+     */
+
+    if (argc != 3)
+        usage_and_exit(argv[0]);
+
+    char *server_port = argv[1];
+    char *web_root = argv[2];
+
+
+    /*
+     * Obtain socket address structure from server name and port number.
+     */
+
+    struct addrinfo hints, *info;
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // Stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int aerr;
+    if ((aerr = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(aerr));
+        exit(1);
+    }
+
+    /*
+     * Create a socket(), bind() it to the server, and wrap in FILE *s.
+     */
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+   
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+
+     /*
+     * Server loop runs forever (writing "for (;;)" is the same as "while(1)")
+     */
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+        
+        char *ip_address = inet_ntoa(clnt_addr.sin_addr);
+            
+        // clnt_addr is now populated with information about the client.
+        //fprintf(stderr, "Accepted connection from %s\n",ip_address);
+
+        pid_t pid = fork();
+
+        // Both the parent and child will resume execution here.
+        if (pid == 0){
+            
+            // Child process
+            close(serv_fd);
+            handle_client(clnt_fd, web_root, ip_address, getpid());
+            exit(0);
+
+        }else{
+            
+            close(clnt_fd);
+            // Parent process
+            struct sigaction sa2;
+            memset(&sa2, 0, sizeof(sa2));         // Zero-initialize sigaction structure
+            sigemptyset(&sa2.sa_mask);           // Don't mask any signals
+            sa.sa_flags = SA_RESTART;             // Restart interrupted system calls
+            sa.sa_handler = &reap_children;      // Reap children upon receiving signal
+
+            if (sigaction(SIGCHLD, &sa, NULL))
+                die("sigaction");
+        }
+         
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    // Theoretically, if we want our server to handle graceful termination, we
+    // should also close() the server socket here too:
+    close(serv_fd);
+
+    return 0;
+}
+
-- 
2.34.1


From 5161264295a97a290b1442fd240cde6ea9372bcc Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 18:28:11 -0500
Subject: [PATCH 09/11] Made a change to README.

---
 README.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index 49c4472..b6c6f1c 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab6
+  - It should work!
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
-- 
2.34.1


From ad8500bd591cd6d51ecbe9b7ce004e6faa945c01 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 30 Nov 2022 23:55:45 -0500
Subject: [PATCH 10/11] Final commit.

---
 README.txt                | 72 ++++++++++++++++++++++++++++++++-
 part1/http-server.c       | 53 ++++++++----------------
 part2/multi-http-server.c | 85 ++++++++++++++++-----------------------
 3 files changed, 122 insertions(+), 88 deletions(-)

diff --git a/README.txt b/README.txt
index b6c6f1c..e0816e8 100644
--- a/README.txt
+++ b/README.txt
@@ -3,9 +3,79 @@ This file should contain:
   - Arman Ozcan
   - ao2794
   - lab6
-  - It should work!
+  - It should work! And I set up my web page.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+==68827== Memcheck, a memory error detector
+==68827== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==68827== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==68827== Command: ./http-server 10125 /mnt/disks/students229/ao2794/html
+==68827== 
+34.145.159.110 "GET /cs3157/ HTTP/1.0" 200 OK
+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented
+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented
+34.145.159.110 "GET /cs3157 HTTP/1.1" 301 Moved Permanently
+==68827== 
+==68827== Process terminating with default action of signal 2 (SIGINT)
+==68827==    at 0x498A5D7: accept (accept.c:26)
+==68827==    by 0x10A1AF: main (http-server.c:283)
+==68827== 
+==68827== HEAP SUMMARY:
+==68827==     in use at exit: 0 bytes in 0 blocks
+==68827==   total heap usage: 19 allocs, 19 frees, 37,592 bytes allocated
+==68827== 
+==68827== All heap blocks were freed -- no leaks are possible
+==68827== 
+==68827== For lists of detected and suppressed errors, rerun with: -s
+==68827== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==115292== Memcheck, a memory error detector
+==115292== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==115292== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
+==115292== Command: ./multi-http-server 10129 /mnt/disks/students229/ao2794/html
+==115292== 
+34.145.159.110 (116118) "GET /cs3157/photos.jpg HTTP/1.1" 404 Not Found
+==116118== 
+==116118== HEAP SUMMARY:
+==116118==     in use at exit: 0 bytes in 0 blocks
+==116118==   total heap usage: 6 allocs, 6 frees, 9,672 bytes allocated
+==116118== 
+==116118== All heap blocks were freed -- no leaks are possible
+==116118== 
+==116118== For lists of detected and suppressed errors, rerun with: -s
+==116118== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+34.145.159.110 (117352) "GET /cs3157/images/photos.jpg HTTP/1.1" 404 Not Found
+==117352== 
+==117352== HEAP SUMMARY:
+==117352==     in use at exit: 0 bytes in 0 blocks
+==117352==   total heap usage: 6 allocs, 6 frees, 9,672 bytes allocated
+==117352== 
+==117352== All heap blocks were freed -- no leaks are possible
+==117352== 
+==117352== For lists of detected and suppressed errors, rerun with: -s
+==117352== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+34.145.159.110 (117760) "GET /cs3157/images/photo.jpg HTTP/1.1" 200 OK
+==117760== 
+==117760== HEAP SUMMARY:
+==117760==     in use at exit: 0 bytes in 0 blocks
+==117760==   total heap usage: 7 allocs, 7 frees, 17,864 bytes allocated
+==117760== 
+==117760== All heap blocks were freed -- no leaks are possible
+==117760== 
+==117760== For lists of detected and suppressed errors, rerun with: -s
+==117760== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+==115292== 
+==115292== Process terminating with default action of signal 2 (SIGINT)
+==115292==    at 0x498A5D7: accept (accept.c:26)
+==115292==    by 0x10A2A7: main (multi-http-server.c:291)
+==115292== 
+==115292== HEAP SUMMARY:
+==115292==     in use at exit: 0 bytes in 0 blocks
+==115292==   total heap usage: 1 allocs, 1 frees, 64 bytes allocated
+==115292== 
+==115292== All heap blocks were freed -- no leaks are possible
+==115292== 
+==115292== For lists of detected and suppressed errors, rerun with: -s
+==115292== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
diff --git a/part1/http-server.c b/part1/http-server.c
index 3e500eb..5923fd2 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -41,8 +41,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
    
     char buf[BUF_SIZE];
 
-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
-    // CHECK AFTER THIS
+    // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -53,9 +52,8 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                 ip_address, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
-        buf[0] = '\0';
-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        buf[0] = 0;
+        fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
@@ -67,14 +65,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
 
     // If the initial request line is not complete or there is an extra word at the end
-    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
+    // Or the URI doesn't start with '/' or there exists 
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL || strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/../") != NULL  || ( (strlen(requestURI) >= 3) && *(requestURI + strlen(requestURI) - 1) == '.' && *(requestURI + strlen(requestURI) - 2) == '.' && *(requestURI + strlen(requestURI) - 3) == '/') ){
        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                 ip_address, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
@@ -88,41 +86,28 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
             "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
         fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
                ip_address, method, requestURI, httpVersion);
+    
         buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-
     char buf3[BUF_SIZE];
-
+    
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
         	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
                         ip_address, method, requestURI, httpVersion);
-
-        	fprintf(stderr, "There was an issue with header lines\n");
-        	buf[0] = 0;
+ 
+                buf[0] = 0;
         	fclose(clnt_r);
         	fclose(clnt_w);
         	return;
     	}
 
-
 	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
  		break;
 
@@ -135,19 +120,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
-        strcat(requestURI, "index.html");
-  
-        
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        strcat(requestURI, "index.html"); 
+         
         
     strcat(web_root, requestURI);
 
-    // fprintf(stderr, "Filename is: %s\n", web_root);
-
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
@@ -157,6 +134,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
                 "</body></html>\r\n", requestURI, requestURI);
         fprintf(stderr, "301 Moved Permanently\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -169,6 +147,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>\r\n");
         fprintf(stderr, "404 Not Found\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -191,9 +170,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
             // Don't crash the server and move to the next client.
             fclose(clnt_w);
             fclose(clnt_r);
+            fclose(file);
             perror("send bytes to client");
             return;
         }
+        fflush(clnt_w);
     }
 
 
@@ -202,6 +183,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
         // Don't crash the server and move to the next client.
         fclose(clnt_w);
         fclose(clnt_r);
+        fclose(file);
         perror("read from the file requested");
         return;
     } 
@@ -212,8 +194,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
     */
 
     // Close FILE * for output file.
-    if (fclose(file))
-        die("close");       
+    fclose(file);       
 
     // Close client connection.
     fclose(clnt_r);
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
index 929e9f7..4eb8018 100644
--- a/part2/multi-http-server.c
+++ b/part2/multi-http-server.c
@@ -31,11 +31,12 @@ void reap_children(int sig){
         ;
 }
 
-static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){
-        
+static void handle_client(int clnt_fd, char *web_root, char *ip_address){
+
     FILE *clnt_r = fdopen(clnt_fd, "rb");
     FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
-     
+    int pid = (int) getpid();
+
      /*
      * Receive the HTTP response.
      */
@@ -47,8 +48,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
    
     char buf[BUF_SIZE];
 
-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE
-    // CHECK AFTER THIS
+    // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
         method = strtok(buf, token_separators);
         requestURI = strtok(NULL, token_separators);
@@ -56,12 +56,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                ip_address, pid, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the first if.\n");
-        buf[0] = '\0';
-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}
+        buf[0] = 0;
+        fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
@@ -73,14 +72,14 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
 
     // If the initial request line is not complete or there is an extra word at the end
-    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL){
-       
+    // Or the URI doesn't start with '/' or there exists 
+    if(method == NULL || requestURI == NULL || httpVersion == NULL || extra != NULL || strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/../") != NULL  || ( (strlen(requestURI) >= 3) && *(requestURI + strlen(requestURI) - 1) == '.' && *(requestURI + strlen(requestURI) - 2) == '.' && *(requestURI + strlen(requestURI) - 3) == '/') ){
+
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                ip_address, pid, method, requestURI, httpVersion);
 
-        fprintf(stderr, "Client connection terminated prematurely by the third if.\n");
         buf[0] = 0; 
         fclose(clnt_r);
         fclose(clnt_w);
@@ -92,43 +91,30 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         fprintf(clnt_w,
             "HTTP/1.0 501 Not Implemented\r\n\r\n"
             "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",
-               ip_address, method, requestURI, httpVersion);
+        fprintf(stderr, "%s (%d) \"%s %s %s\" 501 Not Implemented\n",
+               ip_address, pid, method, requestURI, httpVersion);
+    
         buf[0] = 0;
         fclose(clnt_r);
         fclose(clnt_w);
         return;
     }
         
-    // If URI doesn't start with '/' or there exists '..' in the URI
-    if (strncmp("/", requestURI, 1) != 0 || strstr(requestURI, "/..") != NULL ) {
-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
-                "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                ip_address, method, requestURI, httpVersion);
-        buf[0] = 0;
-        fclose(clnt_r);
-        fclose(clnt_w);
-        return;
-    }
-
     char buf3[BUF_SIZE];
-
+    
     while(1){
 	 if (fgets(buf3, sizeof(buf3), clnt_r) == NULL) {       
        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
-        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",
-                        ip_address, method, requestURI, httpVersion);
-
-        	fprintf(stderr, "There was an issue with header lines\n");
-        	buf[0] = 0;
+        	fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
+                        ip_address, pid, method, requestURI, httpVersion);
+ 
+                buf[0] = 0;
         	fclose(clnt_r);
         	fclose(clnt_w);
         	return;
     	}
 
-
 	if(strlen(buf3) <= 2  && buf3[strlen(buf3)-1] == '\n' )
  		break;
 
@@ -136,33 +122,26 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
     //From this point on, we can assume that HTTP request has correct structure
   
-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requestURI, httpVersion);
+    fprintf(stderr, "%s (%d) \"%s %s %s\" ", ip_address, pid, method, requestURI, httpVersion);
     buf[0] = 0;
 
     // If URI ends with /, append index.html
     if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  == '/')         
-        strcat(requestURI, "index.html");
-  
-        
-        /*
-        * Read from the file, and write out to file_name.
-        */
-        
-        // char *filename; [strlen(web_root + strlen(requestURI)) + 1];
+        strcat(requestURI, "index.html"); 
+         
         
     strcat(web_root, requestURI);
 
-    // fprintf(stderr, "Filename is: %s\n", web_root);
-
     struct stat st;
     if (stat(web_root, &st) == 0 && S_ISDIR(st.st_mode)) {
         fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"
-                "Location: %s/\r\n\r\n"
+                "Location: %s/\r\n\r\n" 
                 "<html><body>\r\n"
                 "<h1>301 Moved Permanently</h1>\r\n"
                 "<p>The document has moved <a href=\"%s/\">here</a>.</p>\r\n"
                 "</body></html>\r\n", requestURI, requestURI);
         fprintf(stderr, "301 Moved Permanently\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -175,6 +154,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>\r\n");
         fprintf(stderr, "404 Not Found\n");
+       
         fclose(clnt_w);
         fclose(clnt_r);
         *(web_root + strlen(web_root) - strlen(requestURI)) = '\0';
@@ -197,9 +177,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
             // Don't crash the server and move to the next client.
             fclose(clnt_w);
             fclose(clnt_r);
+            fclose(file);
             perror("send bytes to client");
             return;
         }
+        fflush(clnt_w);
     }
 
 
@@ -208,6 +190,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
         // Don't crash the server and move to the next client.
         fclose(clnt_w);
         fclose(clnt_r);
+        fclose(file);
         perror("read from the file requested");
         return;
     } 
@@ -218,8 +201,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
     */
 
     // Close FILE * for output file.
-    if (fclose(file))
-        die("close");       
+    fclose(file);       
 
     // Close client connection.
     fclose(clnt_r);
@@ -227,6 +209,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_t p
 
     // Resume server loop to handle next client connection.
     return;
+
 }
 
 
@@ -322,7 +305,7 @@ int main(int argc, char **argv)
             
             // Child process
             close(serv_fd);
-            handle_client(clnt_fd, web_root, ip_address, getpid());
+            handle_client(clnt_fd, web_root, ip_address);
             exit(0);
 
         }else{
-- 
2.34.1


From 17ae1860457a370c88f3a00141b83135e5a0ecb0 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Thu, 1 Dec 2022 00:22:10 -0500
Subject: [PATCH 11/11] Noticed a memory error when the client does CTRL + C
 and fixed it.

---
 part1/http-server.c       | 3 ---
 part2/multi-http-server.c | 5 +----
 2 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/part1/http-server.c b/part1/http-server.c
index 5923fd2..bfd6147 100644
--- a/part1/http-server.c
+++ b/part1/http-server.c
@@ -43,9 +43,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
-        method = strtok(buf, token_separators);
-        requestURI = strtok(NULL, token_separators);
-        httpVersion = strtok(NULL, token_separators);
 
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
diff --git a/part2/multi-http-server.c b/part2/multi-http-server.c
index 4eb8018..e6dd0da 100644
--- a/part2/multi-http-server.c
+++ b/part2/multi-http-server.c
@@ -50,10 +50,7 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_address){
 
     // Reads the initial request line.
     if (fgets(buf, sizeof(buf), clnt_r) == NULL) {       
-        method = strtok(buf, token_separators);
-        requestURI = strtok(NULL, token_separators);
-        httpVersion = strtok(NULL, token_separators);
-
+        
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"
                 "<html><body><h1>400 Bad Request</h1></body></html>\r\n");
         fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n",
-- 
2.34.1


--RM7gcjQxE9obSeaN
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab6.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 6f0b26f4859b98d12156a2b5bbd4046be51fb70f Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 26 Nov 2022 17:01:52=
 -0500=0ASubject: [PATCH 01/11] I created a Makefile and http-server.c with=
 skeletal=0A code.=0A=0A---=0A part1/Makefile      |  16 +++++=0A part1/htt=
p-server.c | 149 ++++++++++++++++++++++++++++++++++++++++++++=0A 2 files ch=
anged, 165 insertions(+)=0A create mode 100644 part1/Makefile=0A create mod=
e 100644 part1/http-server.c=0A=0Adiff --git a/part1/Makefile b/part1/Makef=
ile=0Anew file mode 100644=0Aindex 0000000..564dbfd=0A--- /dev/null=0A+++ b=
/part1/Makefile=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wp=
edantic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+d=
efault: http-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=0A+	=
rm -rf a.out *.o http-server=0A+=0A+.PHONY: all=0A+all: clean http-server=
=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Anew file mode 1=
00644=0Aindex 0000000..dae362f=0A--- /dev/null=0A+++ b/part1/http-server.c=
=0A@@ -0,0 +1,149 @@=0A+#define _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#i=
nclude <netdb.h>=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <=
string.h>=0A+#include <sys/socket.h>=0A+#include <sys/types.h>=0A+#include =
<unistd.h>=0A+=0A+static void die(const char *msg)=0A+{=0A+    perror(msg);=
=0A+    exit(1);=0A+}=0A+=0A+static void usage_and_exit(char *argv0)=0A+{=
=0A+    fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv0);=0A+=
    fprintf(stderr, "   ex) %s 8888 ~/html\n", argv0);=0A+    exit(1);=0A+}=
=0A+=0A+int main(int argc, char **argv)=0A+{=0A+    /*=0A+     * Parse argu=
ments and determine output file name.=0A+     */=0A+=0A+    if (argc !=3D 3=
)=0A+        usage_and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv=
[1];=0A+    //char *web_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtai=
n socket address structure from server name and port number.=0A+     */=0A+=
=0A+    struct addrinfo hints, *info;=0A+    memset(&hints, 0, sizeof(hints=
));=0A+=0A+    hints.ai_family =3D AF_INET;       // Only accept IPv4 addre=
sses=0A+    hints.ai_socktype =3D SOCK_STREAM; // Stream socket for TCP con=
nections=0A+    hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    h=
ints.ai_flags =3D AI_PASSIVE;     // Construct socket address for bind()ing=
=0A+=0A+    int aerr;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &=
hints, &info)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", ga=
i_strerror(aerr));=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Cre=
ate a socket(), bind() it to the server, and wrap in FILE *s.=0A+     */=0A=
+=0A+    int serv_fd =3D socket(info->ai_family, info->ai_socktype, info->a=
i_protocol);=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    i=
f (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind=
");=0A+   =0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for c=
onnections on this socket, maintaining a queue of=0A+    // at most 8 pendi=
ng connections.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen")=
;=0A+=0A+=0A+     /*=0A+     * Server loop runs forever (writing "for (;;)"=
 is the same as "while(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=
=0A+         * accept() connection from client.=0A+         */=0A+=0A+     =
   // Define space to receive client address info.=0A+        struct sockad=
dr_in clnt_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=
=0A+=0A+        // accept() blocks until a client connects with the server,=
 and returns=0A+        // a NEW socket file descriptor for interacting wit=
h the client.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *=
) &clnt_addr,=0A+                             &clnt_addr_len);=0A+        i=
f (clnt_fd < 0)=0A+            die("accept");=0A+=0A+        // clnt_addr i=
s now populated with information about the client.=0A+        fprintf(stder=
r, "Accepted connection from %s\n",=0A+                inet_ntoa(clnt_addr.=
sin_addr));=0A+=0A+        /*=0A+         * Handle client connection.=0A+  =
       */=0A+=0A+        // Keep track of how many bytes we've received.=0A=
+        size_t recv_len =3D 0;=0A+=0A+        int len;=0A+        char buf=
[32];=0A+=0A+        // recv() is like read(), except there's an extra flag=
s argument.=0A+        //=0A+        // Since we didn't pass any flags to r=
ecv(), this is equivalent to=0A+        // read(clnt_fd, buf, sizeof(buf)).=
=0A+        if ((len =3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A+      =
      die("recv");=0A+=0A+        while (len > 0) {=0A+            // Book-=
keeping.=0A+            recv_len +=3D len;=0A+=0A+            // send() is =
like write(), except there's an extra flags argument.=0A+            //=0A+=
            // Since we didn't pass any flags to send(), this is equivalent=
 to=0A+            // write(clnt_fd, buf, len).=0A+            if (send(cln=
t_fd, buf, len, 0) !=3D len)=0A+                die("send");=0A+=0A+       =
     // recv() might not have read everything the client sent, so we need=
=0A+            // to continue recv()ing.=0A+            if ((len =3D recv(=
clnt_fd, buf, sizeof(buf), 0)) < 0)=0A+                die("recv");=0A+    =
    }=0A+=0A+        fprintf(stderr, "Received (and sent) %lu bytes in tota=
l\n", recv_len);=0A+=0A+        // Close client connection.=0A+        clos=
e(clnt_fd);=0A+=0A+        // Resume server loop to handle next client conn=
ection.=0A+    }=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    =
// Theoretically, if we want our server to handle graceful termination, we=
=0A+    // should also close() the server socket here too:=0A+    close(ser=
v_fd);=0A+=0A+    return 0;=0A+}=0A-- =0A2.34.1=0A=0A=0AFrom e0bfbf633d48c7=
dab909c8d32b77e884d1a47796 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao=
2794@columbia.edu>=0ADate: Sat, 26 Nov 2022 21:41:13 -0500=0ASubject: [PATC=
H 02/11] Can parse the HTTP request now.=0A=0A---=0A part1/http-server.c | =
72 +++++++++++++++++++++++++++++++++++++++++++--=0A 1 file changed, 70 inse=
rtions(+), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/htt=
p-server.c=0Aindex dae362f..980293d 100644=0A--- a/part1/http-server.c=0A++=
+ b/part1/http-server.c=0A@@ -8,6 +8,7 @@=0A #include <sys/types.h>=0A #inc=
lude <unistd.h>=0A =0A+#define BUF_SIZE 4096=0A static void die(const char =
*msg)=0A {=0A     perror(msg);=0A@@ -95,9 +96,73 @@ int main(int argc, char=
 **argv)=0A         fprintf(stderr, "Accepted connection from %s\n",=0A    =
             inet_ntoa(clnt_addr.sin_addr));=0A =0A+        FILE *clnt_r =
=3D fdopen(clnt_fd, "rb");=0A+        FILE *clnt_w =3D fdopen(dup(clnt_fd),=
 "wb");=0A+        =0A         /*=0A-         * Handle client connection.=
=0A+         * Receive the HTTP response.=0A          */=0A+        =0A+   =
     char buf[BUF_SIZE];=0A+=0A+        // Read the first line=0A+        i=
f (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A+            fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A+            fclose=
(clnt_r); //if(fclose(clnt_r)){die("close");}=0A+            fclose(clnt_w)=
;=0A+            continue;=0A+        }=0A+=0A+        // If the initial re=
quest line is not complete=0A+        if(buf[strlen(buf)-1] !=3D '\n'){=0A+=
            fprintf(stderr, "Client connection terminated prematurely.\n");=
=0A+            fclose(clnt_r);=0A+            fclose(clnt_w);=0A+         =
   continue;=0A+        }=0A+=0A+=0A+        char *token_separators =3D "\t=
 \r\n"; // tab, space, new line=0A+        char *method =3D strtok(buf, tok=
en_separators);=0A+        char *requestURI =3D strtok(NULL, token_separato=
rs);=0A+        char *httpVersion =3D strtok(NULL, token_separators);=0A+  =
      =0A+        fprintf(stderr,=0A+            "This is method: %s\n"=0A+=
            "This is requestURI: %s\n"=0A+            "This is httpVersion:=
 %s\n"=0A+            ,method, requestURI, httpVersion);=0A+  =0A+=0A+     =
   // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP=
/1.1=0A+        if (strcmp("GET", method) !=3D 0 || strcmp("HTTP/1.0", http=
Version) !=3D 0 || strcmp("HTTP/1.1", httpVersion) !=3D 0) {=0A+           =
 fprintf(clnt_w,=0A+                "HTTP/1.0 501 Not Implemented\n\n"=0A+ =
               "<html><body><h1>501 Not Implemented</h1></body></html>\n");=
=0A+            fclose(clnt_r);=0A+            fclose(clnt_w);=0A+         =
   continue;=0A+        }=0A+        =0A+        // If URI doesn't start wi=
th '/' or there exists '..' in the URI=0A+        if (strncmp("/", requestU=
RI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A+            fpri=
ntf(clnt_w,=0A+                "HTTP/1.0 400 Bad Request\n\n"=0A+          =
      "<html><body><h1>400 Bad Request</h1></body></html>\n");=0A+         =
   fclose(clnt_r);=0A+            fclose(clnt_w);=0A+            continue;=
=0A+        } =0A+=0A+        fprintf(stderr,=0A+            "This is metho=
d: %s\n"=0A+            "This is requestURI: %s\n"=0A+            "This is =
httpVersion: %s\n"=0A+             ,method, requestURI, httpVersion);=0A+=
=0A+        /*        =0A+         * Handle client connection.=0A+        =
=0A =0A         // Keep track of how many bytes we've received.=0A         =
size_t recv_len =3D 0;=0A@@ -131,8 +196,11 @@ int main(int argc, char **arg=
v)=0A =0A         fprintf(stderr, "Received (and sent) %lu bytes in total\n=
", recv_len);=0A =0A+        */=0A+=0A         // Close client connection.=
=0A-        close(clnt_fd);=0A+        fclose(clnt_r);=0A+        fclose(cl=
nt_w);=0A =0A         // Resume server loop to handle next client connectio=
n.=0A     }=0A-- =0A2.34.1=0A=0A=0AFrom 5012829bc3c592d667c295a7da1bf207dc7=
745d1 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0A=
Date: Sat, 26 Nov 2022 22:32:29 -0500=0ASubject: [PATCH 03/11] Now I can se=
nd a file back, but it just sends the same=0A file now.=0A=0A---=0A part1/h=
ttp-server.c | 37 +++++++++++++++++++++++++++++++++++--=0A 1 file changed, =
35 insertions(+), 2 deletions(-)=0A=0Adiff --git a/part1/http-server.c b/pa=
rt1/http-server.c=0Aindex 980293d..f4afac9 100644=0A--- a/part1/http-server=
=2Ec=0A+++ b/part1/http-server.c=0A@@ -135,7 +135,7 @@ int main(int argc, c=
har **argv)=0A   =0A =0A         // If the request is not GET or the HTTP v=
ersion is not HTTP/1.0 or HTTP/1.1=0A-        if (strcmp("GET", method) !=
=3D 0 || strcmp("HTTP/1.0", httpVersion) !=3D 0 || strcmp("HTTP/1.1", httpV=
ersion) !=3D 0) {=0A+        if (strcmp("GET", method) !=3D 0 || !(strcmp("=
HTTP/1.0", httpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D =
0)) {=0A             fprintf(clnt_w,=0A                 "HTTP/1.0 501 Not I=
mplemented\n\n"=0A                 "<html><body><h1>501 Not Implemented</h1=
></body></html>\n");=0A@@ -152,7 +152,7 @@ int main(int argc, char **argv)=
=0A             fclose(clnt_r);=0A             fclose(clnt_w);=0A          =
   continue;=0A-        } =0A+        }=0A =0A         fprintf(stderr,=0A  =
           "This is method: %s\n"=0A@@ -160,6 +160,39 @@ int main(int argc,=
 char **argv)=0A             "This is httpVersion: %s\n"=0A              ,m=
ethod, requestURI, httpVersion);=0A =0A+        /*=0A+        * Read from t=
he file, and write out to file_name.=0A+        */=0A+=0A+        // Open u=
p file_name for reading.=0A+        FILE *file =3D fopen("file.txt", "rb");=
=0A+        if(file =3D=3D NULL)=0A+            die("fopen");=0A+=0A+      =
  char buf2[BUF_SIZE];=0A+        // Switch to fread()/fwrite() so that we =
can download binary files.=0A+        size_t n;=0A+        while ((n =3D fr=
ead(buf2, 1, sizeof(buf2), file)) > 0) {=0A+            if (fwrite(buf2, 1,=
 n, clnt_w) !=3D n) {=0A+                fprintf(stderr, "Encountered error=
 writing to client\n");=0A+                exit(1);=0A+            }=0A+   =
     }=0A+=0A+        /*=0A+        * All done, clean up.=0A+        */=0A+=
=0A+        // fread() returns 0 on EOF or on error, so we need to check fo=
r errors.=0A+        if (ferror(file)) {=0A+            fprintf(stderr, "En=
countered error reading from file.\n");=0A+            exit(1);=0A+        =
}=0A+=0A+        // Close FILE * for output file.=0A+        if (fclose(fil=
e))=0A+            die("close");=0A+=0A         /*        =0A          * Ha=
ndle client connection.=0A         =0A-- =0A2.34.1=0A=0A=0AFrom 10a38d9d157=
3ffab2631791ec2e2eb4e0a05ffb3 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan =
<ao2794@columbia.edu>=0ADate: Mon, 28 Nov 2022 01:07:19 -0500=0ASubject: [P=
ATCH 04/11] Now my program can send the file if it exists and send=0A 404 N=
ot Found when it doesn't.=0A=0A---=0A part1/http-server.c | 42 ++++++++++++=
+++++++++++++++---------------=0A 1 file changed, 27 insertions(+), 15 dele=
tions(-)=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Ainde=
x f4afac9..eb9a728 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-se=
rver.c=0A@@ -32,7 +32,7 @@ int main(int argc, char **argv)=0A         usage=
_and_exit(argv[0]);=0A =0A     char *server_port =3D argv[1];=0A-    //char=
 *web_root =3D argv[2];=0A+    char *web_root =3D argv[2];=0A =0A =0A     /=
*=0A@@ -137,8 +137,8 @@ int main(int argc, char **argv)=0A         // If th=
e request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A    =
     if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =
=3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A             fpr=
intf(clnt_w,=0A-                "HTTP/1.0 501 Not Implemented\n\n"=0A-     =
           "<html><body><h1>501 Not Implemented</h1></body></html>\n");=0A+=
                "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+                "=
<html><body><h1>501 Not Implemented</h1></body></html>");=0A             fc=
lose(clnt_r);=0A             fclose(clnt_w);=0A             continue;=0A@@ =
-147,30 +147,40 @@ int main(int argc, char **argv)=0A         // If URI doe=
sn't start with '/' or there exists '..' in the URI=0A         if (strncmp(=
"/", requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A    =
         fprintf(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\n\n"=
=0A-                "<html><body><h1>400 Bad Request</h1></body></html>\n")=
;=0A+                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                =
"<html><body><h1>400 Bad Request</h1></body></html>");=0A             fclos=
e(clnt_r);=0A             fclose(clnt_w);=0A             continue;=0A      =
   }=0A =0A-        fprintf(stderr,=0A-            "This is method: %s\n"=
=0A-            "This is requestURI: %s\n"=0A-            "This is httpVers=
ion: %s\n"=0A-             ,method, requestURI, httpVersion);=0A-=0A       =
  /*=0A         * Read from the file, and write out to file_name.=0A       =
  */=0A-=0A+        =0A+        char filename[1000] =3D {0};=0A+        =0A=
+        strcpy(filename, web_root);=0A+        strcat(filename, requestURI=
);=0A+        =0A+        printf("%s\n", filename);        =0A         // O=
pen up file_name for reading.=0A-        FILE *file =3D fopen("file.txt", "=
rb");=0A-        if(file =3D=3D NULL)=0A-            die("fopen");=0A+     =
   FILE *file =3D fopen(filename, "rb");=0A+        if(file =3D=3D NULL){=
=0A+            printf("File is not found\n");=0A+            fprintf(clnt_=
w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                    "<html><body><h1=
>404 Not Found</h1></body></html>");=0A+            fclose(clnt_w);=0A+    =
        fclose(clnt_r);=0A+            continue;=0A+        }=0A =0A       =
  char buf2[BUF_SIZE];=0A+       =0A         // Switch to fread()/fwrite() =
so that we can download binary files.=0A+=0A+        fprintf(clnt_w, "HTTP/=
1.0 200 OK\r\n\r\n");=0A+=0A         size_t n;=0A         while ((n =3D fre=
ad(buf2, 1, sizeof(buf2), file)) > 0) {=0A             if (fwrite(buf2, 1, =
n, clnt_w) !=3D n) {=0A@@ -189,6 +199,8 @@ int main(int argc, char **argv)=
=0A             exit(1);=0A         }=0A =0A+    =0A+=0A         // Close F=
ILE * for output file.=0A         if (fclose(file))=0A             die("clo=
se");=0A-- =0A2.34.1=0A=0A=0AFrom 9b98287beb7a42cd036eb343094128d736ca56df =
Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: =
Mon, 28 Nov 2022 02:34:29 -0500=0ASubject: [PATCH 05/11] Now I can send 301=
 Moved Permanently responses!=0A=0A---=0A part1/http-server.c | 28 ++++++++=
++++++++++++++++----=0A 1 file changed, 24 insertions(+), 4 deletions(-)=0A=
=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Aindex eb9a728..=
1c12a49 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=0A@@=
 -6,6 +6,7 @@=0A #include <string.h>=0A #include <sys/socket.h>=0A #include=
 <sys/types.h>=0A+#include <sys/stat.h>=0A #include <unistd.h>=0A =0A #defi=
ne BUF_SIZE 4096=0A@@ -153,7 +154,11 @@ int main(int argc, char **argv)=0A =
            fclose(clnt_w);=0A             continue;=0A         }=0A-=0A+  =
      =0A+        // If URI ends with '/', append "index.html" to the URI =
=0A+        if (strlen(requestURI) > 0 && *(requestURI + strlen(requestURI)=
 - 1)  =3D=3D '/'){=0A+            strcat(requestURI, "index.html");=0A+   =
     }=0A         /*=0A         * Read from the file, and write out to file=
_name.=0A         */=0A@@ -162,12 +167,27 @@ int main(int argc, char **argv=
)=0A         =0A         strcpy(filename, web_root);=0A         strcat(file=
name, requestURI);=0A-        =0A-        printf("%s\n", filename);        =
=0A+=0A+        printf("Filename is: %s\n", filename);=0A+=0A+        struc=
t stat st;=0A+        if (stat(filename, &st) =3D=3D 0 && S_ISDIR(st.st_mod=
e)) {=0A+            printf("Path is a directory!\n");=0A+            fprin=
tf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=0A+                    "Loc=
ation: %s/\r\n\r\n"=0A+                    "<html><body>\r\n"=0A+          =
          "<h1>301 Moved Permanently</h1>\r\n"=0A+                    "<p>T=
he document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+             =
       "</body></html>", requestURI, requestURI);=0A+            fclose(cln=
t_w);=0A+            fclose(clnt_r);=0A+            continue;=0A+        }=
=0A+=0A         // Open up file_name for reading.=0A         FILE *file =3D=
 fopen(filename, "rb");=0A         if(file =3D=3D NULL){=0A-            pri=
ntf("File is not found\n");=0A+            printf("File is not found!\n");=
=0A             fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A        =
             "<html><body><h1>404 Not Found</h1></body></html>");=0A       =
      fclose(clnt_w);=0A-- =0A2.34.1=0A=0A=0AFrom 857918bf62df7d94d34eae5f4=
ecb64a8f9650c27 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columb=
ia.edu>=0ADate: Tue, 29 Nov 2022 05:18:47 -0500=0ASubject: [PATCH 06/11] Ma=
de a lot of changes, seperated the for loop and=0A client handling, also at=
tempted to make sure there is no memory leak, but I=0A have to spend more t=
ime on that.=0A=0A---=0A part1/http-server.c | 349 ++++++++++++++++++++++--=
--------------------=0A 1 file changed, 175 insertions(+), 174 deletions(-)=
=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Aindex 1c12a4=
9..cf244f2 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=
=0A@@ -8,6 +8,7 @@=0A #include <sys/types.h>=0A #include <sys/stat.h>=0A #i=
nclude <unistd.h>=0A+#include <signal.h>=0A =0A #define BUF_SIZE 4096=0A st=
atic void die(const char *msg)=0A@@ -23,8 +24,176 @@ static void usage_and_=
exit(char *argv0)=0A     exit(1);=0A }=0A =0A+static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A+        =0A+    FILE *clnt_=
r =3D fdopen(clnt_fd, "rb");=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "=
wb");=0A+     =0A+    /*=0A+     * Receive the HTTP response.=0A+     */=0A=
+        =0A+    char buf[BUF_SIZE];=0A+=0A+    // Read the first line=0A+ =
   if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A+        fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A+        fclose(cln=
t_r); //if(fclose(clnt_r)){die("close");}=0A+        fclose(clnt_w);=0A+   =
     return;=0A+    }=0A+=0A+    // If the initial request line is not comp=
lete=0A+    if(buf[strlen(buf)-1] !=3D '\n'){=0A+        fprintf(stderr, "C=
lient connection terminated prematurely.\n");=0A+        fclose(clnt_r);=0A=
+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A+=0A+    char *t=
oken_separators =3D "\t \r\n"; // tab, space, new line=0A+    char *method =
=3D strtok(buf, token_separators);=0A+    char *requestURI =3D strtok(NULL,=
 token_separators);=0A+    char *httpVersion =3D strtok(NULL, token_separat=
ors);=0A+        =0A+        //fprintf(stderr,"%s \"%s %s %s\" ", inet_ntoa=
(clnt_addr.sin_addr), method, requestURI, httpVersion);=0A+=0A+     =0A+   =
         =0A+    fprintf(stderr, "This is method: %s\n"=0A+            "Thi=
s is requestURI: %s\n"=0A+            "This is httpVersion: %s\n"=0A+      =
      ,method, requestURI, httpVersion);=0A+  =0A+=0A+    // If the request=
 is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A+    if (strc=
mp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=3D 0 || s=
trcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+        fprintf(clnt_w,=0A+ =
           "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+            "<html><bo=
dy><h1>501 Not Implemented</h1></body></html>");=0A+        fprintf(stderr,=
 "%s \"%s %s %s\" 501 Not Implemented\n",=0A+                ip_address, me=
thod, requestURI, httpVersion);=0A+        fclose(clnt_r);=0A+        fclos=
e(clnt_w);=0A+        return;=0A+    }=0A+        =0A+    // If URI doesn't=
 start with '/' or there exists '..' in the URI=0A+    if (strncmp("/", req=
uestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A+        fpr=
intf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><=
body><h1>400 Bad Request</h1></body></html>");=0A+        fprintf(stderr, "=
%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, method, =
requestURI, httpVersion);=0A+        fclose(clnt_r);=0A+        fclose(clnt=
_w);=0A+        return;=0A+    }=0A+        =0A+        // If URI ends with=
 /, append index.html=0A+    if (strlen(requestURI) > 0 && (*(requestURI + =
strlen(requestURI) - 1))  =3D=3D '/'){=0A+            =0A+        fprintf(s=
tderr, "This is after appending: %s\n",requestURI);=0A+        fprintf(stde=
rr, "This is httpVersion: %s\n", httpVersion);=0A+        strcat(requestURI=
, "index.html");=0A+    }=0A+        =0A+        /*=0A+        * Read from =
the file, and write out to file_name.=0A+        */=0A+        =0A+        =
// char *filename; [strlen(web_root + strlen(requestURI)) + 1];=0A+        =
=0A+    strcat(web_root, requestURI);=0A+=0A+    fprintf(stderr, "Filename =
is: %s\n", web_root);=0A+=0A+    struct stat st;=0A+    if (stat(web_root, =
&st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+        printf("Path is a direct=
ory!\n");=0A+        fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=
=0A+                "Location: %s/\r\n\r\n"=0A+                "<html><body=
>\r\n"=0A+                "<h1>301 Moved Permanently</h1>\r\n"=0A+         =
       "<p>The document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A+ =
               "</body></html>", requestURI, requestURI);=0A+        fprint=
f(stderr, "%s \"%s %s %s\" 301 Moved Permanently\n",=0A+                ip_=
address, method, requestURI, httpVersion);=0A+        fclose(clnt_w);=0A+  =
      fclose(clnt_r);=0A+        *(web_root + strlen(web_root) - strlen(req=
uestURI)) =3D '\0';=0A+        return; =0A+    }=0A+=0A+    // Open up file=
_name for reading.=0A+    FILE *file =3D fopen(web_root, "rb");=0A+    if(f=
ile =3D=3D NULL){=0A+        fprintf(stderr, "File is not found!\n");=0A+  =
      fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                "=
<html><body><h1>404 Not Found</h1></body></html>");=0A+        fprintf(stde=
rr, "This is URI: %s\n", requestURI);=0A+        fprintf(stderr, "This is h=
ttpVersion: %s\n", httpVersion);=0A+        fprintf(stderr, "%s \"%s %s %s\=
" 404 Not Found\n",=0A+                ip_address, method, requestURI, http=
Version);=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        =
*(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        re=
turn;=0A+    }=0A+=0A+    // Bring back web_root to its original content=0A=
+    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+    =
    =0A+    char buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() =
so that we can upload binary files.=0A+=0A+    fprintf(clnt_w, "HTTP/1.0 20=
0 OK\r\n\r\n");=0A+    fprintf(stderr, "%s \"%s %s %s\" 200 OK\n",=0A+     =
       ip_address, method, requestURI, httpVersion);=0A+    size_t n;=0A+  =
  while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A+        if (f=
write(buf2, 1, n, clnt_w) !=3D n) {=0A+            fprintf(stderr, "Encount=
ered error while writing to client\n");=0A+            exit(1);=0A+        =
}=0A+    }=0A+=0A+    /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    =
// fread() returns 0 on EOF or on error, so we need to check for errors.=0A=
+    if (ferror(file)) {=0A+        fprintf(stderr, "Encountered error read=
ing from file.\n");=0A+        exit(1);=0A+    } =0A+=0A+    // Close FILE =
* for output file.=0A+    if (fclose(file))=0A+        die("close");       =
=0A+=0A+    // Close client connection.=0A+    fclose(clnt_r);=0A+    fclos=
e(clnt_w);=0A+=0A+    // Resume server loop to handle next client connectio=
n.=0A+    return;=0A+}=0A+=0A+=0A+=0A int main(int argc, char **argv)=0A {=
=0A+=0A+    struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));        =
 // Zero-initialize sigaction structure=0A+    sigemptyset(&sa.sa_mask);   =
        // Don't mask any signals=0A+    sa.sa_handler =3D SIG_IGN;        =
    // Ignore the signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+ =
       die("sigaction");=0A+=0A     /*=0A      * Parse arguments and determ=
ine output file name.=0A      */=0A@@ -92,182 +261,14 @@ int main(int argc,=
 char **argv)=0A                              &clnt_addr_len);=0A         i=
f (clnt_fd < 0)=0A             die("accept");=0A-=0A-        // clnt_addr i=
s now populated with information about the client.=0A-        fprintf(stder=
r, "Accepted connection from %s\n",=0A-                inet_ntoa(clnt_addr.=
sin_addr));=0A-=0A-        FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A-     =
   FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A-        =0A-        /*=
=0A-         * Receive the HTTP response.=0A-         */=0A-        =0A-   =
     char buf[BUF_SIZE];=0A-=0A-        // Read the first line=0A-        i=
f (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {=0A-            fprintf(st=
derr, "Client connection terminated prematurely.\n");=0A-            fclose=
(clnt_r); //if(fclose(clnt_r)){die("close");}=0A-            fclose(clnt_w)=
;=0A-            continue;=0A-        }=0A-=0A-        // If the initial re=
quest line is not complete=0A-        if(buf[strlen(buf)-1] !=3D '\n'){=0A-=
            fprintf(stderr, "Client connection terminated prematurely.\n");=
=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-         =
   continue;=0A-        }=0A-=0A-=0A-        char *token_separators =3D "\t=
 \r\n"; // tab, space, new line=0A-        char *method =3D strtok(buf, tok=
en_separators);=0A-        char *requestURI =3D strtok(NULL, token_separato=
rs);=0A-        char *httpVersion =3D strtok(NULL, token_separators);=0A-  =
      =0A-        fprintf(stderr,=0A-            "This is method: %s\n"=0A-=
            "This is requestURI: %s\n"=0A-            "This is httpVersion:=
 %s\n"=0A-            ,method, requestURI, httpVersion);=0A-  =0A-=0A-     =
   // If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP=
/1.1=0A-        if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", ht=
tpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-    =
        fprintf(clnt_w,=0A-                "HTTP/1.0 501 Not Implemented\r\=
n\r\n"=0A-                "<html><body><h1>501 Not Implemented</h1></body><=
/html>");=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-=
            continue;=0A-        }=0A         =0A-        // If URI doesn't=
 start with '/' or there exists '..' in the URI=0A-        if (strncmp("/",=
 requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL ) {=0A-       =
     fprintf(clnt_w,=0A-                "HTTP/1.0 400 Bad Request\r\n\r\n"=
=0A-                "<html><body><h1>400 Bad Request</h1></body></html>");=
=0A-            fclose(clnt_r);=0A-            fclose(clnt_w);=0A-         =
   continue;=0A-        }=0A-        =0A-        // If URI ends with '/', a=
ppend "index.html" to the URI =0A-        if (strlen(requestURI) > 0 && *(r=
equestURI + strlen(requestURI) - 1)  =3D=3D '/'){=0A-            strcat(req=
uestURI, "index.html");=0A-        }=0A-        /*=0A-        * Read from t=
he file, and write out to file_name.=0A-        */=0A-        =0A-        c=
har filename[1000] =3D {0};=0A-        =0A-        strcpy(filename, web_roo=
t);=0A-        strcat(filename, requestURI);=0A-=0A-        printf("Filenam=
e is: %s\n", filename);=0A-=0A-        struct stat st;=0A-        if (stat(=
filename, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-            printf("Pa=
th is a directory!\n");=0A-            fprintf(clnt_w, "HTTP/1.0 301 Moved =
Permanently\r\n"=0A-                    "Location: %s/\r\n\r\n"=0A-        =
            "<html><body>\r\n"=0A-                    "<h1>301 Moved Perman=
ently</h1>\r\n"=0A-                    "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A-                    "</body></html>", requ=
estURI, requestURI);=0A-            fclose(clnt_w);=0A-            fclose(c=
lnt_r);=0A-            continue;=0A-        }=0A-=0A-        // Open up fil=
e_name for reading.=0A-        FILE *file =3D fopen(filename, "rb");=0A-   =
     if(file =3D=3D NULL){=0A-            printf("File is not found!\n");=
=0A-            fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A-       =
             "<html><body><h1>404 Not Found</h1></body></html>");=0A-      =
      fclose(clnt_w);=0A-            fclose(clnt_r);=0A-            continu=
e;=0A-        }=0A-=0A-        char buf2[BUF_SIZE];=0A-       =0A-        /=
/ Switch to fread()/fwrite() so that we can download binary files.=0A-=0A- =
       fprintf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=0A-=0A-        size_t n;=
=0A-        while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A-   =
         if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A-                fprint=
f(stderr, "Encountered error writing to client\n");=0A-                exit=
(1);=0A-            }=0A-        }=0A-=0A-        /*=0A-        * All done,=
 clean up.=0A-        */=0A-=0A-        // fread() returns 0 on EOF or on e=
rror, so we need to check for errors.=0A-        if (ferror(file)) {=0A-   =
         fprintf(stderr, "Encountered error reading from file.\n");=0A-    =
        exit(1);=0A-        }=0A-=0A-    =0A-=0A-        // Close FILE * fo=
r output file.=0A-        if (fclose(file))=0A-            die("close");=0A=
-=0A-        /*        =0A-         * Handle client connection.=0A-        =
=0A-=0A-        // Keep track of how many bytes we've received.=0A-        =
size_t recv_len =3D 0;=0A-=0A-        int len;=0A-        char buf[32];=0A-=
=0A-        // recv() is like read(), except there's an extra flags argumen=
t.=0A-        //=0A-        // Since we didn't pass any flags to recv(), th=
is is equivalent to=0A-        // read(clnt_fd, buf, sizeof(buf)).=0A-     =
   if ((len =3D recv(clnt_fd, buf, sizeof(buf), 0)) < 0)=0A-            die=
("recv");=0A-=0A-        while (len > 0) {=0A-            // Book-keeping.=
=0A-            recv_len +=3D len;=0A-=0A-            // send() is like wri=
te(), except there's an extra flags argument.=0A-            //=0A-        =
    // Since we didn't pass any flags to send(), this is equivalent to=0A- =
           // write(clnt_fd, buf, len).=0A-            if (send(clnt_fd, bu=
f, len, 0) !=3D len)=0A-                die("send");=0A-=0A-            // =
recv() might not have read everything the client sent, so we need=0A-      =
      // to continue recv()ing.=0A-            if ((len =3D recv(clnt_fd, b=
uf, sizeof(buf), 0)) < 0)=0A-                die("recv");=0A-        }=0A-=
=0A-        fprintf(stderr, "Received (and sent) %lu bytes in total\n", rec=
v_len);=0A-=0A-        */=0A-=0A-        // Close client connection.=0A-   =
     fclose(clnt_r);=0A-        fclose(clnt_w);=0A+        char *ip_address=
 =3D inet_ntoa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr=
 is now populated with information about the client.=0A+        fprintf(std=
err, "Accepted connection from %s\n",ip_address);=0A =0A-        // Resume =
server loop to handle next client connection.=0A+        handle_client(clnt=
_fd, web_root, ip_address);=0A+          =0A     }=0A =0A     /*=0A-- =0A2.=
34.1=0A=0A=0AFrom 5cd456888b99ea776f7f019a7194cb937fff0ad6 Mon Sep 17 00:00=
:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 2022=
 05:53:07 -0500=0ASubject: [PATCH 07/11] I noticed a mistake. I had assumed=
 that we won't be=0A given header lines, but that's not correct. So, I gene=
ralized it. Now it can=0A handle multiple header lines.=0A=0A---=0A part1/h=
ttp-server.c | 118 ++++++++++++++++++++++++++++----------------=0A 1 file c=
hanged, 75 insertions(+), 43 deletions(-)=0A=0Adiff --git a/part1/http-serv=
er.c b/part1/http-server.c=0Aindex cf244f2..f1194ac 100644=0A--- a/part1/ht=
tp-server.c=0A+++ b/part1/http-server.c=0A@@ -11,6 +11,7 @@=0A #include <si=
gnal.h>=0A =0A #define BUF_SIZE 4096=0A+=0A static void die(const char *msg=
)=0A {=0A     perror(msg);=0A@@ -29,51 +30,88 @@ static void handle_client(=
int clnt_fd, char *web_root, char *ip_address){=0A     FILE *clnt_r =3D fdo=
pen(clnt_fd, "rb");=0A     FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A =
     =0A-    /*=0A+     /*=0A      * Receive the HTTP response.=0A      */=
=0A-        =0A+    =0A+    char *method =3D NULL;=0A+    char *requestURI =
=3D NULL;=0A+    char *httpVersion =3D NULL;    =0A+    char *token_separat=
ors =3D "\t \r\n"; // tab, space, new line=0A+   =0A     char buf[BUF_SIZE]=
;=0A =0A     // Read the first line=0A-    if (fgets(buf, sizeof(buf), clnt=
_r) =3D=3D NULL) {=0A-        fprintf(stderr, "Client connection terminated=
 prematurely.\n");=0A+    if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) =
{       =0A+        method =3D strtok(buf, token_separators);=0A+        re=
questURI =3D strtok(NULL, token_separators);=0A+        httpVersion =3D str=
tok(NULL, token_separators);=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 B=
ad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1=
></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad =
Request\n",=0A+                ip_address, method, requestURI, httpVersion)=
;=0A+=0A+        fprintf(stderr, "Client connection terminated prematurely =
by the first if.\n");=0A+        buf[0] =3D '\0';=0A         fclose(clnt_r)=
; //if(fclose(clnt_r)){die("close");}=0A         fclose(clnt_w);=0A        =
 return;=0A     }=0A =0A-    // If the initial request line is not complete=
=0A-    if(buf[strlen(buf)-1] !=3D '\n'){=0A-        fprintf(stderr, "Clien=
t connection terminated prematurely.\n");=0A+    method =3D strtok(buf, tok=
en_separators);=0A+    requestURI =3D strtok(NULL, token_separators);=0A+  =
  httpVersion =3D strtok(NULL, token_separators);=0A+    char * extra =3D s=
trtok(NULL, token_separators);=0A+=0A+    fprintf(stderr, "%s \"%s %s %s\" =
", ip_address, method, requestURI, httpVersion);=0A+=0A+=0A+  // If the ini=
tial request line is not complete or there is an extra word at the end=0A+ =
   if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NU=
LL || extra !=3D NULL){=0A+       =0A+        fprintf(clnt_w, "HTTP/1.0 400=
 Bad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</=
h1></body></html>\r\n");=0A+        fprintf(stderr, "400 Bad Request\n");=
=0A+=0A+        fprintf(stderr, "Client connection terminated prematurely b=
y the third if.\n");=0A+        buf[0] =3D 0; =0A         fclose(clnt_r);=
=0A         fclose(clnt_w);=0A         return;=0A     }=0A =0A+    char buf=
3[BUF_SIZE];=0A =0A-    char *token_separators =3D "\t \r\n"; // tab, space=
, new line=0A-    char *method =3D strtok(buf, token_separators);=0A-    ch=
ar *requestURI =3D strtok(NULL, token_separators);=0A-    char *httpVersion=
 =3D strtok(NULL, token_separators);=0A-        =0A-        //fprintf(stder=
r,"%s \"%s %s %s\" ", inet_ntoa(clnt_addr.sin_addr), method, requestURI, ht=
tpVersion);=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=
=3D NULL) {       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\=
n\r\n"=0A+                	    "<html><body><h1>400 Bad Request</h1></body>=
</html>\r\n");=0A+        	fprintf(stderr, "400 Bad Request\n");=0A =0A-   =
  =0A-            =0A-    fprintf(stderr, "This is method: %s\n"=0A-       =
     "This is requestURI: %s\n"=0A-            "This is httpVersion: %s\n"=
=0A-            ,method, requestURI, httpVersion);=0A+        	fprintf(stde=
rr, "There was an issue with header lines\n");=0A+        	buf[0] =3D 0;=0A=
+        	fclose(clnt_r);=0A+        	fclose(clnt_w);=0A+        	return;=
=0A+    	}=0A+=0A+=0A+	if(strlen(buf3) <=3D 2  && buf3[strlen(buf3)-1] =3D=
=3D '\n' )=0A+ 		break;=0A+=0A+    }=0A+=0A+    //From this point on, we ca=
n assume that HTTP request has correct structure=0A   =0A =0A     // If the=
 request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=0A     =
if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersion) =3D=
=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A         fprintf(cl=
nt_w,=0A             "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-            =
"<html><body><h1>501 Not Implemented</h1></body></html>");=0A-        fprin=
tf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",=0A-                ip_a=
ddress, method, requestURI, httpVersion);=0A+            "<html><body><h1>5=
01 Not Implemented</h1></body></html>\r\n");=0A+        fprintf(stderr, "50=
1 Not Implemented\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=
=0A         fclose(clnt_w);=0A         return;=0A@@ -82,21 +120,18 @@ stati=
c void handle_client(int clnt_fd, char *web_root, char *ip_address){=0A    =
 // If URI doesn't start with '/' or there exists '..' in the URI=0A     if=
 (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "..") !=3D NULL =
) {=0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-      =
          "<html><body><h1>400 Bad Request</h1></body></html>");=0A-       =
 fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip=
_address, method, requestURI, httpVersion);=0A+                "<html><body=
><h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "=
400 Bad Request\n");=0A+        buf[0] =3D 0;=0A         fclose(clnt_r);=0A=
         fclose(clnt_w);=0A         return;=0A     }=0A         =0A        =
 // If URI ends with /, append index.html=0A-    if (strlen(requestURI) > 0=
 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/'){=0A-            =
=0A-        fprintf(stderr, "This is after appending: %s\n",requestURI);=0A=
-        fprintf(stderr, "This is httpVersion: %s\n", httpVersion);=0A+    =
if (strlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=
=3D '/')         =0A         strcat(requestURI, "index.html");=0A-    }=0A+=
  =0A         =0A         /*=0A         * Read from the file, and write out=
 to file_name.=0A@@ -106,38 +141,34 @@ static void handle_client(int clnt_f=
d, char *web_root, char *ip_address){=0A         =0A     strcat(web_root, r=
equestURI);=0A =0A-    fprintf(stderr, "Filename is: %s\n", web_root);=0A+ =
   // fprintf(stderr, "Filename is: %s\n", web_root);=0A =0A     struct sta=
t st;=0A     if (stat(web_root, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A-=
        printf("Path is a directory!\n");=0A         fprintf(clnt_w, "HTTP/=
1.0 301 Moved Permanently\r\n"=0A                 "Location: %s/\r\n\r\n"=
=0A                 "<html><body>\r\n"=0A                 "<h1>301 Moved Pe=
rmanently</h1>\r\n"=0A                 "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A-                "</body></html>", requestU=
RI, requestURI);=0A-        fprintf(stderr, "%s \"%s %s %s\" 301 Moved Perm=
anently\n",=0A-                ip_address, method, requestURI, httpVersion)=
;=0A+                "</body></html>\r\n", requestURI, requestURI);=0A+    =
    fprintf(stderr, "301 Moved Permanently\n");=0A         fclose(clnt_w);=
=0A         fclose(clnt_r);=0A         *(web_root + strlen(web_root) - strl=
en(requestURI)) =3D '\0';=0A+        buf[0] =3D 0;=0A         return; =0A  =
   }=0A =0A     // Open up file_name for reading.=0A     FILE *file =3D fop=
en(web_root, "rb");=0A     if(file =3D=3D NULL){=0A-        fprintf(stderr,=
 "File is not found!\n");=0A         fprintf(clnt_w, "HTTP/1.0 404 Not Foun=
d\r\n\r\n"=0A-                "<html><body><h1>404 Not Found</h1></body></h=
tml>");=0A-        fprintf(stderr, "This is URI: %s\n", requestURI);=0A-   =
     fprintf(stderr, "This is httpVersion: %s\n", httpVersion);=0A-        =
fprintf(stderr, "%s \"%s %s %s\" 404 Not Found\n",=0A-                ip_ad=
dress, method, requestURI, httpVersion);=0A+                "<html><body><h=
1>404 Not Found</h1></body></html>\r\n");=0A+        fprintf(stderr, "404 N=
ot Found\n");=0A         fclose(clnt_w);=0A         fclose(clnt_r);=0A     =
    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+      =
  buf[0] =3D 0;=0A         return;=0A     }=0A =0A@@ -149,8 +180,7 @@ stati=
c void handle_client(int clnt_fd, char *web_root, char *ip_address){=0A    =
 // Use fread()/fwrite() so that we can upload binary files.=0A =0A     fpr=
intf(clnt_w, "HTTP/1.0 200 OK\r\n\r\n");=0A-    fprintf(stderr, "%s \"%s %s=
 %s\" 200 OK\n",=0A-            ip_address, method, requestURI, httpVersion=
);=0A+    fprintf(stderr, "200 OK\n");=0A     size_t n;=0A     while ((n =
=3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A         if (fwrite(buf2, =
1, n, clnt_w) !=3D n) {=0A@@ -163,6 +193,8 @@ static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A     * All done, clean up.=
=0A     */=0A =0A+    buf[0] =3D 0;=0A+=0A     // fread() returns 0 on EOF =
or on error, so we need to check for errors.=0A     if (ferror(file)) {=0A =
        fprintf(stderr, "Encountered error reading from file.\n");=0A-- =0A=
2.34.1=0A=0A=0AFrom 37a926a43a69c46eadf0385c722c246aa7e03832 Mon Sep 17 00:=
00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 30 Nov 20=
22 18:26:54 -0500=0ASubject: [PATCH 08/11] Wrote part2, but will probably n=
eed some changes.=0A=0A---=0A part1/http-server.c       |  96 ++++++-----=
=0A part2/Makefile            |  16 ++=0A part2/multi-http-server.c | 354 +=
+++++++++++++++++++++++++++++++++++++=0A 3 files changed, 423 insertions(+)=
, 43 deletions(-)=0A create mode 100644 part2/Makefile=0A create mode 10064=
4 part2/multi-http-server.c=0A=0Adiff --git a/part1/http-server.c b/part1/h=
ttp-server.c=0Aindex f1194ac..3e500eb 100644=0A--- a/part1/http-server.c=0A=
+++ b/part1/http-server.c=0A@@ -41,7 +41,8 @@ static void handle_client(int=
 clnt_fd, char *web_root, char *ip_address){=0A    =0A     char buf[BUF_SIZ=
E];=0A =0A-    // Read the first line=0A+    // Read the first line CHECK I=
F IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTER THIS=0A  =
   if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A         met=
hod =3D strtok(buf, token_separators);=0A         requestURI =3D strtok(NUL=
L, token_separators);=0A@@ -64,15 +65,14 @@ static void handle_client(int c=
lnt_fd, char *web_root, char *ip_address){=0A     httpVersion =3D strtok(NU=
LL, token_separators);=0A     char * extra =3D strtok(NULL, token_separator=
s);=0A =0A-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, requ=
estURI, httpVersion);=0A-=0A =0A-  // If the initial request line is not co=
mplete or there is an extra word at the end=0A+    // If the initial reques=
t line is not complete or there is an extra word at the end=0A     if(metho=
d =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL || extra=
 !=3D NULL){=0A        =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Reques=
t\r\n\r\n"=0A                 "<html><body><h1>400 Bad Request</h1></body><=
/html>\r\n");=0A-        fprintf(stderr, "400 Bad Request\n");=0A+        f=
printf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_a=
ddress, method, requestURI, httpVersion);=0A =0A         fprintf(stderr, "C=
lient connection terminated prematurely by the third if.\n");=0A         bu=
f[0] =3D 0; =0A@@ -81,13 +81,39 @@ static void handle_client(int clnt_fd, c=
har *web_root, char *ip_address){=0A         return;=0A     }=0A =0A+    //=
 If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=
=0A+    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersio=
n) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A+        fpri=
ntf(clnt_w,=0A+            "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A+      =
      "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");=0A+   =
     fprintf(stderr, "%s \"%s %s %s\" 501 Not Implemented\n",=0A+          =
     ip_address, method, requestURI, httpVersion);=0A+        buf[0] =3D 0;=
=0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        return;=
=0A+    }=0A+        =0A+    // If URI doesn't start with '/' or there exis=
ts '..' in the URI=0A+    if (strncmp("/", requestURI, 1) !=3D 0 || strstr(=
requestURI, "/..") !=3D NULL ) {=0A+        fprintf(clnt_w, "HTTP/1.0 400 B=
ad Request\r\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1=
></body></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad =
Request\n",=0A+                ip_address, method, requestURI, httpVersion)=
;=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(cln=
t_w);=0A+        return;=0A+    }=0A+=0A     char buf3[BUF_SIZE];=0A =0A   =
  while(1){=0A 	 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {      =
 =0A        		fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A        =
         	    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A=
-        	fprintf(stderr, "400 Bad Request\n");=0A+        	fprintf(stderr,=
 "%s \"%s %s %s\" 400 Bad Request\n",=0A+                        ip_address=
, method, requestURI, httpVersion);=0A =0A         	fprintf(stderr, "There =
was an issue with header lines\n");=0A         	buf[0] =3D 0;=0A@@ -104,31 =
+130,10 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_=
address){=0A =0A     //From this point on, we can assume that HTTP request =
has correct structure=0A   =0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_a=
ddress, method, requestURI, httpVersion);=0A+    buf[0] =3D 0;=0A =0A-    /=
/ If the request is not GET or the HTTP version is not HTTP/1.0 or HTTP/1.1=
=0A-    if (strcmp("GET", method) !=3D 0 || !(strcmp("HTTP/1.0", httpVersio=
n) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=3D 0)) {=0A-        fpri=
ntf(clnt_w,=0A-            "HTTP/1.0 501 Not Implemented\r\n\r\n"=0A-      =
      "<html><body><h1>501 Not Implemented</h1></body></html>\r\n");=0A-   =
     fprintf(stderr, "501 Not Implemented\n");=0A-        buf[0] =3D 0;=0A-=
        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-        return;=0A-  =
  }=0A-        =0A-    // If URI doesn't start with '/' or there exists '..=
' in the URI=0A-    if (strncmp("/", requestURI, 1) !=3D 0 || strstr(reques=
tURI, "..") !=3D NULL ) {=0A-        fprintf(clnt_w, "HTTP/1.0 400 Bad Requ=
est\r\n\r\n"=0A-                "<html><body><h1>400 Bad Request</h1></body=
></html>\r\n");=0A-        fprintf(stderr, "400 Bad Request\n");=0A-       =
 buf[0] =3D 0;=0A-        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-   =
     return;=0A-    }=0A-        =0A-        // If URI ends with /, append =
index.html=0A+    // If URI ends with /, append index.html=0A     if (strle=
n(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/') =
        =0A         strcat(requestURI, "index.html");=0A   =0A@@ -155,7 +16=
0,6 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_addr=
ess){=0A         fclose(clnt_w);=0A         fclose(clnt_r);=0A         *(we=
b_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A-        buf[0]=
 =3D 0;=0A         return; =0A     }=0A =0A@@ -168,7 +172,6 @@ static void =
handle_client(int clnt_fd, char *web_root, char *ip_address){=0A         fc=
lose(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root + strlen(web=
_root) - strlen(requestURI)) =3D '\0';=0A-        buf[0] =3D 0;=0A         =
return;=0A     }=0A =0A@@ -179,28 +182,35 @@ static void handle_client(int =
clnt_fd, char *web_root, char *ip_address){=0A        =0A     // Use fread(=
)/fwrite() so that we can upload binary files.=0A =0A+=0A     fprintf(clnt_=
w, "HTTP/1.0 200 OK\r\n\r\n");=0A     fprintf(stderr, "200 OK\n");=0A     s=
ize_t n;=0A-    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0) {=0A=
+    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(fil=
e)) ) {=0A         if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A-            =
fprintf(stderr, "Encountered error while writing to client\n");=0A-        =
    exit(1);=0A+            // Don't crash the server and move to the next =
client.=0A+            fclose(clnt_w);=0A+            fclose(clnt_r);=0A+  =
          perror("send bytes to client");=0A+            return;=0A        =
 }=0A     }=0A =0A-    /*=0A-    * All done, clean up.=0A-    */=0A-=0A-   =
 buf[0] =3D 0;=0A =0A     // fread() returns 0 on EOF or on error, so we ne=
ed to check for errors.=0A     if (ferror(file)) {=0A-        fprintf(stder=
r, "Encountered error reading from file.\n");=0A-        exit(1);=0A+      =
  // Don't crash the server and move to the next client.=0A+        fclose(=
clnt_w);=0A+        fclose(clnt_r);=0A+        perror("read from the file r=
equested");=0A+        return;=0A     } =0A =0A+=0A+    /*=0A+    * All don=
e, clean up.=0A+    */=0A+=0A     // Close FILE * for output file.=0A     i=
f (fclose(file))=0A         die("close");       =0A@@ -297,7 +307,7 @@ int =
main(int argc, char **argv)=0A         char *ip_address =3D inet_ntoa(clnt_=
addr.sin_addr);=0A             =0A         // clnt_addr is now populated wi=
th information about the client.=0A-        fprintf(stderr, "Accepted conne=
ction from %s\n",ip_address);=0A+        //fprintf(stderr, "Accepted connec=
tion from %s\n",ip_address);=0A =0A         handle_client(clnt_fd, web_root=
, ip_address);=0A           =0Adiff --git a/part2/Makefile b/part2/Makefile=
=0Anew file mode 100644=0Aindex 0000000..9be1e81=0A--- /dev/null=0A+++ b/pa=
rt2/Makefile=0A@@ -0,0 +1,16 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpeda=
ntic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+.PHONY: default=0A+defa=
ult: multi-http-server=0A+=0A+http-server:=0A+=0A+.PHONY: clean=0A+clean:=
=0A+	rm -rf a.out *.o multi-http-server=0A+=0A+.PHONY: all=0A+all: clean mu=
lti-http-server=0Adiff --git a/part2/multi-http-server.c b/part2/multi-http=
-server.c=0Anew file mode 100644=0Aindex 0000000..929e9f7=0A--- /dev/null=
=0A+++ b/part2/multi-http-server.c=0A@@ -0,0 +1,354 @@=0A+#define _GNU_SOUR=
CE=0A+#include <arpa/inet.h>=0A+#include <netdb.h>=0A+#include <stdio.h>=0A=
+#include <stdlib.h>=0A+#include <string.h>=0A+#include <sys/socket.h>=0A+#=
include <sys/types.h>=0A+#include <sys/stat.h>=0A+#include <unistd.h>=0A+#i=
nclude <signal.h>=0A+#include <sys/wait.h>=0A+=0A+#define BUF_SIZE 4096=0A+=
=0A+static void die(const char *msg)=0A+{=0A+    perror(msg);=0A+    exit(1=
);=0A+}=0A+=0A+static void usage_and_exit(char *argv0)=0A+{=0A+    fprintf(=
stderr, "usage: %s <server-port> <web-root>\n", argv0);=0A+    fprintf(stde=
rr, "   ex) %s 8888 ~/html\n", argv0);=0A+    exit(1);=0A+}=0A+=0A+void rea=
p_children(int sig){=0A+    while (waitpid(-1, NULL, WNOHANG) > 0)=0A+     =
   ;=0A+}=0A+=0A+static void handle_client(int clnt_fd, char *web_root, cha=
r *ip_address, pid_t pid){=0A+        =0A+    FILE *clnt_r =3D fdopen(clnt_=
fd, "rb");=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A+     =0A+=
     /*=0A+     * Receive the HTTP response.=0A+     */=0A+    =0A+    char=
 *method =3D NULL;=0A+    char *requestURI =3D NULL;=0A+    char *httpVersi=
on =3D NULL;    =0A+    char *token_separators =3D "\t \r\n"; // tab, space=
, new line=0A+   =0A+    char buf[BUF_SIZE];=0A+=0A+    // Read the first l=
ine CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A+    // CHECK AFTE=
R THIS=0A+    if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A+=
        method =3D strtok(buf, token_separators);=0A+        requestURI =3D=
 strtok(NULL, token_separators);=0A+        httpVersion =3D strtok(NULL, to=
ken_separators);=0A+=0A+        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r=
\n\r\n"=0A+                "<html><body><h1>400 Bad Request</h1></body></ht=
ml>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=
=0A+                ip_address, method, requestURI, httpVersion);=0A+=0A+  =
      fprintf(stderr, "Client connection terminated prematurely by the firs=
t if.\n");=0A+        buf[0] =3D '\0';=0A+        fclose(clnt_r); //if(fclo=
se(clnt_r)){die("close");}=0A+        fclose(clnt_w);=0A+        return;=0A=
+    }=0A+=0A+    method =3D strtok(buf, token_separators);=0A+    requestU=
RI =3D strtok(NULL, token_separators);=0A+    httpVersion =3D strtok(NULL, =
token_separators);=0A+    char * extra =3D strtok(NULL, token_separators);=
=0A+=0A+=0A+    // If the initial request line is not complete or there is =
an extra word at the end=0A+    if(method =3D=3D NULL || requestURI =3D=3D =
NULL || httpVersion =3D=3D NULL || extra !=3D NULL){=0A+       =0A+        =
fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<htm=
l><body><h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(st=
derr, "%s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, m=
ethod, requestURI, httpVersion);=0A+=0A+        fprintf(stderr, "Client con=
nection terminated prematurely by the third if.\n");=0A+        buf[0] =3D =
0; =0A+        fclose(clnt_r);=0A+        fclose(clnt_w);=0A+        return=
;=0A+    }=0A+=0A+    // If the request is not GET or the HTTP version is n=
ot HTTP/1.0 or HTTP/1.1=0A+    if (strcmp("GET", method) !=3D 0 || !(strcmp=
("HTTP/1.0", httpVersion) =3D=3D 0 || strcmp("HTTP/1.1", httpVersion) =3D=
=3D 0)) {=0A+        fprintf(clnt_w,=0A+            "HTTP/1.0 501 Not Imple=
mented\r\n\r\n"=0A+            "<html><body><h1>501 Not Implemented</h1></b=
ody></html>\r\n");=0A+        fprintf(stderr, "%s \"%s %s %s\" 501 Not Impl=
emented\n",=0A+               ip_address, method, requestURI, httpVersion);=
=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r);=0A+        fclose(clnt=
_w);=0A+        return;=0A+    }=0A+        =0A+    // If URI doesn't start=
 with '/' or there exists '..' in the URI=0A+    if (strncmp("/", requestUR=
I, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL ) {=0A+        fprintf(=
clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A+                "<html><body>=
<h1>400 Bad Request</h1></body></html>\r\n");=0A+        fprintf(stderr, "%=
s \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, method, r=
equestURI, httpVersion);=0A+        buf[0] =3D 0;=0A+        fclose(clnt_r)=
;=0A+        fclose(clnt_w);=0A+        return;=0A+    }=0A+=0A+    char bu=
f3[BUF_SIZE];=0A+=0A+    while(1){=0A+	 if (fgets(buf3, sizeof(buf3), clnt_=
r) =3D=3D NULL) {       =0A+       		fprintf(clnt_w, "HTTP/1.0 400 Bad Requ=
est\r\n\r\n"=0A+                	    "<html><body><h1>400 Bad Request</h1><=
/body></html>\r\n");=0A+        	fprintf(stderr, "%s \"%s %s %s\" 400 Bad R=
equest\n",=0A+                        ip_address, method, requestURI, httpV=
ersion);=0A+=0A+        	fprintf(stderr, "There was an issue with header li=
nes\n");=0A+        	buf[0] =3D 0;=0A+        	fclose(clnt_r);=0A+        	=
fclose(clnt_w);=0A+        	return;=0A+    	}=0A+=0A+=0A+	if(strlen(buf3) <=
=3D 2  && buf3[strlen(buf3)-1] =3D=3D '\n' )=0A+ 		break;=0A+=0A+    }=0A+=
=0A+    //From this point on, we can assume that HTTP request has correct s=
tructure=0A+  =0A+    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, metho=
d, requestURI, httpVersion);=0A+    buf[0] =3D 0;=0A+=0A+    // If URI ends=
 with /, append index.html=0A+    if (strlen(requestURI) > 0 && (*(requestU=
RI + strlen(requestURI) - 1))  =3D=3D '/')         =0A+        strcat(reque=
stURI, "index.html");=0A+  =0A+        =0A+        /*=0A+        * Read fro=
m the file, and write out to file_name.=0A+        */=0A+        =0A+      =
  // char *filename; [strlen(web_root + strlen(requestURI)) + 1];=0A+      =
  =0A+    strcat(web_root, requestURI);=0A+=0A+    // fprintf(stderr, "File=
name is: %s\n", web_root);=0A+=0A+    struct stat st;=0A+    if (stat(web_r=
oot, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+        fprintf(clnt_w, "HT=
TP/1.0 301 Moved Permanently\r\n"=0A+                "Location: %s/\r\n\r\n=
"=0A+                "<html><body>\r\n"=0A+                "<h1>301 Moved P=
ermanently</h1>\r\n"=0A+                "<p>The document has moved <a href=
=3D\"%s/\">here</a>.</p>\r\n"=0A+                "</body></html>\r\n", requ=
estURI, requestURI);=0A+        fprintf(stderr, "301 Moved Permanently\n");=
=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *(web_roo=
t + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        return; =0A=
+    }=0A+=0A+    // Open up file_name for reading.=0A+    FILE *file =3D f=
open(web_root, "rb");=0A+    if(file =3D=3D NULL){=0A+        fprintf(clnt_=
w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>404=
 Not Found</h1></body></html>\r\n");=0A+        fprintf(stderr, "404 Not Fo=
und\n");=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+        *=
(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0';=0A+        ret=
urn;=0A+    }=0A+=0A+    // Bring back web_root to its original content=0A+=
    *(web_root + strlen(web_root) - strlen(requestURI)) =3D '\0'; =0A+     =
   =0A+    char buf2[BUF_SIZE];=0A+       =0A+    // Use fread()/fwrite() s=
o that we can upload binary files.=0A+=0A+=0A+    fprintf(clnt_w, "HTTP/1.0=
 200 OK\r\n\r\n");=0A+    fprintf(stderr, "200 OK\n");=0A+    size_t n;=0A+=
    while ((n =3D fread(buf2, 1, sizeof(buf2), file)) > 0  && !(ferror(file=
)) ) {=0A+        if (fwrite(buf2, 1, n, clnt_w) !=3D n) {=0A+            /=
/ Don't crash the server and move to the next client.=0A+            fclose=
(clnt_w);=0A+            fclose(clnt_r);=0A+            perror("send bytes =
to client");=0A+            return;=0A+        }=0A+    }=0A+=0A+=0A+    //=
 fread() returns 0 on EOF or on error, so we need to check for errors.=0A+ =
   if (ferror(file)) {=0A+        // Don't crash the server and move to the=
 next client.=0A+        fclose(clnt_w);=0A+        fclose(clnt_r);=0A+    =
    perror("read from the file requested");=0A+        return;=0A+    } =0A=
+=0A+=0A+    /*=0A+    * All done, clean up.=0A+    */=0A+=0A+    // Close =
FILE * for output file.=0A+    if (fclose(file))=0A+        die("close");  =
     =0A+=0A+    // Close client connection.=0A+    fclose(clnt_r);=0A+    =
fclose(clnt_w);=0A+=0A+    // Resume server loop to handle next client conn=
ection.=0A+    return;=0A+}=0A+=0A+=0A+=0A+int main(int argc, char **argv)=
=0A+{=0A+=0A+    struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));   =
      // Zero-initialize sigaction structure=0A+    sigemptyset(&sa.sa_mask=
);           // Don't mask any signals=0A+    sa.sa_handler =3D SIG_IGN;   =
         // Ignore the signal=0A+=0A+    if (sigaction(SIGPIPE, &sa, NULL))=
=0A+        die("sigaction");=0A+=0A+    /*=0A+     * Parse arguments and d=
etermine output file name.=0A+     */=0A+=0A+    if (argc !=3D 3)=0A+      =
  usage_and_exit(argv[0]);=0A+=0A+    char *server_port =3D argv[1];=0A+   =
 char *web_root =3D argv[2];=0A+=0A+=0A+    /*=0A+     * Obtain socket addr=
ess structure from server name and port number.=0A+     */=0A+=0A+    struc=
t addrinfo hints, *info;=0A+    memset(&hints, 0, sizeof(hints));=0A+=0A+  =
  hints.ai_family =3D AF_INET;       // Only accept IPv4 addresses=0A+    h=
ints.ai_socktype =3D SOCK_STREAM; // Stream socket for TCP connections=0A+ =
   hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints.ai_flags=
 =3D AI_PASSIVE;     // Construct socket address for bind()ing=0A+=0A+    i=
nt aerr;=0A+    if ((aerr =3D getaddrinfo(NULL, server_port, &hints, &info)=
) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(ae=
rr));=0A+        exit(1);=0A+    }=0A+=0A+    /*=0A+     * Create a socket(=
), bind() it to the server, and wrap in FILE *s.=0A+     */=0A+=0A+    int =
serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=
=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    if (bind(serv=
_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+   =
=0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for connections=
 on this socket, maintaining a queue of=0A+    // at most 8 pending connect=
ions.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=0A+=
=0A+     /*=0A+     * Server loop runs forever (writing "for (;;)" is the s=
ame as "while(1)")=0A+     */=0A+    for (;;) {=0A+=0A+        /*=0A+      =
   * accept() connection from client.=0A+         */=0A+=0A+        // Defi=
ne space to receive client address info.=0A+        struct sockaddr_in clnt=
_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+   =
     // accept() blocks until a client connects with the server, and return=
s=0A+        // a NEW socket file descriptor for interacting with the clien=
t.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &clnt_add=
r,=0A+                             &clnt_addr_len);=0A+        if (clnt_fd =
< 0)=0A+            die("accept");=0A+        =0A+        char *ip_address =
=3D inet_ntoa(clnt_addr.sin_addr);=0A+            =0A+        // clnt_addr =
is now populated with information about the client.=0A+        //fprintf(st=
derr, "Accepted connection from %s\n",ip_address);=0A+=0A+        pid_t pid=
 =3D fork();=0A+=0A+        // Both the parent and child will resume execut=
ion here.=0A+        if (pid =3D=3D 0){=0A+            =0A+            // C=
hild process=0A+            close(serv_fd);=0A+            handle_client(cl=
nt_fd, web_root, ip_address, getpid());=0A+            exit(0);=0A+=0A+    =
    }else{=0A+            =0A+            close(clnt_fd);=0A+            //=
 Parent process=0A+            struct sigaction sa2;=0A+            memset(=
&sa2, 0, sizeof(sa2));         // Zero-initialize sigaction structure=0A+  =
          sigemptyset(&sa2.sa_mask);           // Don't mask any signals=0A=
+            sa.sa_flags =3D SA_RESTART;             // Restart interrupted=
 system calls=0A+            sa.sa_handler =3D &reap_children;      // Reap=
 children upon receiving signal=0A+=0A+            if (sigaction(SIGCHLD, &=
sa, NULL))=0A+                die("sigaction");=0A+        }=0A+         =
=0A+    }=0A+=0A+    /*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    // Theo=
retically, if we want our server to handle graceful termination, we=0A+    =
// should also close() the server socket here too:=0A+    close(serv_fd);=
=0A+=0A+    return 0;=0A+}=0A+=0A-- =0A2.34.1=0A=0A=0AFrom 5161264295a97a29=
0b1442fd240cde6ea9372bcc Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao27=
94@columbia.edu>=0ADate: Wed, 30 Nov 2022 18:28:11 -0500=0ASubject: [PATCH =
09/11] Made a change to README.=0A=0A---=0A README.txt | 8 ++++----=0A 1 fi=
le changed, 4 insertions(+), 4 deletions(-)=0A=0Adiff --git a/README.txt b/=
README.txt=0Aindex 49c4472..b6c6f1c 100644=0A--- a/README.txt=0A+++ b/READM=
E.txt=0A@@ -1,9 +1,9 @@=0A This file should contain:=0A =0A-  - your name=
=0A-  - your UNI=0A-  - lab assignment number=0A-  - description for each p=
art=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab6=0A+  - It should work!=0A =
=0A The description should indicate whether your solution for the part is=
=0A working or not.  You may also want to include anything else you would=
=0A-- =0A2.34.1=0A=0A=0AFrom ad8500bd591cd6d51ecbe9b7ce004e6faa945c01 Mon S=
ep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, =
30 Nov 2022 23:55:45 -0500=0ASubject: [PATCH 10/11] Final commit.=0A=0A---=
=0A README.txt                | 72 ++++++++++++++++++++++++++++++++-=0A par=
t1/http-server.c       | 53 ++++++++----------------=0A part2/multi-http-se=
rver.c | 85 ++++++++++++++++-----------------------=0A 3 files changed, 122=
 insertions(+), 88 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=
=0Aindex b6c6f1c..e0816e8 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@=
 -3,9 +3,79 @@ This file should contain:=0A   - Arman Ozcan=0A   - ao2794=
=0A   - lab6=0A-  - It should work!=0A+  - It should work! And I set up my =
web page.=0A =0A The description should indicate whether your solution for =
the part is=0A working or not.  You may also want to include anything else =
you would=0A like to communicate to the grader such as extra functionalitie=
s you=0A implemented or how you tried to fix your non-working code.=0A+=3D=
=3D68827=3D=3D Memcheck, a memory error detector=0A+=3D=3D68827=3D=3D Copyr=
ight (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D68827=
=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info=
=0A+=3D=3D68827=3D=3D Command: ./http-server 10125 /mnt/disks/students229/a=
o2794/html=0A+=3D=3D68827=3D=3D =0A+34.145.159.110 "GET /cs3157/ HTTP/1.0" =
200 OK=0A+34.145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented=0A+34.=
145.159.110 "GET /cs3157/ HTTP/1.5" 501 Not Implemented=0A+34.145.159.110 "=
GET /cs3157 HTTP/1.1" 301 Moved Permanently=0A+=3D=3D68827=3D=3D =0A+=3D=3D=
68827=3D=3D Process terminating with default action of signal 2 (SIGINT)=0A=
+=3D=3D68827=3D=3D    at 0x498A5D7: accept (accept.c:26)=0A+=3D=3D68827=3D=
=3D    by 0x10A1AF: main (http-server.c:283)=0A+=3D=3D68827=3D=3D =0A+=3D=
=3D68827=3D=3D HEAP SUMMARY:=0A+=3D=3D68827=3D=3D     in use at exit: 0 byt=
es in 0 blocks=0A+=3D=3D68827=3D=3D   total heap usage: 19 allocs, 19 frees=
, 37,592 bytes allocated=0A+=3D=3D68827=3D=3D =0A+=3D=3D68827=3D=3D All hea=
p blocks were freed -- no leaks are possible=0A+=3D=3D68827=3D=3D =0A+=3D=
=3D68827=3D=3D For lists of detected and suppressed errors, rerun with: -s=
=0A+=3D=3D68827=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: =
0 from 0)=0A+=3D=3D115292=3D=3D Memcheck, a memory error detector=0A+=3D=3D=
115292=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al=
=2E=0A+=3D=3D115292=3D=3D Using Valgrind-3.18.1 and LibVEX; rerun with -h f=
or copyright info=0A+=3D=3D115292=3D=3D Command: ./multi-http-server 10129 =
/mnt/disks/students229/ao2794/html=0A+=3D=3D115292=3D=3D =0A+34.145.159.110=
 (116118) "GET /cs3157/photos.jpg HTTP/1.1" 404 Not Found=0A+=3D=3D116118=
=3D=3D =0A+=3D=3D116118=3D=3D HEAP SUMMARY:=0A+=3D=3D116118=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D116118=3D=3D   total heap usage: 6 =
allocs, 6 frees, 9,672 bytes allocated=0A+=3D=3D116118=3D=3D =0A+=3D=3D1161=
18=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D11611=
8=3D=3D =0A+=3D=3D116118=3D=3D For lists of detected and suppressed errors,=
 rerun with: -s=0A+=3D=3D116118=3D=3D ERROR SUMMARY: 0 errors from 0 contex=
ts (suppressed: 0 from 0)=0A+34.145.159.110 (117352) "GET /cs3157/images/ph=
otos.jpg HTTP/1.1" 404 Not Found=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=3D=
=3D HEAP SUMMARY:=0A+=3D=3D117352=3D=3D     in use at exit: 0 bytes in 0 bl=
ocks=0A+=3D=3D117352=3D=3D   total heap usage: 6 allocs, 6 frees, 9,672 byt=
es allocated=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=3D=3D All heap blocks w=
ere freed -- no leaks are possible=0A+=3D=3D117352=3D=3D =0A+=3D=3D117352=
=3D=3D For lists of detected and suppressed errors, rerun with: -s=0A+=3D=
=3D117352=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from=
 0)=0A+34.145.159.110 (117760) "GET /cs3157/images/photo.jpg HTTP/1.1" 200 =
OK=0A+=3D=3D117760=3D=3D =0A+=3D=3D117760=3D=3D HEAP SUMMARY:=0A+=3D=3D1177=
60=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D117760=3D=3D   to=
tal heap usage: 7 allocs, 7 frees, 17,864 bytes allocated=0A+=3D=3D117760=
=3D=3D =0A+=3D=3D117760=3D=3D All heap blocks were freed -- no leaks are po=
ssible=0A+=3D=3D117760=3D=3D =0A+=3D=3D117760=3D=3D For lists of detected a=
nd suppressed errors, rerun with: -s=0A+=3D=3D117760=3D=3D ERROR SUMMARY: 0=
 errors from 0 contexts (suppressed: 0 from 0)=0A+=3D=3D115292=3D=3D =0A+=
=3D=3D115292=3D=3D Process terminating with default action of signal 2 (SIG=
INT)=0A+=3D=3D115292=3D=3D    at 0x498A5D7: accept (accept.c:26)=0A+=3D=3D1=
15292=3D=3D    by 0x10A2A7: main (multi-http-server.c:291)=0A+=3D=3D115292=
=3D=3D =0A+=3D=3D115292=3D=3D HEAP SUMMARY:=0A+=3D=3D115292=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D115292=3D=3D   total heap usage: 1 =
allocs, 1 frees, 64 bytes allocated=0A+=3D=3D115292=3D=3D =0A+=3D=3D115292=
=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D115292=
=3D=3D =0A+=3D=3D115292=3D=3D For lists of detected and suppressed errors, =
rerun with: -s=0A+=3D=3D115292=3D=3D ERROR SUMMARY: 0 errors from 0 context=
s (suppressed: 0 from 0)=0Adiff --git a/part1/http-server.c b/part1/http-se=
rver.c=0Aindex 3e500eb..5923fd2 100644=0A--- a/part1/http-server.c=0A+++ b/=
part1/http-server.c=0A@@ -41,8 +41,7 @@ static void handle_client(int clnt_=
fd, char *web_root, char *ip_address){=0A    =0A     char buf[BUF_SIZE];=0A=
 =0A-    // Read the first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE ST=
RUCTURE=0A-    // CHECK AFTER THIS=0A+    // Reads the initial request line=
=2E=0A     if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A    =
     method =3D strtok(buf, token_separators);=0A         requestURI =3D st=
rtok(NULL, token_separators);=0A@@ -53,9 +52,8 @@ static void handle_client=
(int clnt_fd, char *web_root, char *ip_address){=0A         fprintf(stderr,=
 "%s \"%s %s %s\" 400 Bad Request\n",=0A                 ip_address, method=
, requestURI, httpVersion);=0A =0A-        fprintf(stderr, "Client connecti=
on terminated prematurely by the first if.\n");=0A-        buf[0] =3D '\0';=
=0A-        fclose(clnt_r); //if(fclose(clnt_r)){die("close");}=0A+        =
buf[0] =3D 0;=0A+        fclose(clnt_r);=0A         fclose(clnt_w);=0A     =
    return;=0A     }=0A@@ -67,14 +65,14 @@ static void handle_client(int cl=
nt_fd, char *web_root, char *ip_address){=0A =0A =0A     // If the initial =
request line is not complete or there is an extra word at the end=0A-    if=
(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL ||=
 extra !=3D NULL){=0A+    // Or the URI doesn't start with '/' or there exi=
sts =0A+    if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =
=3D=3D NULL || extra !=3D NULL || strncmp("/", requestURI, 1) !=3D 0 || str=
str(requestURI, "/../") !=3D NULL  || ( (strlen(requestURI) >=3D 3) && *(re=
questURI + strlen(requestURI) - 1) =3D=3D '.' && *(requestURI + strlen(requ=
estURI) - 2) =3D=3D '.' && *(requestURI + strlen(requestURI) - 3) =3D=3D '/=
') ){=0A        =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r=
\n"=0A                 "<html><body><h1>400 Bad Request</h1></body></html>\=
r\n");=0A         fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A  =
               ip_address, method, requestURI, httpVersion);=0A =0A-       =
 fprintf(stderr, "Client connection terminated prematurely by the third if.=
\n");=0A         buf[0] =3D 0; =0A         fclose(clnt_r);=0A         fclos=
e(clnt_w);=0A@@ -88,41 +86,28 @@ static void handle_client(int clnt_fd, cha=
r *web_root, char *ip_address){=0A             "<html><body><h1>501 Not Imp=
lemented</h1></body></html>\r\n");=0A         fprintf(stderr, "%s \"%s %s %=
s\" 501 Not Implemented\n",=0A                ip_address, method, requestUR=
I, httpVersion);=0A+    =0A         buf[0] =3D 0;=0A         fclose(clnt_r)=
;=0A         fclose(clnt_w);=0A         return;=0A     }=0A         =0A-   =
 // If URI doesn't start with '/' or there exists '..' in the URI=0A-    if=
 (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL=
 ) {=0A-        fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-     =
           "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-  =
      fprintf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-             =
   ip_address, method, requestURI, httpVersion);=0A-        buf[0] =3D 0;=
=0A-        fclose(clnt_r);=0A-        fclose(clnt_w);=0A-        return;=
=0A-    }=0A-=0A     char buf3[BUF_SIZE];=0A-=0A+    =0A     while(1){=0A 	=
 if (fgets(buf3, sizeof(buf3), clnt_r) =3D=3D NULL) {       =0A        		fp=
rintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A                 	    "<=
html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A         	fprint=
f(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A                         i=
p_address, method, requestURI, httpVersion);=0A-=0A-        	fprintf(stderr=
, "There was an issue with header lines\n");=0A-        	buf[0] =3D 0;=0A+ =
=0A+                buf[0] =3D 0;=0A         	fclose(clnt_r);=0A         	f=
close(clnt_w);=0A         	return;=0A     	}=0A =0A-=0A 	if(strlen(buf3) <=
=3D 2  && buf3[strlen(buf3)-1] =3D=3D '\n' )=0A  		break;=0A =0A@@ -135,19 =
+120,11 @@ static void handle_client(int clnt_fd, char *web_root, char *ip_=
address){=0A =0A     // If URI ends with /, append index.html=0A     if (st=
rlen(requestURI) > 0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/=
')         =0A-        strcat(requestURI, "index.html");=0A-  =0A-        =
=0A-        /*=0A-        * Read from the file, and write out to file_name.=
=0A-        */=0A-        =0A-        // char *filename; [strlen(web_root +=
 strlen(requestURI)) + 1];=0A+        strcat(requestURI, "index.html"); =0A=
+         =0A         =0A     strcat(web_root, requestURI);=0A =0A-    // f=
printf(stderr, "Filename is: %s\n", web_root);=0A-=0A     struct stat st;=
=0A     if (stat(web_root, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A      =
   fprintf(clnt_w, "HTTP/1.0 301 Moved Permanently\r\n"=0A@@ -157,6 +134,7 =
@@ static void handle_client(int clnt_fd, char *web_root, char *ip_address)=
{=0A                 "<p>The document has moved <a href=3D\"%s/\">here</a>.=
</p>\r\n"=0A                 "</body></html>\r\n", requestURI, requestURI);=
=0A         fprintf(stderr, "301 Moved Permanently\n");=0A+       =0A      =
   fclose(clnt_w);=0A         fclose(clnt_r);=0A         *(web_root + strle=
n(web_root) - strlen(requestURI)) =3D '\0';=0A@@ -169,6 +147,7 @@ static vo=
id handle_client(int clnt_fd, char *web_root, char *ip_address){=0A        =
 fprintf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A                 "<html=
><body><h1>404 Not Found</h1></body></html>\r\n");=0A         fprintf(stder=
r, "404 Not Found\n");=0A+       =0A         fclose(clnt_w);=0A         fcl=
ose(clnt_r);=0A         *(web_root + strlen(web_root) - strlen(requestURI))=
 =3D '\0';=0A@@ -191,9 +170,11 @@ static void handle_client(int clnt_fd, ch=
ar *web_root, char *ip_address){=0A             // Don't crash the server a=
nd move to the next client.=0A             fclose(clnt_w);=0A             f=
close(clnt_r);=0A+            fclose(file);=0A             perror("send byt=
es to client");=0A             return;=0A         }=0A+        fflush(clnt_=
w);=0A     }=0A =0A =0A@@ -202,6 +183,7 @@ static void handle_client(int cl=
nt_fd, char *web_root, char *ip_address){=0A         // Don't crash the ser=
ver and move to the next client.=0A         fclose(clnt_w);=0A         fclo=
se(clnt_r);=0A+        fclose(file);=0A         perror("read from the file =
requested");=0A         return;=0A     } =0A@@ -212,8 +194,7 @@ static void=
 handle_client(int clnt_fd, char *web_root, char *ip_address){=0A     */=0A=
 =0A     // Close FILE * for output file.=0A-    if (fclose(file))=0A-     =
   die("close");       =0A+    fclose(file);       =0A =0A     // Close cli=
ent connection.=0A     fclose(clnt_r);=0Adiff --git a/part2/multi-http-serv=
er.c b/part2/multi-http-server.c=0Aindex 929e9f7..4eb8018 100644=0A--- a/pa=
rt2/multi-http-server.c=0A+++ b/part2/multi-http-server.c=0A@@ -31,11 +31,1=
2 @@ void reap_children(int sig){=0A         ;=0A }=0A =0A-static void hand=
le_client(int clnt_fd, char *web_root, char *ip_address, pid_t pid){=0A-   =
     =0A+static void handle_client(int clnt_fd, char *web_root, char *ip_ad=
dress){=0A+=0A     FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A     FILE *cln=
t_w =3D fdopen(dup(clnt_fd), "wb");=0A-     =0A+    int pid =3D (int) getpi=
d();=0A+=0A      /*=0A      * Receive the HTTP response.=0A      */=0A@@ -4=
7,8 +48,7 @@ static void handle_client(int clnt_fd, char *web_root, char *i=
p_address, pid_t p=0A    =0A     char buf[BUF_SIZE];=0A =0A-    // Read the=
 first line CHECK IF IT EVER ENTERS HERE!!! AND MOVE STRUCTURE=0A-    // CH=
ECK AFTER THIS=0A+    // Reads the initial request line.=0A     if (fgets(b=
uf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A         method =3D strtok=
(buf, token_separators);=0A         requestURI =3D strtok(NULL, token_separ=
ators);=0A@@ -56,12 +56,11 @@ static void handle_client(int clnt_fd, char *=
web_root, char *ip_address, pid_t p=0A =0A         fprintf(clnt_w, "HTTP/1.=
0 400 Bad Request\r\n\r\n"=0A                 "<html><body><h1>400 Bad Requ=
est</h1></body></html>\r\n");=0A-        fprintf(stderr, "%s \"%s %s %s\" 4=
00 Bad Request\n",=0A-                ip_address, method, requestURI, httpV=
ersion);=0A+        fprintf(stderr, "%s (%d) \"%s %s %s\" 400 Bad Request\n=
",=0A+                ip_address, pid, method, requestURI, httpVersion);=0A=
 =0A-        fprintf(stderr, "Client connection terminated prematurely by t=
he first if.\n");=0A-        buf[0] =3D '\0';=0A-        fclose(clnt_r); //=
if(fclose(clnt_r)){die("close");}=0A+        buf[0] =3D 0;=0A+        fclos=
e(clnt_r);=0A         fclose(clnt_w);=0A         return;=0A     }=0A@@ -73,=
14 +72,14 @@ static void handle_client(int clnt_fd, char *web_root, char *i=
p_address, pid_t p=0A =0A =0A     // If the initial request line is not com=
plete or there is an extra word at the end=0A-    if(method =3D=3D NULL || =
requestURI =3D=3D NULL || httpVersion =3D=3D NULL || extra !=3D NULL){=0A- =
      =0A+    // Or the URI doesn't start with '/' or there exists =0A+    =
if(method =3D=3D NULL || requestURI =3D=3D NULL || httpVersion =3D=3D NULL =
|| extra !=3D NULL || strncmp("/", requestURI, 1) !=3D 0 || strstr(requestU=
RI, "/../") !=3D NULL  || ( (strlen(requestURI) >=3D 3) && *(requestURI + s=
trlen(requestURI) - 1) =3D=3D '.' && *(requestURI + strlen(requestURI) - 2)=
 =3D=3D '.' && *(requestURI + strlen(requestURI) - 3) =3D=3D '/') ){=0A+=0A=
         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A             =
    "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0A-        f=
printf(stderr, "%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip_a=
ddress, method, requestURI, httpVersion);=0A+        fprintf(stderr, "%s (%=
d) \"%s %s %s\" 400 Bad Request\n",=0A+                ip_address, pid, met=
hod, requestURI, httpVersion);=0A =0A-        fprintf(stderr, "Client conne=
ction terminated prematurely by the third if.\n");=0A         buf[0] =3D 0;=
 =0A         fclose(clnt_r);=0A         fclose(clnt_w);=0A@@ -92,43 +91,30 =
@@ static void handle_client(int clnt_fd, char *web_root, char *ip_address,=
 pid_t p=0A         fprintf(clnt_w,=0A             "HTTP/1.0 501 Not Implem=
ented\r\n\r\n"=0A             "<html><body><h1>501 Not Implemented</h1></bo=
dy></html>\r\n");=0A-        fprintf(stderr, "%s \"%s %s %s\" 501 Not Imple=
mented\n",=0A-               ip_address, method, requestURI, httpVersion);=
=0A+        fprintf(stderr, "%s (%d) \"%s %s %s\" 501 Not Implemented\n",=
=0A+               ip_address, pid, method, requestURI, httpVersion);=0A+  =
  =0A         buf[0] =3D 0;=0A         fclose(clnt_r);=0A         fclose(cl=
nt_w);=0A         return;=0A     }=0A         =0A-    // If URI doesn't sta=
rt with '/' or there exists '..' in the URI=0A-    if (strncmp("/", request=
URI, 1) !=3D 0 || strstr(requestURI, "/..") !=3D NULL ) {=0A-        fprint=
f(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A-                "<html><bod=
y><h1>400 Bad Request</h1></body></html>\r\n");=0A-        fprintf(stderr, =
"%s \"%s %s %s\" 400 Bad Request\n",=0A-                ip_address, method,=
 requestURI, httpVersion);=0A-        buf[0] =3D 0;=0A-        fclose(clnt_=
r);=0A-        fclose(clnt_w);=0A-        return;=0A-    }=0A-=0A     char =
buf3[BUF_SIZE];=0A-=0A+    =0A     while(1){=0A 	 if (fgets(buf3, sizeof(bu=
f3), clnt_r) =3D=3D NULL) {       =0A        		fprintf(clnt_w, "HTTP/1.0 40=
0 Bad Request\r\n\r\n"=0A                 	    "<html><body><h1>400 Bad Req=
uest</h1></body></html>\r\n");=0A-        	fprintf(stderr, "%s \"%s %s %s\"=
 400 Bad Request\n",=0A-                        ip_address, method, request=
URI, httpVersion);=0A-=0A-        	fprintf(stderr, "There was an issue with=
 header lines\n");=0A-        	buf[0] =3D 0;=0A+        	fprintf(stderr, "%=
s (%d) \"%s %s %s\" 400 Bad Request\n",=0A+                        ip_addre=
ss, pid, method, requestURI, httpVersion);=0A+ =0A+                buf[0] =
=3D 0;=0A         	fclose(clnt_r);=0A         	fclose(clnt_w);=0A         	=
return;=0A     	}=0A =0A-=0A 	if(strlen(buf3) <=3D 2  && buf3[strlen(buf3)-=
1] =3D=3D '\n' )=0A  		break;=0A =0A@@ -136,33 +122,26 @@ static void handl=
e_client(int clnt_fd, char *web_root, char *ip_address, pid_t p=0A =0A     =
//From this point on, we can assume that HTTP request has correct structure=
=0A   =0A-    fprintf(stderr, "%s \"%s %s %s\" ", ip_address, method, reque=
stURI, httpVersion);=0A+    fprintf(stderr, "%s (%d) \"%s %s %s\" ", ip_add=
ress, pid, method, requestURI, httpVersion);=0A     buf[0] =3D 0;=0A =0A   =
  // If URI ends with /, append index.html=0A     if (strlen(requestURI) > =
0 && (*(requestURI + strlen(requestURI) - 1))  =3D=3D '/')         =0A-    =
    strcat(requestURI, "index.html");=0A-  =0A-        =0A-        /*=0A-  =
      * Read from the file, and write out to file_name.=0A-        */=0A-  =
      =0A-        // char *filename; [strlen(web_root + strlen(requestURI))=
 + 1];=0A+        strcat(requestURI, "index.html"); =0A+         =0A       =
  =0A     strcat(web_root, requestURI);=0A =0A-    // fprintf(stderr, "File=
name is: %s\n", web_root);=0A-=0A     struct stat st;=0A     if (stat(web_r=
oot, &st) =3D=3D 0 && S_ISDIR(st.st_mode)) {=0A         fprintf(clnt_w, "HT=
TP/1.0 301 Moved Permanently\r\n"=0A-                "Location: %s/\r\n\r\n=
"=0A+                "Location: %s/\r\n\r\n" =0A                 "<html><bo=
dy>\r\n"=0A                 "<h1>301 Moved Permanently</h1>\r\n"=0A        =
         "<p>The document has moved <a href=3D\"%s/\">here</a>.</p>\r\n"=0A=
                 "</body></html>\r\n", requestURI, requestURI);=0A         =
fprintf(stderr, "301 Moved Permanently\n");=0A+       =0A         fclose(cl=
nt_w);=0A         fclose(clnt_r);=0A         *(web_root + strlen(web_root) =
- strlen(requestURI)) =3D '\0';=0A@@ -175,6 +154,7 @@ static void handle_cl=
ient(int clnt_fd, char *web_root, char *ip_address, pid_t p=0A         fpri=
ntf(clnt_w, "HTTP/1.0 404 Not Found\r\n\r\n"=0A                 "<html><bod=
y><h1>404 Not Found</h1></body></html>\r\n");=0A         fprintf(stderr, "4=
04 Not Found\n");=0A+       =0A         fclose(clnt_w);=0A         fclose(c=
lnt_r);=0A         *(web_root + strlen(web_root) - strlen(requestURI)) =3D =
'\0';=0A@@ -197,9 +177,11 @@ static void handle_client(int clnt_fd, char *w=
eb_root, char *ip_address, pid_t p=0A             // Don't crash the server=
 and move to the next client.=0A             fclose(clnt_w);=0A            =
 fclose(clnt_r);=0A+            fclose(file);=0A             perror("send b=
ytes to client");=0A             return;=0A         }=0A+        fflush(cln=
t_w);=0A     }=0A =0A =0A@@ -208,6 +190,7 @@ static void handle_client(int =
clnt_fd, char *web_root, char *ip_address, pid_t p=0A         // Don't cras=
h the server and move to the next client.=0A         fclose(clnt_w);=0A    =
     fclose(clnt_r);=0A+        fclose(file);=0A         perror("read from =
the file requested");=0A         return;=0A     } =0A@@ -218,8 +201,7 @@ st=
atic void handle_client(int clnt_fd, char *web_root, char *ip_address, pid_=
t p=0A     */=0A =0A     // Close FILE * for output file.=0A-    if (fclose=
(file))=0A-        die("close");       =0A+    fclose(file);       =0A =0A =
    // Close client connection.=0A     fclose(clnt_r);=0A@@ -227,6 +209,7 @=
@ static void handle_client(int clnt_fd, char *web_root, char *ip_address, =
pid_t p=0A =0A     // Resume server loop to handle next client connection.=
=0A     return;=0A+=0A }=0A =0A =0A@@ -322,7 +305,7 @@ int main(int argc, c=
har **argv)=0A             =0A             // Child process=0A             =
close(serv_fd);=0A-            handle_client(clnt_fd, web_root, ip_address,=
 getpid());=0A+            handle_client(clnt_fd, web_root, ip_address);=0A=
             exit(0);=0A =0A         }else{=0A-- =0A2.34.1=0A=0A=0AFrom 17a=
e1860457a370c88f3a00141b83135e5a0ecb0 Mon Sep 17 00:00:00 2001=0AFrom: Arma=
n Ozcan <ao2794@columbia.edu>=0ADate: Thu, 1 Dec 2022 00:22:10 -0500=0ASubj=
ect: [PATCH 11/11] Noticed a memory error when the client does CTRL + C=0A =
and fixed it.=0A=0A---=0A part1/http-server.c       | 3 ---=0A part2/multi-=
http-server.c | 5 +----=0A 2 files changed, 1 insertion(+), 7 deletions(-)=
=0A=0Adiff --git a/part1/http-server.c b/part1/http-server.c=0Aindex 5923fd=
2..bfd6147 100644=0A--- a/part1/http-server.c=0A+++ b/part1/http-server.c=
=0A@@ -43,9 +43,6 @@ static void handle_client(int clnt_fd, char *web_root,=
 char *ip_address){=0A =0A     // Reads the initial request line.=0A     if=
 (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A-        method =
=3D strtok(buf, token_separators);=0A-        requestURI =3D strtok(NULL, t=
oken_separators);=0A-        httpVersion =3D strtok(NULL, token_separators)=
;=0A =0A         fprintf(clnt_w, "HTTP/1.0 400 Bad Request\r\n\r\n"=0A     =
            "<html><body><h1>400 Bad Request</h1></body></html>\r\n");=0Adi=
ff --git a/part2/multi-http-server.c b/part2/multi-http-server.c=0Aindex 4e=
b8018..e6dd0da 100644=0A--- a/part2/multi-http-server.c=0A+++ b/part2/multi=
-http-server.c=0A@@ -50,10 +50,7 @@ static void handle_client(int clnt_fd, =
char *web_root, char *ip_address){=0A =0A     // Reads the initial request =
line.=0A     if (fgets(buf, sizeof(buf), clnt_r) =3D=3D NULL) {       =0A- =
       method =3D strtok(buf, token_separators);=0A-        requestURI =3D =
strtok(NULL, token_separators);=0A-        httpVersion =3D strtok(NULL, tok=
en_separators);=0A-=0A+        =0A         fprintf(clnt_w, "HTTP/1.0 400 Ba=
d Request\r\n\r\n"=0A                 "<html><body><h1>400 Bad Request</h1>=
</body></html>\r\n");=0A         fprintf(stderr, "%s (%d) \"%s %s %s\" 400 =
Bad Request\n",=0A-- =0A2.34.1=0A=0A
--RM7gcjQxE9obSeaN--

From do.not.reply@cloud.cs.columbia.edu Wed Dec 14 17:52:23 2022
Date: Wed, 14 Dec 2022 17:52:23 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab7.mbox
Message-ID: <Y5pTpYIYxkzOC4h+@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="8npxk+dsqscB+TCs"
Content-Disposition: inline
Status: RO
Content-Length: 112741
Lines: 2613


--8npxk+dsqscB+TCs
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 5b3cf0a1b0e8127cf80fa450a98c1d32513c8579 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Thu, 8 Dec 2022 22:05:32 -0500
Subject: [PATCH 1/9] First commit.

---
 part1/Makefile            |  22 +++++
 part1/mdb-lookup-server.c | 174 ++++++++++++++++++++++++++++++++++++++
 part1/mdb.c               |  53 ++++++++++++
 part1/mdb.h               |  18 +++-
 4 files changed, 264 insertions(+), 3 deletions(-)
 create mode 100644 part1/Makefile
 create mode 100644 part1/mdb-lookup-server.c
 create mode 100644 part1/mdb.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..6f5a47e
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,22 @@
+CC = gcc
+
+# Support externally overriding CFLAGS
+CFLAGS ?= -g -Wall -Wpedantic -std=c17
+CFLAGS += -I/home/j-hui/cs3157-pub/include
+
+LDFLAGS = -L/home/j-hui/cs3157-pub/lib
+LDLIBS = -lmylist
+
+.PHONY: default
+default: mdb-lookup-server
+
+mdb-lookup-server: mdb-lookup-server.o mdb.o
+mdb-lookup-server.o: mdb-lookup-server.c mdb.h
+mdb.o: mdb.h
+	
+.PHONY: clean
+clean:
+	rm -f *.o a.out core mdb-lookup-server
+
+.PHONY: all
+all: clean default
diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
new file mode 100644
index 0000000..7072e1f
--- /dev/null
+++ b/part1/mdb-lookup-server.c
@@ -0,0 +1,174 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <linux/limits.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <unistd.h>
+#include <mylist.h>
+#include "mdb.h"
+
+#define KeyMax 5
+#define MAX_LINE_LENGTH 1024  // Maximum line length for request and headers
+#define DISK_IO_BUF_SIZE 4096 // Size of buffer for reading and sending files
+
+static void die(const char *message)
+{
+    perror(message);
+    exit(1);
+}
+
+int main(int argc, char **argv) {
+    /*
+     * Check and obtain command-line arguments
+     */
+    if (argc != 2) {
+        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
+        exit(1);
+    }
+
+    char *server_port = argv[1];
+    char *database = argv[2];
+
+    /*
+     * Construct socket address information using getaddrinfo().
+     */
+
+    // Define hints for getaddrinfo(), which we need to zero out first.
+    struct addrinfo hints;
+
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    // N.B. info actually points to a linked list of address information
+    // structures; assume that the first is sufficient and ignore the rest.
+
+    /*
+     * Create socket() and prepare it to accept() connections.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    // bind() socket to a port on the server; the port in info->ai_addr should
+    // be the same port that getaddrinfo() parsed from server_port.
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        /*
+         * Handle client connection.
+         */
+
+        FILE *fp = fopen(database, "rb");
+        if (fp == NULL)
+            die(database);
+
+        /*
+         * read all records into memory
+         */
+
+        struct List list;
+        initList(&list);
+
+        int loaded = loadmdb(fp, &list);
+        if (loaded < 0)
+            die("loadmdb");
+
+        if (fclose(fp) < 0)
+            perror("file");
+        
+        /*
+         * lookup loop
+         */
+        
+        char line[1024];
+        char key[KeyMax + 1];
+
+       
+        // clear up the key!!
+        
+        // open a file pointer
+        // make 
+
+       /*
+        * search with key
+        */
+
+        // traverse the list, printing out the matching records
+        struct Node *node = list.head;
+        int recNo = 1;
+        while (node) {
+            struct MdbRec *rec = (struct MdbRec *)node->data;
+
+            if (strstr(rec->name, key) || strstr(rec->msg, key))
+                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+
+            node = node->next;
+            recNo++;
+        }
+
+        // Close client connection.
+        close(clnt_fd);
+
+        // Resume server loop to handle next client connection.
+    }
+
+    close(serv_fd);
+    return 0;
+}
diff --git a/part1/mdb.c b/part1/mdb.c
new file mode 100644
index 0000000..ce5243a
--- /dev/null
+++ b/part1/mdb.c
@@ -0,0 +1,53 @@
+/*
+ * mdb.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <mylist.h>
+
+#include "mdb.h"
+
+int loadmdb(FILE *fp, struct List *dest)
+{
+    /*
+     * read all records into memory
+     */
+
+    struct MdbRec r;
+    struct Node *node = NULL;
+    int count = 0;
+
+    while (fread(&r, sizeof(r), 1, fp) == 1) {
+
+        // allocate memory for a new record and copy into it the one
+        // that was just read from the database.
+        struct MdbRec *rec = (struct MdbRec *)malloc(sizeof(r));
+        if (!rec)
+            return -1;
+
+        memcpy(rec, &r, sizeof(r));
+
+        // add the record to the linked list.
+        node = addAfter(dest, node, rec);
+        if (node == NULL)
+            return -1;
+
+        count++;
+    }
+
+    // see if fread() produced error
+    if (ferror(fp))
+        return -1;
+
+    return count;
+}
+
+void freemdb(struct List *list)
+{
+    // free all the records
+    traverseList(list, &free);
+    removeAllNodes(list);
+}
diff --git a/part1/mdb.h b/part1/mdb.h
index fb091b5..6712a6c 100644
--- a/part1/mdb.h
+++ b/part1/mdb.h
@@ -1,9 +1,21 @@
-#ifndef __MDB_H__
-#define __MDB_H__
+/*
+ * mdb.h
+ */
+
+#ifndef _MDB_H_
+#define _MDB_H_
+
+#include <stdio.h>
+
+#include <mylist.h>
 
 struct MdbRec {
     char name[16];
     char msg[24];
 };
 
-#endif
+int loadmdb(FILE *fp, struct List *dest);
+void freemdb(struct List *list);
+
+#endif /* _MDB_H_ */
+
-- 
2.34.1


From af5c8ebf61fc2d15148c940e57849615ab8a723d Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 9 Dec 2022 23:46:19 -0500
Subject: [PATCH 2/9] I managed to get mdb-lookup-server working, but it only
 can handle one process for now.

---
 part1/Makefile            |  10 ++--
 part1/mdb-lookup-server.c | 116 +++++++++++++++++++++++++++++---------
 2 files changed, 94 insertions(+), 32 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index 6f5a47e..3dc4b25 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -7,13 +7,15 @@ CFLAGS += -I/home/j-hui/cs3157-pub/include
 LDFLAGS = -L/home/j-hui/cs3157-pub/lib
 LDLIBS = -lmylist
 
+mdb-lookup-server: mdb-lookup-server.o mdb.o
+
+mdb.o: mdb.c mdb.h
+
+mdb-lookup-server.o: mdb-lookup-server.c mdb.h
+
 .PHONY: default
 default: mdb-lookup-server
 
-mdb-lookup-server: mdb-lookup-server.o mdb.o
-mdb-lookup-server.o: mdb-lookup-server.c mdb.h
-mdb.o: mdb.h
-	
 .PHONY: clean
 clean:
 	rm -f *.o a.out core mdb-lookup-server
diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index 7072e1f..bb1a9fe 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -29,7 +29,7 @@ int main(int argc, char **argv) {
     /*
      * Check and obtain command-line arguments
      */
-    if (argc != 2) {
+    if (argc != 3) {
         fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
         exit(1);
     }
@@ -37,6 +37,11 @@ int main(int argc, char **argv) {
     char *server_port = argv[1];
     char *database = argv[2];
 
+    // Open the database file
+    FILE *fp = fopen(database, "rb");
+    if (fp == NULL)
+        die(database);
+
     /*
      * Construct socket address information using getaddrinfo().
      */
@@ -114,10 +119,18 @@ int main(int argc, char **argv) {
         /*
          * Handle client connection.
          */
+        
+       
+        /*
+        * Open client file descriptor as FILE pointers.
+        */
+        FILE *clnt_r = fdopen(clnt_fd, "rb");
+        if (clnt_r == NULL)
+            die("fdopen");
 
-        FILE *fp = fopen(database, "rb");
-        if (fp == NULL)
-            die(database);
+        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+        if (clnt_w == NULL)
+            die("fdopen");
 
         /*
          * read all records into memory
@@ -130,45 +143,92 @@ int main(int argc, char **argv) {
         if (loaded < 0)
             die("loadmdb");
 
-        if (fclose(fp) < 0)
-            perror("file");
+        fseek(fp, 0, SEEK_SET);   
         
         /*
          * lookup loop
          */
-        
+              
         char line[1024];
         char key[KeyMax + 1];
-
-       
-        // clear up the key!!
+         
+        while(fgets(line, sizeof(line), clnt_r) != NULL){
+  
+            /*
+             * clean up user input
+             */
+            
+            if(strlen(line) >= 2 && line[strlen(line)-2] == '\r'){
+                line[strlen(line)-2] = '\n';
+                line[strlen(line)-1] = 0;
+            }
+
+            // must null-terminate the string manually after strncpy().
+            strncpy(key, line, sizeof(key) - 1);
+            key[sizeof(key) - 1] = '\0';
+
+            // if newline is within the first KeyMax characters, remove it.
+            size_t last = strlen(key) - 1;
+            if (key[last] == '\n')
+                key[last] = '\0';
+
+            // user might have typed more than sizeof(line) - 1 characters in line;
+            // continue fgets()ing until we encounter a newline.
+            while (line[strlen(line) - 1] != '\n' && fgets(line, sizeof(line), clnt_r))
+                ;
+
+            /*
+             * search with key
+             */
+
+            // traverse the list, printing out the matching records
+            struct Node *node = list.head;
+            int recNo = 1;
+            while (node) {
+                struct MdbRec *rec = (struct MdbRec *)node->data;
+
+                if (strstr(rec->name, key) || strstr(rec->msg, key))
+                    fprintf(clnt_w, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+
+                node = node->next;
+                recNo++;
+            }
+            
+            fflush(clnt_w);
         
-        // open a file pointer
-        // make 
+        }
+       
+        // see if fgets() produced error CHECK THIS! SHOULD YOU DIE?
+        if (ferror(clnt_r))
+            perror("clnt_r");
 
-       /*
-        * search with key
-        */
+        /*
+         * clean up and quit
+         */
 
-        // traverse the list, printing out the matching records
-        struct Node *node = list.head;
-        int recNo = 1;
-        while (node) {
-            struct MdbRec *rec = (struct MdbRec *)node->data;
+        freemdb(&list);
 
-            if (strstr(rec->name, key) || strstr(rec->msg, key))
-                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+       /*
+        * Done with client request; close the connection and log the transaction.
+        */
 
-            node = node->next;
-            recNo++;
-        }
+        // Closing can FILE pointers can also produce errors, which we log.
+        if (fclose(clnt_w) < 0)
+            perror("clnt_w");
 
-        // Close client connection.
-        close(clnt_fd);
+        if (fclose(clnt_r) < 0)
+            perror("clnt_r");
 
         // Resume server loop to handle next client connection.
     }
-
+   
+   /*
+    * UNREACHABLE
+    */
+    
+    if (fclose(fp) < 0)
+        perror("file");
+    
     close(serv_fd);
     return 0;
 }
-- 
2.34.1


From f9827408c9474f66f2efa62a5ac50dc3438824dd Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 01:36:14 -0500
Subject: [PATCH 3/9] I did part 1.

---
 part1/mdb-lookup-server.c | 262 ++++++++++++++++++++++++--------------
 1 file changed, 164 insertions(+), 98 deletions(-)

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index bb1a9fe..f523464 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -25,101 +25,16 @@ static void die(const char *message)
     exit(1);
 }
 
-int main(int argc, char **argv) {
-    /*
-     * Check and obtain command-line arguments
-     */
-    if (argc != 3) {
-        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
-        exit(1);
-    }
-
-    char *server_port = argv[1];
-    char *database = argv[2];
-
-    // Open the database file
-    FILE *fp = fopen(database, "rb");
-    if (fp == NULL)
-        die(database);
-
-    /*
-     * Construct socket address information using getaddrinfo().
-     */
-
-    // Define hints for getaddrinfo(), which we need to zero out first.
-    struct addrinfo hints;
-
-    memset(&hints, 0, sizeof(hints));
-
-    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
-    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
-    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
-    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
-
-    // Define where getaddrinfo() will return the information it found.
-    struct addrinfo *info;
-
-    // Call getaddrinfo(), specifying the server IP address and port as strings.
-    // getaddrinfo() will parse those for us and point info to the result.
-    int addr_err;
-    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
-        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
-        exit(1);
-    }
-
-    // N.B. info actually points to a linked list of address information
-    // structures; assume that the first is sufficient and ignore the rest.
-
-    /*
-     * Create socket() and prepare it to accept() connections.
-     */
-
-    // Create socket() according to the address family, socket type, and
-    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
-    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
-    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
-    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
-    if (serv_fd < 0)
-        die("socket");
-
-    // bind() socket to a port on the server; the port in info->ai_addr should
-    // be the same port that getaddrinfo() parsed from server_port.
-    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
-        die("bind");
-
-    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
-    freeaddrinfo(info);
-
-    // Start listen()ing for connections on this socket, maintaining a queue of
-    // at most 8 pending connections.
-    if (listen(serv_fd, 8) < 0)
-        die("listen");
-
-    for (;;) {
-
-        /*
-         * accept() connection from client.
-         */
-
-        // Define space to receive client address info.
-        struct sockaddr_in clnt_addr;
-        socklen_t clnt_addr_len = sizeof(clnt_addr);
-
-        // accept() blocks until a client connects with the server, and returns
-        // a NEW socket file descriptor for interacting with the client.
-        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
-                             &clnt_addr_len);
-        if (clnt_fd < 0)
-            die("accept");
-
-        // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",
-                inet_ntoa(clnt_addr.sin_addr));
+static void handle_client(char *database, int clnt_fd){
 
         /*
          * Handle client connection.
          */
-        
+
+        // Open the database file
+        FILE *fp = fopen(database, "rb");
+        if (fp == NULL)
+            die(database);
        
         /*
         * Open client file descriptor as FILE pointers.
@@ -141,9 +56,10 @@ int main(int argc, char **argv) {
 
         int loaded = loadmdb(fp, &list);
         if (loaded < 0)
-            die("loadmdb");
-
-        fseek(fp, 0, SEEK_SET);   
+            die("loadmdb");   
+   
+        if (fclose(fp) < 0)
+            perror("file");
         
         /*
          * lookup loop
@@ -192,8 +108,11 @@ int main(int argc, char **argv) {
 
                 node = node->next;
                 recNo++;
+                fflush(clnt_w);
             }
             
+            fprintf(clnt_w, "\n");
+
             fflush(clnt_w);
         
         }
@@ -205,7 +124,7 @@ int main(int argc, char **argv) {
         /*
          * clean up and quit
          */
-
+ 
         freemdb(&list);
 
        /*
@@ -220,15 +139,162 @@ int main(int argc, char **argv) {
             perror("clnt_r");
 
         // Resume server loop to handle next client connection.
+}
+
+static void sigchld_handler(int sig)
+{
+    // Keep reaping dead children until there aren't any to reap.
+    while (waitpid(-1, NULL, WNOHANG) > 0)
+        ;
+}
+
+
+int main(int argc, char **argv) {
+
+    /*
+     * Configure signal-handling.
+     */
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+
+    // Ignore SIGPIPE so that we don't terminate when we call
+    // send() on a disconnected socket.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction(SIGPIPE)");
+
+    // Install a handler for the SIGCHLD signal so that we can reap children
+    // who have finished processing their requests.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
+    sa.sa_handler = &sigchld_handler;
+    if (sigaction(SIGCHLD, &sa, NULL))
+        die("sigaction(SIGCHLD)");
+
+    /*
+     * Check and obtain command-line arguments
+     */
+    if (argc != 3) {
+        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
+        exit(1);
+    }
+
+    char *server_port = argv[1];
+    char *database = argv[2];
+
+    /*
+     * Construct socket address information using getaddrinfo().
+     */
+
+    // Define hints for getaddrinfo(), which we need to zero out first.
+    struct addrinfo hints;
+
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    // N.B. info actually points to a linked list of address information
+    // structures; assume that the first is sufficient and ignore the rest.
+
+    /*
+     * Create socket() and prepare it to accept() connections.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    // bind() socket to a port on the server; the port in info->ai_addr should
+    // be the same port that getaddrinfo() parsed from server_port.
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+        
+        pid_t pid = fork();
+        if (pid < 0)
+            die("fork");
+
+        if (pid > 0) {
+            /*
+             * Parent process:
+             *
+             * Close client socket and continue accept()ing connections.
+             */
+
+            close(clnt_fd);
+
+            continue;
+        }
+
+        /*
+         * Child process:
+         *
+         * Close server socket, handle the client, and exit.
+         */
+
+        close(serv_fd);
+
+        // clnt_addr is populated with information about the client.
+        fprintf(stderr, "Connection started: %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        handle_client(database, clnt_fd);
+
+        fprintf(stderr, "Connection terminated: %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+       
+        exit(0);
     }
    
    /*
     * UNREACHABLE
     */
     
-    if (fclose(fp) < 0)
-        perror("file");
-    
     close(serv_fd);
     return 0;
 }
-- 
2.34.1


From 9acec0aafb2a5401645ae224ffee41c01f95de52 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 02:56:44 -0500
Subject: [PATCH 4/9] Added the skeletal code for part2.

---
 README.txt          |   8 +-
 part2/Makefile      |  14 ++
 part2/http-server.c | 452 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 470 insertions(+), 4 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/http-server.c

diff --git a/README.txt b/README.txt
index 49c4472..08c20e8 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 7
+  - My programs should work as they are supposed to.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..6646a20
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,14 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+http-server:
+http-server.o:
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core http-server
+
+.PHONY: all
+all: clean http-server
diff --git a/part2/http-server.c b/part2/http-server.c
new file mode 100644
index 0000000..998e393
--- /dev/null
+++ b/part2/http-server.c
@@ -0,0 +1,452 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <linux/limits.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <unistd.h>
+
+#define MAXPENDING 5          // Maximum outstanding connection requests
+#define MAX_LINE_LENGTH 1024  // Maximum line length for request and headers
+#define DISK_IO_BUF_SIZE 4096 // Size of buffer for reading and sending files
+
+static void die(const char *message)
+{
+    perror(message);
+    exit(1);
+}
+
+/*
+ * HTTP/1.0 status codes and the corresponding reason phrases.
+ */
+static struct {
+    int status;
+    char *reason;
+} http_status_codes[] = {
+    { 200, "OK" },
+    { 201, "Created" },
+    { 202, "Accepted" },
+    { 204, "No Content" },
+    { 301, "Moved Permanently" },
+    { 302, "Moved Temporarily" },
+    { 304, "Not Modified" },
+    { 400, "Bad Request" },
+    { 401, "Unauthorized" },
+    { 403, "Forbidden" },
+    { 404, "Not Found" },
+    { 500, "Internal Server Error" },
+    { 501, "Not Implemented" },
+    { 502, "Bad Gateway" },
+    { 503, "Service Unavailable" },
+    { 0, NULL } // marks the end of the list
+};
+
+static inline const char *get_reason_phrase(int status_code)
+{
+    int i = -1;
+    while (http_status_codes[++i].status > 0)
+        if (http_status_codes[i].status == status_code)
+            return http_status_codes[i].reason;
+    return "Unknown Status Code";
+}
+
+/*
+ * Send HTTP status line.
+ *
+ * Returns negative if send() failed.
+ */
+static int send_status_line(FILE *fp, int status_code)
+{
+    const char *reason_phrase = get_reason_phrase(status_code);
+    return fprintf(fp, "HTTP/1.0 %d %s\r\n", status_code, reason_phrase);
+}
+
+/*
+ * Send blank line.
+ *
+ * Returns number of bytes sent; returns negative if failed.
+ */
+static int send_blank_line(FILE *fp)
+{
+    return fprintf(fp, "\r\n");
+}
+
+/*
+ * Send a generic HTTP response for error statuses (400+).
+ *
+ * Returns negative if failed.
+ */
+static int send_error_status(FILE *fp, int status_code)
+{
+    if (send_status_line(fp, status_code) < 0)
+        return -1;
+
+    // no headers needed
+    if (send_blank_line(fp) < 0)
+        return -1;
+
+    return fprintf(fp,
+        "<html><body>\n"
+        "<h1>%d %s</h1>\n"
+        "</body></html>\n",
+        status_code, get_reason_phrase(status_code));
+}
+
+/*
+ * Send 301 status: redirect the browser to request_uri with '/' appended to it.
+ *
+ * Returns negative if failed.
+ */
+static int send301(const char *request_uri, FILE *fp)
+{
+    if (send_status_line(fp, 301) < 0)
+        return -1;
+
+    // Send Location header and format redirection link in HTML in case browser
+    // doesn't automatically redirect.
+    return fprintf(fp,
+        "Location: %s/\r\n"
+        "\r\n"
+        "<html><body>\n"
+        "<h1>301 Moved Permanently</h1>\n"
+        "<p>The document has moved "
+        "<a href=\"%s/\">here</a>.</p>\n"
+        "</body></html>\n",
+        request_uri, request_uri);
+}
+
+/*
+ * Handle static file requests.
+ * Returns the HTTP status code that was sent to the browser.
+ *
+ * If send() ever fails (i.e., could not write to clnt_w), report the error and
+ * move on.
+ */
+static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w)
+{
+    /*
+     * Define variables that we will need to use before we return.
+     */
+
+    int status_code; // We'll return this value.
+    FILE *fp = NULL; // We'll fclose() this at the end.
+
+    // Set clnt_w to line-buffering so that lines are flushed immediately.
+    setlinebuf(clnt_w);
+
+    /*
+     * Construct the path of the requested file from web_root and request_uri.
+     */
+
+    char file_path[PATH_MAX];
+
+    if (strlen(web_root) + strlen(request_uri) + 12 > sizeof(file_path)) {
+        // File paths can't exceed sizeof(file_path) on Linux, so just 404.
+        status_code = 404; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    strcpy(file_path, web_root);
+
+    // Note: since the URI definitely begins with '/', we don't need to worry
+    // about appending '/' to web_root.
+
+    strcat(file_path, request_uri);
+
+    // If request_uri ends with '/', append "index.html".
+    if (file_path[strlen(file_path) - 1] == '/')
+        strcat(file_path, "index.html");
+
+    /*
+     * Open the requested file.
+     */
+
+    // See if the requested file is a directory.
+    struct stat st;
+    if (stat(file_path, &st) == 0 && S_ISDIR(st.st_mode)) {
+        status_code = 301; // "Moved Permanently"
+        if (send301(request_uri, clnt_w) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    // If unable to open the file, send "404 Not Found".
+    fp = fopen(file_path, "rb");
+    if (fp == NULL) {
+        status_code = 404; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    // Otherwise, send "200 OK".
+    status_code = 200; // "OK"
+    if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+        perror("send");
+        goto cleanup;
+    }
+
+    /*
+     * Send the file.
+     */
+
+    // Buffer for file contents.
+    char file_buf[DISK_IO_BUF_SIZE];
+
+    // Turn off buffering for clnt_w because we already have our own file_buf.
+    if (fflush(clnt_w) < 0) {
+        perror("send");
+        goto cleanup;
+    }
+    setbuf(clnt_w, NULL);
+
+    // Read and send file in a block at a time.
+    size_t n;
+    while ((n = fread(file_buf, 1, sizeof(file_buf), fp)) > 0) {
+        if (fwrite(file_buf, 1, n, clnt_w) != n) {
+            perror("send");
+            goto cleanup;
+        }
+    }
+
+    // fread() returns 0 both on EOF and on error; check if there was an error.
+    if (ferror(fp))
+        // Note that if we had an error, we sent the client a truncated (i.e.,
+        // corrupted) file; not much we can do about that at this point since
+        // we already sent the status...
+        perror("fread");
+
+cleanup:
+
+    /*
+     * close() the FILE pointer and return.
+     */
+
+    if (fp)
+        fclose(fp);
+
+    return status_code;
+}
+
+void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
+{
+    /*
+     * Open client file descriptor as FILE pointers.
+     */
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    if (clnt_r == NULL)
+        die("fdopen");
+
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+    if (clnt_w == NULL)
+        die("fdopen");
+
+    /*
+     * Let's parse the request line.
+     */
+
+    // Note: we'll use these fields at the end when we log the connection.
+    int status_code;
+    char *method = NULL, *request_uri = NULL, *http_version = NULL, *extra;
+
+    char request_buf[MAX_LINE_LENGTH];
+
+    if (fgets(request_buf, sizeof(request_buf), clnt_r) == NULL) {
+        // Socket closed prematurely; there isn't much we can do
+        status_code = 400; // "Bad Request"
+        goto terminate_connection;
+    }
+
+    char *token_separators = "\t \r\n"; // tab, space, new line
+
+    method = strtok(request_buf, token_separators);
+    request_uri = strtok(NULL, token_separators);
+    http_version = strtok(NULL, token_separators);
+    extra = strtok(NULL, token_separators);
+
+    // Note: We must not modify request_buf past this point, because method,
+    // request_uri, http_version, and extra point to within request_buf.
+
+    // Check that we have exactly three tokens in the request line.
+    if (!method || !request_uri || !http_version || extra) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // We only support GET requests.
+    if (strcmp(method, "GET")) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // We only support HTTP/1.0 and HTTP/1.1.
+    if (strcmp(http_version, "HTTP/1.0") && strcmp(http_version, "HTTP/1.1")) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // request_uri must begin with "/".
+    if (!request_uri || *request_uri != '/') {
+        status_code = 400; // "Bad Request"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // Ensure request_uri does not contain "/../" and does not end with "/..".
+    int uri_len = strlen(request_uri);
+    if (uri_len >= 3) {
+        char *tail = request_uri + (uri_len - 3);
+        if (strcmp(tail, "/..") == 0 || strstr(request_uri, "/../") != NULL) {
+            status_code = 400; // "Bad Request"
+            send_error_status(clnt_w, status_code);
+            goto terminate_connection;
+        }
+    }
+
+    /*
+     * Skip HTTP headers.
+     */
+
+    // We need another buffer for trashing the headers, because request_buf
+    // still currently holds the method, request_uri, and http_version strings.
+    char line_buf[MAX_LINE_LENGTH];
+
+    while (1) {
+        if (fgets(line_buf, sizeof(line_buf), clnt_r) == NULL) {
+            // Socket closed prematurely; there isn't much we can do
+            status_code = 400; // "Bad Request"
+            goto terminate_connection;
+        }
+
+        // Check if we have reached the end of the headers, i.e., an empty line.
+        if (strcmp("\r\n", line_buf) == 0 || strcmp("\n", line_buf) == 0)
+            break;
+    }
+
+    /*
+     * We have a well-formed HTTP GET request; time to handle it.
+     */
+
+    status_code = handle_file_request(web_root, request_uri, clnt_w);
+
+terminate_connection:
+
+    /*
+     * Done with client request; close the connection and log the transaction.
+     */
+
+    // Closing can FILE pointers can also produce errors, which we log.
+    if (fclose(clnt_w) < 0)
+        perror("send");
+
+    if (fclose(clnt_r) < 0)
+        perror("recv");
+
+    fprintf(stderr, "%s \"%s %s %s\" %d %s\n",
+        clnt_ip,
+        method,
+        request_uri,
+        http_version,
+        status_code,
+        get_reason_phrase(status_code));
+}
+
+int main(int argc, char *argv[])
+{
+    /*
+     * Configure signal-handling.
+     */
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+
+    // Ignore SIGPIPE so that we don't terminate when we call
+    // send() on a disconnected socket.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction(SIGPIPE)");
+
+    /*
+     * Parse arguments.
+     */
+
+    if (argc != 3) {
+        fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv[0]);
+        exit(1);
+    }
+
+    char *serv_port = argv[1];
+    char *web_root = argv[2];
+
+    /*
+     * Construct server socket to listen on serv_port.
+     */
+
+    struct addrinfo hints, *info;
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, serv_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    freeaddrinfo(info);
+
+    /*
+     * Server accept() loop.
+     */
+
+    for (;;) {
+        // We only need sockaddr_in since we only accept IPv4 peers.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_len = sizeof(clnt_addr);
+
+        int clnt_fd = accept(serv_fd, (struct sockaddr *)&clnt_addr, &clnt_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        char clnt_ip[INET_ADDRSTRLEN];
+
+        if (inet_ntop(AF_INET, &clnt_addr.sin_addr, clnt_ip, sizeof(clnt_ip))
+            == NULL)
+            die("inet_ntop");
+
+        handle_client(web_root, clnt_fd, clnt_ip);
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    close(serv_fd);
+
+    return 0;
+}
-- 
2.34.1


From de8e9262d9f21956eb524d448b8ee747d84ba0a7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 17:41:04 -0500
Subject: [PATCH 5/9] Now, part2 works partially. When mdb-lookup is called, it
 always prints the default page.

---
 part2/http-server.c | 99 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 93 insertions(+), 6 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 998e393..8748882 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -127,7 +127,21 @@ static int send301(const char *request_uri, FILE *fp)
  * If send() ever fails (i.e., could not write to clnt_w), report the error and
  * move on.
  */
-static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w)
+
+static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
+    const char *form =
+          "<h1>mdb-lookup</h1>\n"
+          "<p>\n"
+          "<form method=GET action=/mdb-lookup>\n"
+          "lookup: <input type=text name=key>\n"
+          "<input type=submit>\n"
+          "</form>\n"
+          "<p>\n";
+
+    fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form);
+}
+
+static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
 {
     /*
      * Define variables that we will need to use before we return.
@@ -138,6 +152,21 @@ static int handle_file_request(const char *web_root, const char *request_uri, FI
 
     // Set clnt_w to line-buffering so that lines are flushed immediately.
     setlinebuf(clnt_w);
+    
+    // enter if uri is /mdb-lookup or it starts with /mdb-lookup?
+    if(!strcmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "/mdb-lookup?", 12)){
+     
+        status_code = 200; // "OK"
+        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+            perror("send");
+            goto cleanup;
+        }
+
+        // return the result
+        handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        
+        goto cleanup;
+    }
+
 
     /*
      * Construct the path of the requested file from web_root and request_uri.
@@ -235,7 +264,7 @@ cleanup:
     return status_code;
 }
 
-void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
+void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip, FILE *mdb_r, FILE *mdb_w)
 {
     /*
      * Open client file descriptor as FILE pointers.
@@ -337,7 +366,7 @@ void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
      * We have a well-formed HTTP GET request; time to handle it.
      */
 
-    status_code = handle_file_request(web_root, request_uri, clnt_w);
+    status_code = handle_file_request(web_root, request_uri, clnt_w, mdb_r, mdb_w);
 
 terminate_connection:
 
@@ -382,13 +411,15 @@ int main(int argc, char *argv[])
      * Parse arguments.
      */
 
-    if (argc != 3) {
-        fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv[0]);
+    if (argc != 5) {
+        fprintf(stderr, "usage: %s <server-port> <web-root> <mdb-host> <mdb-port>\n", argv[0]);
         exit(1);
     }
 
     char *serv_port = argv[1];
     char *web_root = argv[2];
+    char *mdb_host = argv[3];
+    char *mdb_port = argv[4];
 
     /*
      * Construct server socket to listen on serv_port.
@@ -420,6 +451,60 @@ int main(int argc, char *argv[])
 
     freeaddrinfo(info);
 
+    /*
+     * Construct client socket to connect to mdb-lookup-server.
+     */
+
+    // Zero out hints first.
+    memset(&hints, 0, sizeof(hints));
+
+    // Specify what kind of connection we intend to make; these values tell
+    // getaddrinfo() that we don't care about other kinds of addresses.
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info_mdb;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    if ((addr_err = getaddrinfo(mdb_host, mdb_port, &hints, &info_mdb)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    /*
+     * Create socket() and connect() it to server.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int mdb_fd = socket(info_mdb->ai_family, info_mdb->ai_socktype, info_mdb->ai_protocol);
+    if (mdb_fd < 0)
+        die("socket");
+
+    // Connect socket with server address; the IP address and port in
+    // info->ai_addr should be the same address and port that getaddrinfo()
+    // parsed from server_address and server_port.
+    if (connect(mdb_fd, info_mdb->ai_addr, info_mdb->ai_addrlen) < 0)
+        die("connect");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info_mdb);
+
+    /*
+     * Open mdb-lookup-server file descriptor as FILE pointers.
+     */
+    FILE *mdb_r = fdopen(mdb_fd, "rb");
+    if (mdb_r == NULL)
+        die("fdopen");
+
+    FILE *mdb_w = fdopen(dup(mdb_fd), "wb");
+    if (mdb_w == NULL)
+        die("fdopen");
     /*
      * Server accept() loop.
      */
@@ -439,13 +524,15 @@ int main(int argc, char *argv[])
             == NULL)
             die("inet_ntop");
 
-        handle_client(web_root, clnt_fd, clnt_ip);
+        handle_client(web_root, clnt_fd, clnt_ip, mdb_r, mdb_w);
     }
 
     /*
      * UNREACHABLE
      */
 
+    fclose(mdb_r);
+    fclose(mdb_w);
     close(serv_fd);
 
     return 0;
-- 
2.34.1


From 537bcddf9cea379212bb4ffafff70962f1692dfc Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 20:46:04 -0500
Subject: [PATCH 6/9] I am not quite sure, but it seems like part2 is working
 okay now. I have to check if the memory leaks are constant.

---
 part2/http-server.c | 65 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 63 insertions(+), 2 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 8748882..7de5023 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -130,7 +130,7 @@ static int send301(const char *request_uri, FILE *fp)
 
 static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
     const char *form =
-          "<h1>mdb-lookup</h1>\n"
+          "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n"
           "<p>\n"
           "<form method=GET action=/mdb-lookup>\n"
           "lookup: <input type=text name=key>\n"
@@ -138,7 +138,65 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
           "</form>\n"
           "<p>\n";
 
-    fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form);
+    if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
+        if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
+            perror("send");
+        return;
+    }
+                
+    fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
+
+    char key[strlen(request + 5) + 1];
+        
+    fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
+    
+    strncpy(key, request + 5, sizeof(key) - 1);
+
+    key[sizeof(key)  - 1] = '\n';
+    
+    fwrite(key, sizeof(key), 1, stderr);
+
+    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){
+        perror("send");
+        return;
+    }
+
+    // Buffer for result of lookup.
+    char result_buf[500];
+    int isYellow = 0;
+
+    if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
+        perror("send");
+
+    while(fgets(result_buf, sizeof(result_buf), mdb_r) != NULL ) {
+        if(!strcmp(result_buf, "\n")){
+            fprintf(stderr,"I found newline character at the response!\n");
+            break;
+        }
+
+        if(isYellow){
+            if(fprintf(clnt_w, "<tr><td bgcolor=yellow>\n%s\n", result_buf) < 0)
+            perror("send");
+            isYellow = 0;
+        }else{
+            if(fprintf(clnt_w, "<tr><td>\n%s\n", result_buf) < 0)
+            perror("send");
+            isYellow = 1;
+        }
+    }
+    
+    if(ferror(mdb_r))
+        perror("mdb_lookup_server");
+
+
+    if(fprintf(clnt_w, "</table>\n</body></html>\n") < 0)
+        perror("send");
+ 
+
+    if (fflush(clnt_w) < 0)
+        perror("send");
+
+    return;
 }
 
 static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
@@ -505,6 +563,9 @@ int main(int argc, char *argv[])
     FILE *mdb_w = fdopen(dup(mdb_fd), "wb");
     if (mdb_w == NULL)
         die("fdopen");
+
+    setbuf(mdb_w, NULL);
+
     /*
      * Server accept() loop.
      */
-- 
2.34.1


From 66f20d2a0fe0a1547190d4a34e9d2bb0ec00daa6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 23:27:33 -0500
Subject: [PATCH 7/9] Now part2 can send 500 Internal Server Error.

---
 part2/http-server.c | 34 +++++++++++++++++++++-------------
 1 file changed, 21 insertions(+), 13 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 7de5023..44281c4 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -128,20 +128,22 @@ static int send301(const char *request_uri, FILE *fp)
  * move on.
  */
 
-static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
+static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
     const char *form =
-          "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n"
+          "<h1>mdb-lookup</h1>\n"
           "<p>\n"
           "<form method=GET action=/mdb-lookup>\n"
           "lookup: <input type=text name=key>\n"
           "<input type=submit>\n"
           "</form>\n"
           "<p>\n";
+        
+    int status_code;
 
     if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
         if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
             perror("send");
-        return;
+        return 1;
     }
                 
     fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
@@ -156,15 +158,23 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
     
     fwrite(key, sizeof(key), 1, stderr);
 
-    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){
+    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){ 
         perror("send");
-        return;
+        status_code = 500; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        return 0;
     }
 
     // Buffer for result of lookup.
     char result_buf[500];
     int isYellow = 0;
 
+    status_code = 200; // "OK"
+    if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+        perror("send");
+    }
+
     if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
         perror("send");
 
@@ -196,7 +206,7 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
     if (fflush(clnt_w) < 0)
         perror("send");
 
-    return;
+    return 1;
 }
 
 static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
@@ -213,15 +223,13 @@ static int handle_file_request(const char *web_root, const char *request_uri, FI
     
     // enter if uri is /mdb-lookup or it starts with /mdb-lookup?
     if(!strcmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "/mdb-lookup?", 12)){
-     
-        status_code = 200; // "OK"
-        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
-            perror("send");
-            goto cleanup;
-        }
 
         // return the result
-        handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        
+        if(handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w)){
+            status_code = 200;
+        }else{
+            status_code = 500;
+        }     
         goto cleanup;
     }
 
-- 
2.34.1


From abd922f7427ed2fb37f27b4d2ded014a2f972f12 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 11 Dec 2022 03:16:46 -0500
Subject: [PATCH 8/9] Fixed a little bug when the default lookup page is
 printed.

---
 part2/http-server.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/part2/http-server.c b/part2/http-server.c
index 44281c4..d581745 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -141,6 +141,10 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
     int status_code;
 
     if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
+        status_code = 200; // "OK"
+        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0)
+            perror("send");
+
         if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
             perror("send");
         return 1;
-- 
2.34.1


From 8b71c382d86a5a0205505a6a219936b46b72e707 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 14 Dec 2022 17:50:47 -0500
Subject: [PATCH 9/9] Final commit!

---
 part2/http-server.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index d581745..c5635b4 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -150,20 +150,20 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
         return 1;
     }
                 
-    fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
+    //fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
 
     char key[strlen(request + 5) + 1];
         
-    fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
+    //fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
     
     strncpy(key, request + 5, sizeof(key) - 1);
 
     key[sizeof(key)  - 1] = '\n';
     
-    fwrite(key, sizeof(key), 1, stderr);
+    //fwrite(key, sizeof(key), 1, stderr);
 
     if(fwrite(key, sizeof(key), 1, mdb_w) != 1){ 
-        perror("send");
+        perror("mdb-lookup-server send");
         status_code = 500; // "Not Found"
         if (send_error_status(clnt_w, status_code) < 0)
             perror("send");
@@ -182,9 +182,10 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
     if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
         perror("send");
 
+    int i = 1;
     while(fgets(result_buf, sizeof(result_buf), mdb_r) != NULL ) {
         if(!strcmp(result_buf, "\n")){
-            fprintf(stderr,"I found newline character at the response!\n");
+            i = 0;
             break;
         }
 
@@ -199,8 +200,11 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
         }
     }
     
+    if(i)
+        perror("mdb-lookup-server recv");
+
     if(ferror(mdb_r))
-        perror("mdb_lookup_server");
+        perror("mdb-lookup-server");
 
 
     if(fprintf(clnt_w, "</table>\n</body></html>\n") < 0)
-- 
2.34.1


--8npxk+dsqscB+TCs
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab7.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 5b3cf0a1b0e8127cf80fa450a98c1d32513c8579 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Thu, 8 Dec 2022 22:05:32 =
-0500=0ASubject: [PATCH 1/9] First commit.=0A=0A---=0A part1/Makefile      =
      |  22 +++++=0A part1/mdb-lookup-server.c | 174 ++++++++++++++++++++++=
++++++++++++++++=0A part1/mdb.c               |  53 ++++++++++++=0A part1/m=
db.h               |  18 +++-=0A 4 files changed, 264 insertions(+), 3 dele=
tions(-)=0A create mode 100644 part1/Makefile=0A create mode 100644 part1/m=
db-lookup-server.c=0A create mode 100644 part1/mdb.c=0A=0Adiff --git a/part=
1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 0000000..6f5a47e=
=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,22 @@=0A+CC =3D gcc=0A=
+=0A+# Support externally overriding CFLAGS=0A+CFLAGS ?=3D -g -Wall -Wpedan=
tic -std=3Dc17=0A+CFLAGS +=3D -I/home/j-hui/cs3157-pub/include=0A+=0A+LDFLA=
GS =3D -L/home/j-hui/cs3157-pub/lib=0A+LDLIBS =3D -lmylist=0A+=0A+.PHONY: d=
efault=0A+default: mdb-lookup-server=0A+=0A+mdb-lookup-server: mdb-lookup-s=
erver.o mdb.o=0A+mdb-lookup-server.o: mdb-lookup-server.c mdb.h=0A+mdb.o: m=
db.h=0A+	=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core mdb-lookup-se=
rver=0A+=0A+.PHONY: all=0A+all: clean default=0Adiff --git a/part1/mdb-look=
up-server.c b/part1/mdb-lookup-server.c=0Anew file mode 100644=0Aindex 0000=
000..7072e1f=0A--- /dev/null=0A+++ b/part1/mdb-lookup-server.c=0A@@ -0,0 +1=
,174 @@=0A+#define _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#include <linux=
/limits.h>=0A+#include <netdb.h>=0A+#include <signal.h>=0A+#include <stdio.=
h>=0A+#include <stdlib.h>=0A+#include <string.h>=0A+#include <sys/socket.h>=
=0A+#include <sys/stat.h>=0A+#include <sys/types.h>=0A+#include <sys/wait.h=
>=0A+#include <time.h>=0A+#include <unistd.h>=0A+#include <mylist.h>=0A+#in=
clude "mdb.h"=0A+=0A+#define KeyMax 5=0A+#define MAX_LINE_LENGTH 1024  // M=
aximum line length for request and headers=0A+#define DISK_IO_BUF_SIZE 4096=
 // Size of buffer for reading and sending files=0A+=0A+static void die(con=
st char *message)=0A+{=0A+    perror(message);=0A+    exit(1);=0A+}=0A+=0A+=
int main(int argc, char **argv) {=0A+    /*=0A+     * Check and obtain comm=
and-line arguments=0A+     */=0A+    if (argc !=3D 2) {=0A+        fprintf(=
stderr, "Usage: %s <server-port> <database>\n", argv[0]);=0A+        exit(1=
);=0A+    }=0A+=0A+    char *server_port =3D argv[1];=0A+    char *database=
 =3D argv[2];=0A+=0A+    /*=0A+     * Construct socket address information =
using getaddrinfo().=0A+     */=0A+=0A+    // Define hints for getaddrinfo(=
), which we need to zero out first.=0A+    struct addrinfo hints;=0A+=0A+  =
  memset(&hints, 0, sizeof(hints));=0A+=0A+    hints.ai_family =3D AF_INET;=
        // Only accept IPv4 addresses=0A+    hints.ai_socktype =3D SOCK_STR=
EAM;  // stream socket for TCP connections=0A+    hints.ai_protocol =3D IPP=
ROTO_TCP;  // TCP protocol=0A+    hints.ai_flags =3D AI_PASSIVE;      // Co=
nstruct socket address for bind()ing=0A+=0A+    // Define where getaddrinfo=
() will return the information it found.=0A+    struct addrinfo *info;=0A+=
=0A+    // Call getaddrinfo(), specifying the server IP address and port as=
 strings.=0A+    // getaddrinfo() will parse those for us and point info to=
 the result.=0A+    int addr_err;=0A+    if ((addr_err =3D getaddrinfo(NULL=
, server_port, &hints, &info)) !=3D 0) {=0A+        fprintf(stderr, "getadd=
rinfo: %s\n", gai_strerror(addr_err));=0A+        exit(1);=0A+    }=0A+=0A+=
    // N.B. info actually points to a linked list of address information=0A=
+    // structures; assume that the first is sufficient and ignore the rest=
=2E=0A+=0A+    /*=0A+     * Create socket() and prepare it to accept() conn=
ections.=0A+     */=0A+=0A+    // Create socket() according to the address =
family, socket type, and=0A+    // protocol of the address info.  Since we =
specified AF_INET, SOCK_STREAM,=0A+    // and IPPROTO_TCP in the hints, thi=
s should be equivalent to just calling=0A+    // socket(AF_INET, SOCK_STREA=
M, IPPROTO_TCP).=0A+    int serv_fd =3D socket(info->ai_family, info->ai_so=
cktype, info->ai_protocol);=0A+    if (serv_fd < 0)=0A+        die("socket"=
);=0A+=0A+    // bind() socket to a port on the server; the port in info->a=
i_addr should=0A+    // be the same port that getaddrinfo() parsed from ser=
ver_port.=0A+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A=
+        die("bind");=0A+=0A+    // BTW: we're done with the info retrieved=
 by getaddrinfo(), so free it.=0A+    freeaddrinfo(info);=0A+=0A+    // Sta=
rt listen()ing for connections on this socket, maintaining a queue of=0A+  =
  // at most 8 pending connections.=0A+    if (listen(serv_fd, 8) < 0)=0A+ =
       die("listen");=0A+=0A+    for (;;) {=0A+=0A+        /*=0A+         *=
 accept() connection from client.=0A+         */=0A+=0A+        // Define s=
pace to receive client address info.=0A+        struct sockaddr_in clnt_add=
r;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+       =
 // accept() blocks until a client connects with the server, and returns=0A=
+        // a NEW socket file descriptor for interacting with the client.=
=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &clnt_addr,=
=0A+                             &clnt_addr_len);=0A+        if (clnt_fd < =
0)=0A+            die("accept");=0A+=0A+        // clnt_addr is now populat=
ed with information about the client.=0A+        fprintf(stderr, "Accepted =
connection from %s\n",=0A+                inet_ntoa(clnt_addr.sin_addr));=
=0A+=0A+        /*=0A+         * Handle client connection.=0A+         */=
=0A+=0A+        FILE *fp =3D fopen(database, "rb");=0A+        if (fp =3D=
=3D NULL)=0A+            die(database);=0A+=0A+        /*=0A+         * rea=
d all records into memory=0A+         */=0A+=0A+        struct List list;=
=0A+        initList(&list);=0A+=0A+        int loaded =3D loadmdb(fp, &lis=
t);=0A+        if (loaded < 0)=0A+            die("loadmdb");=0A+=0A+      =
  if (fclose(fp) < 0)=0A+            perror("file");=0A+        =0A+       =
 /*=0A+         * lookup loop=0A+         */=0A+        =0A+        char li=
ne[1024];=0A+        char key[KeyMax + 1];=0A+=0A+       =0A+        // cle=
ar up the key!!=0A+        =0A+        // open a file pointer=0A+        //=
 make =0A+=0A+       /*=0A+        * search with key=0A+        */=0A+=0A+ =
       // traverse the list, printing out the matching records=0A+        s=
truct Node *node =3D list.head;=0A+        int recNo =3D 1;=0A+        whil=
e (node) {=0A+            struct MdbRec *rec =3D (struct MdbRec *)node->dat=
a;=0A+=0A+            if (strstr(rec->name, key) || strstr(rec->msg, key))=
=0A+                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->n=
ame, rec->msg);=0A+=0A+            node =3D node->next;=0A+            recN=
o++;=0A+        }=0A+=0A+        // Close client connection.=0A+        clo=
se(clnt_fd);=0A+=0A+        // Resume server loop to handle next client con=
nection.=0A+    }=0A+=0A+    close(serv_fd);=0A+    return 0;=0A+}=0Adiff -=
-git a/part1/mdb.c b/part1/mdb.c=0Anew file mode 100644=0Aindex 0000000..ce=
5243a=0A--- /dev/null=0A+++ b/part1/mdb.c=0A@@ -0,0 +1,53 @@=0A+/*=0A+ * md=
b.c=0A+ */=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <st=
ring.h>=0A+=0A+#include <mylist.h>=0A+=0A+#include "mdb.h"=0A+=0A+int loadm=
db(FILE *fp, struct List *dest)=0A+{=0A+    /*=0A+     * read all records i=
nto memory=0A+     */=0A+=0A+    struct MdbRec r;=0A+    struct Node *node =
=3D NULL;=0A+    int count =3D 0;=0A+=0A+    while (fread(&r, sizeof(r), 1,=
 fp) =3D=3D 1) {=0A+=0A+        // allocate memory for a new record and cop=
y into it the one=0A+        // that was just read from the database.=0A+  =
      struct MdbRec *rec =3D (struct MdbRec *)malloc(sizeof(r));=0A+       =
 if (!rec)=0A+            return -1;=0A+=0A+        memcpy(rec, &r, sizeof(=
r));=0A+=0A+        // add the record to the linked list.=0A+        node =
=3D addAfter(dest, node, rec);=0A+        if (node =3D=3D NULL)=0A+        =
    return -1;=0A+=0A+        count++;=0A+    }=0A+=0A+    // see if fread(=
) produced error=0A+    if (ferror(fp))=0A+        return -1;=0A+=0A+    re=
turn count;=0A+}=0A+=0A+void freemdb(struct List *list)=0A+{=0A+    // free=
 all the records=0A+    traverseList(list, &free);=0A+    removeAllNodes(li=
st);=0A+}=0Adiff --git a/part1/mdb.h b/part1/mdb.h=0Aindex fb091b5..6712a6c=
 100644=0A--- a/part1/mdb.h=0A+++ b/part1/mdb.h=0A@@ -1,9 +1,21 @@=0A-#ifnd=
ef __MDB_H__=0A-#define __MDB_H__=0A+/*=0A+ * mdb.h=0A+ */=0A+=0A+#ifndef _=
MDB_H_=0A+#define _MDB_H_=0A+=0A+#include <stdio.h>=0A+=0A+#include <mylist=
=2Eh>=0A =0A struct MdbRec {=0A     char name[16];=0A     char msg[24];=0A =
};=0A =0A-#endif=0A+int loadmdb(FILE *fp, struct List *dest);=0A+void freem=
db(struct List *list);=0A+=0A+#endif /* _MDB_H_ */=0A+=0A-- =0A2.34.1=0A=0A=
=0AFrom af5c8ebf61fc2d15148c940e57849615ab8a723d Mon Sep 17 00:00:00 2001=
=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 9 Dec 2022 23:46:19=
 -0500=0ASubject: [PATCH 2/9] I managed to get mdb-lookup-server working, b=
ut it only=0A can handle one process for now.=0A=0A---=0A part1/Makefile   =
         |  10 ++--=0A part1/mdb-lookup-server.c | 116 ++++++++++++++++++++=
+++++++++---------=0A 2 files changed, 94 insertions(+), 32 deletions(-)=0A=
=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex 6f5a47e..3dc4b25 10=
0644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -7,13 +7,15 @@ CFLA=
GS +=3D -I/home/j-hui/cs3157-pub/include=0A LDFLAGS =3D -L/home/j-hui/cs315=
7-pub/lib=0A LDLIBS =3D -lmylist=0A =0A+mdb-lookup-server: mdb-lookup-serve=
r.o mdb.o=0A+=0A+mdb.o: mdb.c mdb.h=0A+=0A+mdb-lookup-server.o: mdb-lookup-=
server.c mdb.h=0A+=0A .PHONY: default=0A default: mdb-lookup-server=0A =0A-=
mdb-lookup-server: mdb-lookup-server.o mdb.o=0A-mdb-lookup-server.o: mdb-lo=
okup-server.c mdb.h=0A-mdb.o: mdb.h=0A-	=0A .PHONY: clean=0A clean:=0A 	rm =
-f *.o a.out core mdb-lookup-server=0Adiff --git a/part1/mdb-lookup-server.=
c b/part1/mdb-lookup-server.c=0Aindex 7072e1f..bb1a9fe 100644=0A--- a/part1=
/mdb-lookup-server.c=0A+++ b/part1/mdb-lookup-server.c=0A@@ -29,7 +29,7 @@ =
int main(int argc, char **argv) {=0A     /*=0A      * Check and obtain comm=
and-line arguments=0A      */=0A-    if (argc !=3D 2) {=0A+    if (argc !=
=3D 3) {=0A         fprintf(stderr, "Usage: %s <server-port> <database>\n",=
 argv[0]);=0A         exit(1);=0A     }=0A@@ -37,6 +37,11 @@ int main(int a=
rgc, char **argv) {=0A     char *server_port =3D argv[1];=0A     char *data=
base =3D argv[2];=0A =0A+    // Open the database file=0A+    FILE *fp =3D =
fopen(database, "rb");=0A+    if (fp =3D=3D NULL)=0A+        die(database);=
=0A+=0A     /*=0A      * Construct socket address information using getaddr=
info().=0A      */=0A@@ -114,10 +119,18 @@ int main(int argc, char **argv) =
{=0A         /*=0A          * Handle client connection.=0A          */=0A+ =
       =0A+       =0A+        /*=0A+        * Open client file descriptor a=
s FILE pointers.=0A+        */=0A+        FILE *clnt_r =3D fdopen(clnt_fd, =
"rb");=0A+        if (clnt_r =3D=3D NULL)=0A+            die("fdopen");=0A =
=0A-        FILE *fp =3D fopen(database, "rb");=0A-        if (fp =3D=3D NU=
LL)=0A-            die(database);=0A+        FILE *clnt_w =3D fdopen(dup(cl=
nt_fd), "wb");=0A+        if (clnt_w =3D=3D NULL)=0A+            die("fdope=
n");=0A =0A         /*=0A          * read all records into memory=0A@@ -130=
,45 +143,92 @@ int main(int argc, char **argv) {=0A         if (loaded < 0)=
=0A             die("loadmdb");=0A =0A-        if (fclose(fp) < 0)=0A-     =
       perror("file");=0A+        fseek(fp, 0, SEEK_SET);   =0A         =0A=
         /*=0A          * lookup loop=0A          */=0A-        =0A+       =
       =0A         char line[1024];=0A         char key[KeyMax + 1];=0A-=0A=
-       =0A-        // clear up the key!!=0A+         =0A+        while(fge=
ts(line, sizeof(line), clnt_r) !=3D NULL){=0A+  =0A+            /*=0A+     =
        * clean up user input=0A+             */=0A+            =0A+       =
     if(strlen(line) >=3D 2 && line[strlen(line)-2] =3D=3D '\r'){=0A+      =
          line[strlen(line)-2] =3D '\n';=0A+                line[strlen(lin=
e)-1] =3D 0;=0A+            }=0A+=0A+            // must null-terminate the=
 string manually after strncpy().=0A+            strncpy(key, line, sizeof(=
key) - 1);=0A+            key[sizeof(key) - 1] =3D '\0';=0A+=0A+           =
 // if newline is within the first KeyMax characters, remove it.=0A+       =
     size_t last =3D strlen(key) - 1;=0A+            if (key[last] =3D=3D '=
\n')=0A+                key[last] =3D '\0';=0A+=0A+            // user migh=
t have typed more than sizeof(line) - 1 characters in line;=0A+            =
// continue fgets()ing until we encounter a newline.=0A+            while (=
line[strlen(line) - 1] !=3D '\n' && fgets(line, sizeof(line), clnt_r))=0A+ =
               ;=0A+=0A+            /*=0A+             * search with key=0A=
+             */=0A+=0A+            // traverse the list, printing out the =
matching records=0A+            struct Node *node =3D list.head;=0A+       =
     int recNo =3D 1;=0A+            while (node) {=0A+                stru=
ct MdbRec *rec =3D (struct MdbRec *)node->data;=0A+=0A+                if (=
strstr(rec->name, key) || strstr(rec->msg, key))=0A+                    fpr=
intf(clnt_w, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);=0A+=0A+ =
               node =3D node->next;=0A+                recNo++;=0A+        =
    }=0A+            =0A+            fflush(clnt_w);=0A         =0A-       =
 // open a file pointer=0A-        // make =0A+        }=0A+       =0A+    =
    // see if fgets() produced error CHECK THIS! SHOULD YOU DIE?=0A+       =
 if (ferror(clnt_r))=0A+            perror("clnt_r");=0A =0A-       /*=0A- =
       * search with key=0A-        */=0A+        /*=0A+         * clean up=
 and quit=0A+         */=0A =0A-        // traverse the list, printing out =
the matching records=0A-        struct Node *node =3D list.head;=0A-       =
 int recNo =3D 1;=0A-        while (node) {=0A-            struct MdbRec *r=
ec =3D (struct MdbRec *)node->data;=0A+        freemdb(&list);=0A =0A-     =
       if (strstr(rec->name, key) || strstr(rec->msg, key))=0A-            =
    fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);=
=0A+       /*=0A+        * Done with client request; close the connection a=
nd log the transaction.=0A+        */=0A =0A-            node =3D node->nex=
t;=0A-            recNo++;=0A-        }=0A+        // Closing can FILE poin=
ters can also produce errors, which we log.=0A+        if (fclose(clnt_w) <=
 0)=0A+            perror("clnt_w");=0A =0A-        // Close client connect=
ion.=0A-        close(clnt_fd);=0A+        if (fclose(clnt_r) < 0)=0A+     =
       perror("clnt_r");=0A =0A         // Resume server loop to handle nex=
t client connection.=0A     }=0A-=0A+   =0A+   /*=0A+    * UNREACHABLE=0A+ =
   */=0A+    =0A+    if (fclose(fp) < 0)=0A+        perror("file");=0A+    =
=0A     close(serv_fd);=0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom f=
9827408c9474f66f2efa62a5ac50dc3438824dd Mon Sep 17 00:00:00 2001=0AFrom: Ar=
man Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 01:36:14 -0500=0AS=
ubject: [PATCH 3/9] I did part 1.=0A=0A---=0A part1/mdb-lookup-server.c | 2=
62 ++++++++++++++++++++++++--------------=0A 1 file changed, 164 insertions=
(+), 98 deletions(-)=0A=0Adiff --git a/part1/mdb-lookup-server.c b/part1/md=
b-lookup-server.c=0Aindex bb1a9fe..f523464 100644=0A--- a/part1/mdb-lookup-=
server.c=0A+++ b/part1/mdb-lookup-server.c=0A@@ -25,101 +25,16 @@ static vo=
id die(const char *message)=0A     exit(1);=0A }=0A =0A-int main(int argc, =
char **argv) {=0A-    /*=0A-     * Check and obtain command-line arguments=
=0A-     */=0A-    if (argc !=3D 3) {=0A-        fprintf(stderr, "Usage: %s=
 <server-port> <database>\n", argv[0]);=0A-        exit(1);=0A-    }=0A-=0A=
-    char *server_port =3D argv[1];=0A-    char *database =3D argv[2];=0A-=
=0A-    // Open the database file=0A-    FILE *fp =3D fopen(database, "rb")=
;=0A-    if (fp =3D=3D NULL)=0A-        die(database);=0A-=0A-    /*=0A-   =
  * Construct socket address information using getaddrinfo().=0A-     */=0A=
-=0A-    // Define hints for getaddrinfo(), which we need to zero out first=
=2E=0A-    struct addrinfo hints;=0A-=0A-    memset(&hints, 0, sizeof(hints=
));=0A-=0A-    hints.ai_family =3D AF_INET;        // Only accept IPv4 addr=
esses=0A-    hints.ai_socktype =3D SOCK_STREAM;  // stream socket for TCP c=
onnections=0A-    hints.ai_protocol =3D IPPROTO_TCP;  // TCP protocol=0A-  =
  hints.ai_flags =3D AI_PASSIVE;      // Construct socket address for bind(=
)ing=0A-=0A-    // Define where getaddrinfo() will return the information i=
t found.=0A-    struct addrinfo *info;=0A-=0A-    // Call getaddrinfo(), sp=
ecifying the server IP address and port as strings.=0A-    // getaddrinfo()=
 will parse those for us and point info to the result.=0A-    int addr_err;=
=0A-    if ((addr_err =3D getaddrinfo(NULL, server_port, &hints, &info)) !=
=3D 0) {=0A-        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_=
err));=0A-        exit(1);=0A-    }=0A-=0A-    // N.B. info actually points=
 to a linked list of address information=0A-    // structures; assume that =
the first is sufficient and ignore the rest.=0A-=0A-    /*=0A-     * Create=
 socket() and prepare it to accept() connections.=0A-     */=0A-=0A-    // =
Create socket() according to the address family, socket type, and=0A-    //=
 protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,=0A=
-    // and IPPROTO_TCP in the hints, this should be equivalent to just cal=
ling=0A-    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).=0A-    int serv_f=
d =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=0A-   =
 if (serv_fd < 0)=0A-        die("socket");=0A-=0A-    // bind() socket to =
a port on the server; the port in info->ai_addr should=0A-    // be the sam=
e port that getaddrinfo() parsed from server_port.=0A-    if (bind(serv_fd,=
 info->ai_addr, info->ai_addrlen) < 0)=0A-        die("bind");=0A-=0A-    /=
/ BTW: we're done with the info retrieved by getaddrinfo(), so free it.=0A-=
    freeaddrinfo(info);=0A-=0A-    // Start listen()ing for connections on =
this socket, maintaining a queue of=0A-    // at most 8 pending connections=
=2E=0A-    if (listen(serv_fd, 8) < 0)=0A-        die("listen");=0A-=0A-   =
 for (;;) {=0A-=0A-        /*=0A-         * accept() connection from client=
=2E=0A-         */=0A-=0A-        // Define space to receive client address=
 info.=0A-        struct sockaddr_in clnt_addr;=0A-        socklen_t clnt_a=
ddr_len =3D sizeof(clnt_addr);=0A-=0A-        // accept() blocks until a cl=
ient connects with the server, and returns=0A-        // a NEW socket file =
descriptor for interacting with the client.=0A-        int clnt_fd =3D acce=
pt(serv_fd, (struct sockaddr *) &clnt_addr,=0A-                            =
 &clnt_addr_len);=0A-        if (clnt_fd < 0)=0A-            die("accept");=
=0A-=0A-        // clnt_addr is now populated with information about the cl=
ient.=0A-        fprintf(stderr, "Accepted connection from %s\n",=0A-      =
          inet_ntoa(clnt_addr.sin_addr));=0A+static void handle_client(char=
 *database, int clnt_fd){=0A =0A         /*=0A          * Handle client con=
nection.=0A          */=0A-        =0A+=0A+        // Open the database fil=
e=0A+        FILE *fp =3D fopen(database, "rb");=0A+        if (fp =3D=3D N=
ULL)=0A+            die(database);=0A        =0A         /*=0A         * Op=
en client file descriptor as FILE pointers.=0A@@ -141,9 +56,10 @@ int main(=
int argc, char **argv) {=0A =0A         int loaded =3D loadmdb(fp, &list);=
=0A         if (loaded < 0)=0A-            die("loadmdb");=0A-=0A-        f=
seek(fp, 0, SEEK_SET);   =0A+            die("loadmdb");   =0A+   =0A+     =
   if (fclose(fp) < 0)=0A+            perror("file");=0A         =0A       =
  /*=0A          * lookup loop=0A@@ -192,8 +108,11 @@ int main(int argc, ch=
ar **argv) {=0A =0A                 node =3D node->next;=0A                =
 recNo++;=0A+                fflush(clnt_w);=0A             }=0A           =
  =0A+            fprintf(clnt_w, "\n");=0A+=0A             fflush(clnt_w);=
=0A         =0A         }=0A@@ -205,7 +124,7 @@ int main(int argc, char **a=
rgv) {=0A         /*=0A          * clean up and quit=0A          */=0A-=0A+=
 =0A         freemdb(&list);=0A =0A        /*=0A@@ -220,15 +139,162 @@ int =
main(int argc, char **argv) {=0A             perror("clnt_r");=0A =0A      =
   // Resume server loop to handle next client connection.=0A+}=0A+=0A+stat=
ic void sigchld_handler(int sig)=0A+{=0A+    // Keep reaping dead children =
until there aren't any to reap.=0A+    while (waitpid(-1, NULL, WNOHANG) > =
0)=0A+        ;=0A+}=0A+=0A+=0A+int main(int argc, char **argv) {=0A+=0A+  =
  /*=0A+     * Configure signal-handling.=0A+     */=0A+=0A+    struct siga=
ction sa;=0A+    memset(&sa, 0, sizeof(sa));=0A+=0A+    // Ignore SIGPIPE s=
o that we don't terminate when we call=0A+    // send() on a disconnected s=
ocket.=0A+    sigemptyset(&sa.sa_mask);=0A+    sa.sa_flags =3D 0;=0A+    sa=
=2Esa_handler =3D SIG_IGN;=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+   =
     die("sigaction(SIGPIPE)");=0A+=0A+    // Install a handler for the SIG=
CHLD signal so that we can reap children=0A+    // who have finished proces=
sing their requests.=0A+    sigemptyset(&sa.sa_mask);=0A+    sa.sa_flags =
=3D SA_RESTART | SA_NOCLDSTOP;=0A+    sa.sa_handler =3D &sigchld_handler;=
=0A+    if (sigaction(SIGCHLD, &sa, NULL))=0A+        die("sigaction(SIGCHL=
D)");=0A+=0A+    /*=0A+     * Check and obtain command-line arguments=0A+  =
   */=0A+    if (argc !=3D 3) {=0A+        fprintf(stderr, "Usage: %s <serv=
er-port> <database>\n", argv[0]);=0A+        exit(1);=0A+    }=0A+=0A+    c=
har *server_port =3D argv[1];=0A+    char *database =3D argv[2];=0A+=0A+   =
 /*=0A+     * Construct socket address information using getaddrinfo().=0A+=
     */=0A+=0A+    // Define hints for getaddrinfo(), which we need to zero=
 out first.=0A+    struct addrinfo hints;=0A+=0A+    memset(&hints, 0, size=
of(hints));=0A+=0A+    hints.ai_family =3D AF_INET;        // Only accept I=
Pv4 addresses=0A+    hints.ai_socktype =3D SOCK_STREAM;  // stream socket f=
or TCP connections=0A+    hints.ai_protocol =3D IPPROTO_TCP;  // TCP protoc=
ol=0A+    hints.ai_flags =3D AI_PASSIVE;      // Construct socket address f=
or bind()ing=0A+=0A+    // Define where getaddrinfo() will return the infor=
mation it found.=0A+    struct addrinfo *info;=0A+=0A+    // Call getaddrin=
fo(), specifying the server IP address and port as strings.=0A+    // getad=
drinfo() will parse those for us and point info to the result.=0A+    int a=
ddr_err;=0A+    if ((addr_err =3D getaddrinfo(NULL, server_port, &hints, &i=
nfo)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerro=
r(addr_err));=0A+        exit(1);=0A+    }=0A+=0A+    // N.B. info actually=
 points to a linked list of address information=0A+    // structures; assum=
e that the first is sufficient and ignore the rest.=0A+=0A+    /*=0A+     *=
 Create socket() and prepare it to accept() connections.=0A+     */=0A+=0A+=
    // Create socket() according to the address family, socket type, and=0A=
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STR=
EAM,=0A+    // and IPPROTO_TCP in the hints, this should be equivalent to j=
ust calling=0A+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).=0A+    int=
 serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=
=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    // bind() soc=
ket to a port on the server; the port in info->ai_addr should=0A+    // be =
the same port that getaddrinfo() parsed from server_port.=0A+    if (bind(s=
erv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+=
=0A+    // BTW: we're done with the info retrieved by getaddrinfo(), so fre=
e it.=0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for connec=
tions on this socket, maintaining a queue of=0A+    // at most 8 pending co=
nnections.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=
=0A+    for (;;) {=0A+=0A+        /*=0A+         * accept() connection from=
 client.=0A+         */=0A+=0A+        // Define space to receive client ad=
dress info.=0A+        struct sockaddr_in clnt_addr;=0A+        socklen_t c=
lnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+        // accept() blocks until=
 a client connects with the server, and returns=0A+        // a NEW socket =
file descriptor for interacting with the client.=0A+        int clnt_fd =3D=
 accept(serv_fd, (struct sockaddr *) &clnt_addr,=0A+                       =
      &clnt_addr_len);=0A+        if (clnt_fd < 0)=0A+            die("acce=
pt");=0A+        =0A+        pid_t pid =3D fork();=0A+        if (pid < 0)=
=0A+            die("fork");=0A+=0A+        if (pid > 0) {=0A+            /=
*=0A+             * Parent process:=0A+             *=0A+             * Clo=
se client socket and continue accept()ing connections.=0A+             */=
=0A+=0A+            close(clnt_fd);=0A+=0A+            continue;=0A+       =
 }=0A+=0A+        /*=0A+         * Child process:=0A+         *=0A+        =
 * Close server socket, handle the client, and exit.=0A+         */=0A+=0A+=
        close(serv_fd);=0A+=0A+        // clnt_addr is populated with infor=
mation about the client.=0A+        fprintf(stderr, "Connection started: %s=
\n",=0A+                inet_ntoa(clnt_addr.sin_addr));=0A+=0A+        hand=
le_client(database, clnt_fd);=0A+=0A+        fprintf(stderr, "Connection te=
rminated: %s\n",=0A+                inet_ntoa(clnt_addr.sin_addr));=0A+    =
   =0A+        exit(0);=0A     }=0A    =0A    /*=0A     * UNREACHABLE=0A   =
  */=0A     =0A-    if (fclose(fp) < 0)=0A-        perror("file");=0A-    =
=0A     close(serv_fd);=0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AFrom 9=
acec0aafb2a5401645ae224ffee41c01f95de52 Mon Sep 17 00:00:00 2001=0AFrom: Ar=
man Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 02:56:44 -0500=0AS=
ubject: [PATCH 4/9] Added the skeletal code for part2.=0A=0A---=0A README.t=
xt          |   8 +-=0A part2/Makefile      |  14 ++=0A part2/http-server.c=
 | 452 ++++++++++++++++++++++++++++++++++++++++++++=0A 3 files changed, 470=
 insertions(+), 4 deletions(-)=0A create mode 100644 part2/Makefile=0A crea=
te mode 100644 part2/http-server.c=0A=0Adiff --git a/README.txt b/README.tx=
t=0Aindex 49c4472..08c20e8 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@=
@ -1,9 +1,9 @@=0A This file should contain:=0A =0A-  - your name=0A-  - you=
r UNI=0A-  - lab assignment number=0A-  - description for each part=0A+  - =
Arman Ozcan=0A+  - ao2794=0A+  - lab 7=0A+  - My programs should work as th=
ey are supposed to.=0A =0A The description should indicate whether your sol=
ution for the part is=0A working or not.  You may also want to include anyt=
hing else you would=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew fi=
le mode 100644=0Aindex 0000000..6646a20=0A--- /dev/null=0A+++ b/part2/Makef=
ile=0A@@ -0,0 +1,14 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpedantic -std=
=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+http-server:=0A+http-server.o:=
=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core http-server=0A+=0A=
+.PHONY: all=0A+all: clean http-server=0Adiff --git a/part2/http-server.c b=
/part2/http-server.c=0Anew file mode 100644=0Aindex 0000000..998e393=0A--- =
/dev/null=0A+++ b/part2/http-server.c=0A@@ -0,0 +1,452 @@=0A+#define _GNU_S=
OURCE=0A+#include <arpa/inet.h>=0A+#include <linux/limits.h>=0A+#include <n=
etdb.h>=0A+#include <signal.h>=0A+#include <stdio.h>=0A+#include <stdlib.h>=
=0A+#include <string.h>=0A+#include <sys/socket.h>=0A+#include <sys/stat.h>=
=0A+#include <time.h>=0A+#include <unistd.h>=0A+=0A+#define MAXPENDING 5   =
       // Maximum outstanding connection requests=0A+#define MAX_LINE_LENGT=
H 1024  // Maximum line length for request and headers=0A+#define DISK_IO_B=
UF_SIZE 4096 // Size of buffer for reading and sending files=0A+=0A+static =
void die(const char *message)=0A+{=0A+    perror(message);=0A+    exit(1);=
=0A+}=0A+=0A+/*=0A+ * HTTP/1.0 status codes and the corresponding reason ph=
rases.=0A+ */=0A+static struct {=0A+    int status;=0A+    char *reason;=0A=
+} http_status_codes[] =3D {=0A+    { 200, "OK" },=0A+    { 201, "Created" =
},=0A+    { 202, "Accepted" },=0A+    { 204, "No Content" },=0A+    { 301, =
"Moved Permanently" },=0A+    { 302, "Moved Temporarily" },=0A+    { 304, "=
Not Modified" },=0A+    { 400, "Bad Request" },=0A+    { 401, "Unauthorized=
" },=0A+    { 403, "Forbidden" },=0A+    { 404, "Not Found" },=0A+    { 500=
, "Internal Server Error" },=0A+    { 501, "Not Implemented" },=0A+    { 50=
2, "Bad Gateway" },=0A+    { 503, "Service Unavailable" },=0A+    { 0, NULL=
 } // marks the end of the list=0A+};=0A+=0A+static inline const char *get_=
reason_phrase(int status_code)=0A+{=0A+    int i =3D -1;=0A+    while (http=
_status_codes[++i].status > 0)=0A+        if (http_status_codes[i].status =
=3D=3D status_code)=0A+            return http_status_codes[i].reason;=0A+ =
   return "Unknown Status Code";=0A+}=0A+=0A+/*=0A+ * Send HTTP status line=
=2E=0A+ *=0A+ * Returns negative if send() failed.=0A+ */=0A+static int sen=
d_status_line(FILE *fp, int status_code)=0A+{=0A+    const char *reason_phr=
ase =3D get_reason_phrase(status_code);=0A+    return fprintf(fp, "HTTP/1.0=
 %d %s\r\n", status_code, reason_phrase);=0A+}=0A+=0A+/*=0A+ * Send blank l=
ine.=0A+ *=0A+ * Returns number of bytes sent; returns negative if failed.=
=0A+ */=0A+static int send_blank_line(FILE *fp)=0A+{=0A+    return fprintf(=
fp, "\r\n");=0A+}=0A+=0A+/*=0A+ * Send a generic HTTP response for error st=
atuses (400+).=0A+ *=0A+ * Returns negative if failed.=0A+ */=0A+static int=
 send_error_status(FILE *fp, int status_code)=0A+{=0A+    if (send_status_l=
ine(fp, status_code) < 0)=0A+        return -1;=0A+=0A+    // no headers ne=
eded=0A+    if (send_blank_line(fp) < 0)=0A+        return -1;=0A+=0A+    r=
eturn fprintf(fp,=0A+        "<html><body>\n"=0A+        "<h1>%d %s</h1>\n"=
=0A+        "</body></html>\n",=0A+        status_code, get_reason_phrase(s=
tatus_code));=0A+}=0A+=0A+/*=0A+ * Send 301 status: redirect the browser to=
 request_uri with '/' appended to it.=0A+ *=0A+ * Returns negative if faile=
d.=0A+ */=0A+static int send301(const char *request_uri, FILE *fp)=0A+{=0A+=
    if (send_status_line(fp, 301) < 0)=0A+        return -1;=0A+=0A+    // =
Send Location header and format redirection link in HTML in case browser=0A=
+    // doesn't automatically redirect.=0A+    return fprintf(fp,=0A+      =
  "Location: %s/\r\n"=0A+        "\r\n"=0A+        "<html><body>\n"=0A+    =
    "<h1>301 Moved Permanently</h1>\n"=0A+        "<p>The document has move=
d "=0A+        "<a href=3D\"%s/\">here</a>.</p>\n"=0A+        "</body></htm=
l>\n",=0A+        request_uri, request_uri);=0A+}=0A+=0A+/*=0A+ * Handle st=
atic file requests.=0A+ * Returns the HTTP status code that was sent to the=
 browser.=0A+ *=0A+ * If send() ever fails (i.e., could not write to clnt_w=
), report the error and=0A+ * move on.=0A+ */=0A+static int handle_file_req=
uest(const char *web_root, const char *request_uri, FILE *clnt_w)=0A+{=0A+ =
   /*=0A+     * Define variables that we will need to use before we return.=
=0A+     */=0A+=0A+    int status_code; // We'll return this value.=0A+    =
FILE *fp =3D NULL; // We'll fclose() this at the end.=0A+=0A+    // Set cln=
t_w to line-buffering so that lines are flushed immediately.=0A+    setline=
buf(clnt_w);=0A+=0A+    /*=0A+     * Construct the path of the requested fi=
le from web_root and request_uri.=0A+     */=0A+=0A+    char file_path[PATH=
_MAX];=0A+=0A+    if (strlen(web_root) + strlen(request_uri) + 12 > sizeof(=
file_path)) {=0A+        // File paths can't exceed sizeof(file_path) on Li=
nux, so just 404.=0A+        status_code =3D 404; // "Not Found"=0A+       =
 if (send_error_status(clnt_w, status_code) < 0)=0A+            perror("sen=
d");=0A+        goto cleanup;=0A+    }=0A+=0A+    strcpy(file_path, web_roo=
t);=0A+=0A+    // Note: since the URI definitely begins with '/', we don't =
need to worry=0A+    // about appending '/' to web_root.=0A+=0A+    strcat(=
file_path, request_uri);=0A+=0A+    // If request_uri ends with '/', append=
 "index.html".=0A+    if (file_path[strlen(file_path) - 1] =3D=3D '/')=0A+ =
       strcat(file_path, "index.html");=0A+=0A+    /*=0A+     * Open the re=
quested file.=0A+     */=0A+=0A+    // See if the requested file is a direc=
tory.=0A+    struct stat st;=0A+    if (stat(file_path, &st) =3D=3D 0 && S_=
ISDIR(st.st_mode)) {=0A+        status_code =3D 301; // "Moved Permanently"=
=0A+        if (send301(request_uri, clnt_w) < 0)=0A+            perror("se=
nd");=0A+        goto cleanup;=0A+    }=0A+=0A+    // If unable to open the=
 file, send "404 Not Found".=0A+    fp =3D fopen(file_path, "rb");=0A+    i=
f (fp =3D=3D NULL) {=0A+        status_code =3D 404; // "Not Found"=0A+    =
    if (send_error_status(clnt_w, status_code) < 0)=0A+            perror("=
send");=0A+        goto cleanup;=0A+    }=0A+=0A+    // Otherwise, send "20=
0 OK".=0A+    status_code =3D 200; // "OK"=0A+    if (send_status_line(clnt=
_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {=0A+        perror("s=
end");=0A+        goto cleanup;=0A+    }=0A+=0A+    /*=0A+     * Send the f=
ile.=0A+     */=0A+=0A+    // Buffer for file contents.=0A+    char file_bu=
f[DISK_IO_BUF_SIZE];=0A+=0A+    // Turn off buffering for clnt_w because we=
 already have our own file_buf.=0A+    if (fflush(clnt_w) < 0) {=0A+       =
 perror("send");=0A+        goto cleanup;=0A+    }=0A+    setbuf(clnt_w, NU=
LL);=0A+=0A+    // Read and send file in a block at a time.=0A+    size_t n=
;=0A+    while ((n =3D fread(file_buf, 1, sizeof(file_buf), fp)) > 0) {=0A+=
        if (fwrite(file_buf, 1, n, clnt_w) !=3D n) {=0A+            perror(=
"send");=0A+            goto cleanup;=0A+        }=0A+    }=0A+=0A+    // f=
read() returns 0 both on EOF and on error; check if there was an error.=0A+=
    if (ferror(fp))=0A+        // Note that if we had an error, we sent the=
 client a truncated (i.e.,=0A+        // corrupted) file; not much we can d=
o about that at this point since=0A+        // we already sent the status..=
=2E=0A+        perror("fread");=0A+=0A+cleanup:=0A+=0A+    /*=0A+     * clo=
se() the FILE pointer and return.=0A+     */=0A+=0A+    if (fp)=0A+        =
fclose(fp);=0A+=0A+    return status_code;=0A+}=0A+=0A+void handle_client(c=
onst char *web_root, int clnt_fd, const char *clnt_ip)=0A+{=0A+    /*=0A+  =
   * Open client file descriptor as FILE pointers.=0A+     */=0A+    FILE *=
clnt_r =3D fdopen(clnt_fd, "rb");=0A+    if (clnt_r =3D=3D NULL)=0A+       =
 die("fdopen");=0A+=0A+    FILE *clnt_w =3D fdopen(dup(clnt_fd), "wb");=0A+=
    if (clnt_w =3D=3D NULL)=0A+        die("fdopen");=0A+=0A+    /*=0A+    =
 * Let's parse the request line.=0A+     */=0A+=0A+    // Note: we'll use t=
hese fields at the end when we log the connection.=0A+    int status_code;=
=0A+    char *method =3D NULL, *request_uri =3D NULL, *http_version =3D NUL=
L, *extra;=0A+=0A+    char request_buf[MAX_LINE_LENGTH];=0A+=0A+    if (fge=
ts(request_buf, sizeof(request_buf), clnt_r) =3D=3D NULL) {=0A+        // S=
ocket closed prematurely; there isn't much we can do=0A+        status_code=
 =3D 400; // "Bad Request"=0A+        goto terminate_connection;=0A+    }=
=0A+=0A+    char *token_separators =3D "\t \r\n"; // tab, space, new line=
=0A+=0A+    method =3D strtok(request_buf, token_separators);=0A+    reques=
t_uri =3D strtok(NULL, token_separators);=0A+    http_version =3D strtok(NU=
LL, token_separators);=0A+    extra =3D strtok(NULL, token_separators);=0A+=
=0A+    // Note: We must not modify request_buf past this point, because me=
thod,=0A+    // request_uri, http_version, and extra point to within reques=
t_buf.=0A+=0A+    // Check that we have exactly three tokens in the request=
 line.=0A+    if (!method || !request_uri || !http_version || extra) {=0A+ =
       status_code =3D 501; // "Not Implemented"=0A+        send_error_stat=
us(clnt_w, status_code);=0A+        goto terminate_connection;=0A+    }=0A+=
=0A+    // We only support GET requests.=0A+    if (strcmp(method, "GET")) =
{=0A+        status_code =3D 501; // "Not Implemented"=0A+        send_erro=
r_status(clnt_w, status_code);=0A+        goto terminate_connection;=0A+   =
 }=0A+=0A+    // We only support HTTP/1.0 and HTTP/1.1.=0A+    if (strcmp(h=
ttp_version, "HTTP/1.0") && strcmp(http_version, "HTTP/1.1")) {=0A+        =
status_code =3D 501; // "Not Implemented"=0A+        send_error_status(clnt=
_w, status_code);=0A+        goto terminate_connection;=0A+    }=0A+=0A+   =
 // request_uri must begin with "/".=0A+    if (!request_uri || *request_ur=
i !=3D '/') {=0A+        status_code =3D 400; // "Bad Request"=0A+        s=
end_error_status(clnt_w, status_code);=0A+        goto terminate_connection=
;=0A+    }=0A+=0A+    // Ensure request_uri does not contain "/../" and doe=
s not end with "/..".=0A+    int uri_len =3D strlen(request_uri);=0A+    if=
 (uri_len >=3D 3) {=0A+        char *tail =3D request_uri + (uri_len - 3);=
=0A+        if (strcmp(tail, "/..") =3D=3D 0 || strstr(request_uri, "/../")=
 !=3D NULL) {=0A+            status_code =3D 400; // "Bad Request"=0A+     =
       send_error_status(clnt_w, status_code);=0A+            goto terminat=
e_connection;=0A+        }=0A+    }=0A+=0A+    /*=0A+     * Skip HTTP heade=
rs.=0A+     */=0A+=0A+    // We need another buffer for trashing the header=
s, because request_buf=0A+    // still currently holds the method, request_=
uri, and http_version strings.=0A+    char line_buf[MAX_LINE_LENGTH];=0A+=
=0A+    while (1) {=0A+        if (fgets(line_buf, sizeof(line_buf), clnt_r=
) =3D=3D NULL) {=0A+            // Socket closed prematurely; there isn't m=
uch we can do=0A+            status_code =3D 400; // "Bad Request"=0A+     =
       goto terminate_connection;=0A+        }=0A+=0A+        // Check if w=
e have reached the end of the headers, i.e., an empty line.=0A+        if (=
strcmp("\r\n", line_buf) =3D=3D 0 || strcmp("\n", line_buf) =3D=3D 0)=0A+  =
          break;=0A+    }=0A+=0A+    /*=0A+     * We have a well-formed HTT=
P GET request; time to handle it.=0A+     */=0A+=0A+    status_code =3D han=
dle_file_request(web_root, request_uri, clnt_w);=0A+=0A+terminate_connectio=
n:=0A+=0A+    /*=0A+     * Done with client request; close the connection a=
nd log the transaction.=0A+     */=0A+=0A+    // Closing can FILE pointers =
can also produce errors, which we log.=0A+    if (fclose(clnt_w) < 0)=0A+  =
      perror("send");=0A+=0A+    if (fclose(clnt_r) < 0)=0A+        perror(=
"recv");=0A+=0A+    fprintf(stderr, "%s \"%s %s %s\" %d %s\n",=0A+        c=
lnt_ip,=0A+        method,=0A+        request_uri,=0A+        http_version,=
=0A+        status_code,=0A+        get_reason_phrase(status_code));=0A+}=
=0A+=0A+int main(int argc, char *argv[])=0A+{=0A+    /*=0A+     * Configure=
 signal-handling.=0A+     */=0A+=0A+    struct sigaction sa;=0A+    memset(=
&sa, 0, sizeof(sa));=0A+=0A+    // Ignore SIGPIPE so that we don't terminat=
e when we call=0A+    // send() on a disconnected socket.=0A+    sigemptyse=
t(&sa.sa_mask);=0A+    sa.sa_flags =3D 0;=0A+    sa.sa_handler =3D SIG_IGN;=
=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+        die("sigaction(SIGPIP=
E)");=0A+=0A+    /*=0A+     * Parse arguments.=0A+     */=0A+=0A+    if (ar=
gc !=3D 3) {=0A+        fprintf(stderr, "usage: %s <server-port> <web-root>=
\n", argv[0]);=0A+        exit(1);=0A+    }=0A+=0A+    char *serv_port =3D =
argv[1];=0A+    char *web_root =3D argv[2];=0A+=0A+    /*=0A+     * Constru=
ct server socket to listen on serv_port.=0A+     */=0A+=0A+    struct addri=
nfo hints, *info;=0A+=0A+    memset(&hints, 0, sizeof(hints));=0A+    hints=
=2Eai_family =3D AF_INET;       // Only accept IPv4 addresses=0A+    hints.=
ai_socktype =3D SOCK_STREAM; // stream socket for TCP connections=0A+    hi=
nts.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints.ai_flags =3D =
AI_PASSIVE;     // Construct socket address for bind()ing=0A+=0A+    int ad=
dr_err;=0A+    if ((addr_err =3D getaddrinfo(NULL, serv_port, &hints, &info=
)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(a=
ddr_err));=0A+        exit(1);=0A+    }=0A+=0A+    int serv_fd =3D socket(i=
nfo->ai_family, info->ai_socktype, info->ai_protocol);=0A+    if (serv_fd <=
 0)=0A+        die("socket");=0A+=0A+    if (bind(serv_fd, info->ai_addr, i=
nfo->ai_addrlen) < 0)=0A+        die("bind");=0A+=0A+    if (listen(serv_fd=
, 8) < 0)=0A+        die("listen");=0A+=0A+    freeaddrinfo(info);=0A+=0A+ =
   /*=0A+     * Server accept() loop.=0A+     */=0A+=0A+    for (;;) {=0A+ =
       // We only need sockaddr_in since we only accept IPv4 peers.=0A+    =
    struct sockaddr_in clnt_addr;=0A+        socklen_t clnt_len =3D sizeof(=
clnt_addr);=0A+=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr=
 *)&clnt_addr, &clnt_len);=0A+        if (clnt_fd < 0)=0A+            die("=
accept");=0A+=0A+        char clnt_ip[INET_ADDRSTRLEN];=0A+=0A+        if (=
inet_ntop(AF_INET, &clnt_addr.sin_addr, clnt_ip, sizeof(clnt_ip))=0A+      =
      =3D=3D NULL)=0A+            die("inet_ntop");=0A+=0A+        handle_c=
lient(web_root, clnt_fd, clnt_ip);=0A+    }=0A+=0A+    /*=0A+     * UNREACH=
ABLE=0A+     */=0A+=0A+    close(serv_fd);=0A+=0A+    return 0;=0A+}=0A-- =
=0A2.34.1=0A=0A=0AFrom de8e9262d9f21956eb524d448b8ee747d84ba0a7 Mon Sep 17 =
00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec=
 2022 17:41:04 -0500=0ASubject: [PATCH 5/9] Now, part2 works partially. Whe=
n mdb-lookup is called, it=0A always prints the default page.=0A=0A---=0A p=
art2/http-server.c | 99 ++++++++++++++++++++++++++++++++++++++++++---=0A 1 =
file changed, 93 insertions(+), 6 deletions(-)=0A=0Adiff --git a/part2/http=
-server.c b/part2/http-server.c=0Aindex 998e393..8748882 100644=0A--- a/par=
t2/http-server.c=0A+++ b/part2/http-server.c=0A@@ -127,7 +127,21 @@ static =
int send301(const char *request_uri, FILE *fp)=0A  * If send() ever fails (=
i.e., could not write to clnt_w), report the error and=0A  * move on.=0A  *=
/=0A-static int handle_file_request(const char *web_root, const char *reque=
st_uri, FILE *clnt_w)=0A+=0A+static void handle_lookup(const char *request,=
 FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){=0A+    const char *form =3D=0A+  =
        "<h1>mdb-lookup</h1>\n"=0A+          "<p>\n"=0A+          "<form me=
thod=3DGET action=3D/mdb-lookup>\n"=0A+          "lookup: <input type=3Dtex=
t name=3Dkey>\n"=0A+          "<input type=3Dsubmit>\n"=0A+          "</for=
m>\n"=0A+          "<p>\n";=0A+=0A+    fprintf(clnt_w, "<html><body>\n%s</b=
ody></html>\n", form);=0A+}=0A+=0A+static int handle_file_request(const cha=
r *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_=
w)=0A {=0A     /*=0A      * Define variables that we will need to use befor=
e we return.=0A@@ -138,6 +152,21 @@ static int handle_file_request(const ch=
ar *web_root, const char *request_uri, FI=0A =0A     // Set clnt_w to line-=
buffering so that lines are flushed immediately.=0A     setlinebuf(clnt_w);=
=0A+    =0A+    // enter if uri is /mdb-lookup or it starts with /mdb-looku=
p?=0A+    if(!strcmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "=
/mdb-lookup?", 12)){=0A+     =0A+        status_code =3D 200; // "OK"=0A+  =
      if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt=
_w) < 0) {=0A+            perror("send");=0A+            goto cleanup;=0A+ =
       }=0A+=0A+        // return the result=0A+        handle_lookup(reque=
st_uri + 11, clnt_w, mdb_r, mdb_w);        =0A+        goto cleanup;=0A+   =
 }=0A+=0A =0A     /*=0A      * Construct the path of the requested file fro=
m web_root and request_uri.=0A@@ -235,7 +264,7 @@ cleanup:=0A     return st=
atus_code;=0A }=0A =0A-void handle_client(const char *web_root, int clnt_fd=
, const char *clnt_ip)=0A+void handle_client(const char *web_root, int clnt=
_fd, const char *clnt_ip, FILE *mdb_r, FILE *mdb_w)=0A {=0A     /*=0A      =
* Open client file descriptor as FILE pointers.=0A@@ -337,7 +366,7 @@ void =
handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)=0A   =
   * We have a well-formed HTTP GET request; time to handle it.=0A      */=
=0A =0A-    status_code =3D handle_file_request(web_root, request_uri, clnt=
_w);=0A+    status_code =3D handle_file_request(web_root, request_uri, clnt=
_w, mdb_r, mdb_w);=0A =0A terminate_connection:=0A =0A@@ -382,13 +411,15 @@=
 int main(int argc, char *argv[])=0A      * Parse arguments.=0A      */=0A =
=0A-    if (argc !=3D 3) {=0A-        fprintf(stderr, "usage: %s <server-po=
rt> <web-root>\n", argv[0]);=0A+    if (argc !=3D 5) {=0A+        fprintf(s=
tderr, "usage: %s <server-port> <web-root> <mdb-host> <mdb-port>\n", argv[0=
]);=0A         exit(1);=0A     }=0A =0A     char *serv_port =3D argv[1];=0A=
     char *web_root =3D argv[2];=0A+    char *mdb_host =3D argv[3];=0A+    =
char *mdb_port =3D argv[4];=0A =0A     /*=0A      * Construct server socket=
 to listen on serv_port.=0A@@ -420,6 +451,60 @@ int main(int argc, char *ar=
gv[])=0A =0A     freeaddrinfo(info);=0A =0A+    /*=0A+     * Construct clie=
nt socket to connect to mdb-lookup-server.=0A+     */=0A+=0A+    // Zero ou=
t hints first.=0A+    memset(&hints, 0, sizeof(hints));=0A+=0A+    // Speci=
fy what kind of connection we intend to make; these values tell=0A+    // g=
etaddrinfo() that we don't care about other kinds of addresses.=0A+    hint=
s.ai_family =3D AF_INET;        // Only accept IPv4 addresses=0A+    hints.=
ai_socktype =3D SOCK_STREAM;  // stream socket for TCP connections=0A+    h=
ints.ai_protocol =3D IPPROTO_TCP;  // TCP protocol=0A+=0A+    // Define whe=
re getaddrinfo() will return the information it found.=0A+    struct addrin=
fo *info_mdb;=0A+=0A+    // Call getaddrinfo(), specifying the server IP ad=
dress and port as strings.=0A+    // getaddrinfo() will parse those for us =
and point info to the result.=0A+    if ((addr_err =3D getaddrinfo(mdb_host=
, mdb_port, &hints, &info_mdb)) !=3D 0) {=0A+        fprintf(stderr, "getad=
drinfo: %s\n", gai_strerror(addr_err));=0A+        exit(1);=0A+    }=0A+=0A=
+    /*=0A+     * Create socket() and connect() it to server.=0A+     */=0A=
+=0A+    // Create socket() according to the address family, socket type, a=
nd=0A+    // protocol of the address info.  Since we specified AF_INET, SOC=
K_STREAM,=0A+    // and IPPROTO_TCP in the hints, this should be equivalent=
 to just calling=0A+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).=0A+  =
  int mdb_fd =3D socket(info_mdb->ai_family, info_mdb->ai_socktype, info_md=
b->ai_protocol);=0A+    if (mdb_fd < 0)=0A+        die("socket");=0A+=0A+  =
  // Connect socket with server address; the IP address and port in=0A+    =
// info->ai_addr should be the same address and port that getaddrinfo()=0A+=
    // parsed from server_address and server_port.=0A+    if (connect(mdb_f=
d, info_mdb->ai_addr, info_mdb->ai_addrlen) < 0)=0A+        die("connect");=
=0A+=0A+    // BTW: we're done with the info retrieved by getaddrinfo(), so=
 free it.=0A+    freeaddrinfo(info_mdb);=0A+=0A+    /*=0A+     * Open mdb-l=
ookup-server file descriptor as FILE pointers.=0A+     */=0A+    FILE *mdb_=
r =3D fdopen(mdb_fd, "rb");=0A+    if (mdb_r =3D=3D NULL)=0A+        die("f=
dopen");=0A+=0A+    FILE *mdb_w =3D fdopen(dup(mdb_fd), "wb");=0A+    if (m=
db_w =3D=3D NULL)=0A+        die("fdopen");=0A     /*=0A      * Server acce=
pt() loop.=0A      */=0A@@ -439,13 +524,15 @@ int main(int argc, char *argv=
[])=0A             =3D=3D NULL)=0A             die("inet_ntop");=0A =0A-   =
     handle_client(web_root, clnt_fd, clnt_ip);=0A+        handle_client(we=
b_root, clnt_fd, clnt_ip, mdb_r, mdb_w);=0A     }=0A =0A     /*=0A      * U=
NREACHABLE=0A      */=0A =0A+    fclose(mdb_r);=0A+    fclose(mdb_w);=0A   =
  close(serv_fd);=0A =0A     return 0;=0A-- =0A2.34.1=0A=0A=0AFrom 537bcddf=
9cea379212bb4ffafff70962f1692dfc Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozc=
an <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 20:46:04 -0500=0ASubject:=
 [PATCH 6/9] I am not quite sure, but it seems like part2 is working=0A oka=
y now. I have to check if the memory leaks are constant.=0A=0A---=0A part2/=
http-server.c | 65 +++++++++++++++++++++++++++++++++++++++++++--=0A 1 file =
changed, 63 insertions(+), 2 deletions(-)=0A=0Adiff --git a/part2/http-serv=
er.c b/part2/http-server.c=0Aindex 8748882..7de5023 100644=0A--- a/part2/ht=
tp-server.c=0A+++ b/part2/http-server.c=0A@@ -130,7 +130,7 @@ static int se=
nd301(const char *request_uri, FILE *fp)=0A =0A static void handle_lookup(c=
onst char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){=0A     const c=
har *form =3D=0A-          "<h1>mdb-lookup</h1>\n"=0A+          "<h1>mdb-li=
asdsadasdasdasdasdasdasdasdookup</h1>\n"=0A           "<p>\n"=0A           =
"<form method=3DGET action=3D/mdb-lookup>\n"=0A           "lookup: <input t=
ype=3Dtext name=3Dkey>\n"=0A@@ -138,7 +138,65 @@ static void handle_lookup(=
const char *request, FILE *clnt_w, FILE *mdb_r, FILE *=0A           "</form=
>\n"=0A           "<p>\n";=0A =0A-    fprintf(clnt_w, "<html><body>\n%s</bo=
dy></html>\n", form);=0A+    if(strlen(request) < 5 || strncmp(request, "?k=
ey=3D", 5) ){=0A+        if(fprintf(clnt_w, "<html><body>\n%s</body></html>=
\n", form) < 0)=0A+            perror("send");=0A+        return;=0A+    }=
=0A+                =0A+    fprintf(stderr, "Length of request after =3D %l=
d\n", strlen(request + 5));=0A+=0A+    char key[strlen(request + 5) + 1];=
=0A+        =0A+    fprintf(stderr, "Size of key array =3D %ld\nThis is the=
 array: ", sizeof(key));=0A+    =0A+    strncpy(key, request + 5, sizeof(ke=
y) - 1);=0A+=0A+    key[sizeof(key)  - 1] =3D '\n';=0A+    =0A+    fwrite(k=
ey, sizeof(key), 1, stderr);=0A+=0A+    if(fwrite(key, sizeof(key), 1, mdb_=
w) !=3D 1){=0A+        perror("send");=0A+        return;=0A+    }=0A+=0A+ =
   // Buffer for result of lookup.=0A+    char result_buf[500];=0A+    int =
isYellow =3D 0;=0A+=0A+    if(fprintf(clnt_w, "<html><body>\n%s<p><table bo=
rder>\n", form) < 0)=0A+        perror("send");=0A+=0A+    while(fgets(resu=
lt_buf, sizeof(result_buf), mdb_r) !=3D NULL ) {=0A+        if(!strcmp(resu=
lt_buf, "\n")){=0A+            fprintf(stderr,"I found newline character at=
 the response!\n");=0A+            break;=0A+        }=0A+=0A+        if(is=
Yellow){=0A+            if(fprintf(clnt_w, "<tr><td bgcolor=3Dyellow>\n%s\n=
", result_buf) < 0)=0A+            perror("send");=0A+            isYellow =
=3D 0;=0A+        }else{=0A+            if(fprintf(clnt_w, "<tr><td>\n%s\n"=
, result_buf) < 0)=0A+            perror("send");=0A+            isYellow =
=3D 1;=0A+        }=0A+    }=0A+    =0A+    if(ferror(mdb_r))=0A+        pe=
rror("mdb_lookup_server");=0A+=0A+=0A+    if(fprintf(clnt_w, "</table>\n</b=
ody></html>\n") < 0)=0A+        perror("send");=0A+ =0A+=0A+    if (fflush(=
clnt_w) < 0)=0A+        perror("send");=0A+=0A+    return;=0A }=0A =0A stat=
ic int handle_file_request(const char *web_root, const char *request_uri, F=
ILE *clnt_w, FILE *mdb_r, FILE *mdb_w)=0A@@ -505,6 +563,9 @@ int main(int a=
rgc, char *argv[])=0A     FILE *mdb_w =3D fdopen(dup(mdb_fd), "wb");=0A    =
 if (mdb_w =3D=3D NULL)=0A         die("fdopen");=0A+=0A+    setbuf(mdb_w, =
NULL);=0A+=0A     /*=0A      * Server accept() loop.=0A      */=0A-- =0A2.3=
4.1=0A=0A=0AFrom 66f20d2a0fe0a1547190d4a34e9d2bb0ec00daa6 Mon Sep 17 00:00:=
00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 =
23:27:33 -0500=0ASubject: [PATCH 7/9] Now part2 can send 500 Internal Serve=
r Error.=0A=0A---=0A part2/http-server.c | 34 +++++++++++++++++++++--------=
-----=0A 1 file changed, 21 insertions(+), 13 deletions(-)=0A=0Adiff --git =
a/part2/http-server.c b/part2/http-server.c=0Aindex 7de5023..44281c4 100644=
=0A--- a/part2/http-server.c=0A+++ b/part2/http-server.c=0A@@ -128,20 +128,=
22 @@ static int send301(const char *request_uri, FILE *fp)=0A  * move on.=
=0A  */=0A =0A-static void handle_lookup(const char *request, FILE *clnt_w,=
 FILE *mdb_r, FILE *mdb_w){=0A+static int handle_lookup(const char *request=
, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){=0A     const char *form =3D=0A- =
         "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n"=0A+          "=
<h1>mdb-lookup</h1>\n"=0A           "<p>\n"=0A           "<form method=3DGE=
T action=3D/mdb-lookup>\n"=0A           "lookup: <input type=3Dtext name=3D=
key>\n"=0A           "<input type=3Dsubmit>\n"=0A           "</form>\n"=0A =
          "<p>\n";=0A+        =0A+    int status_code;=0A =0A     if(strlen=
(request) < 5 || strncmp(request, "?key=3D", 5) ){=0A         if(fprintf(cl=
nt_w, "<html><body>\n%s</body></html>\n", form) < 0)=0A             perror(=
"send");=0A-        return;=0A+        return 1;=0A     }=0A               =
  =0A     fprintf(stderr, "Length of request after =3D %ld\n", strlen(reque=
st + 5));=0A@@ -156,15 +158,23 @@ static void handle_lookup(const char *req=
uest, FILE *clnt_w, FILE *mdb_r, FILE *=0A     =0A     fwrite(key, sizeof(k=
ey), 1, stderr);=0A =0A-    if(fwrite(key, sizeof(key), 1, mdb_w) !=3D 1){=
=0A+    if(fwrite(key, sizeof(key), 1, mdb_w) !=3D 1){ =0A         perror("=
send");=0A-        return;=0A+        status_code =3D 500; // "Not Found"=
=0A+        if (send_error_status(clnt_w, status_code) < 0)=0A+            =
perror("send");=0A+        return 0;=0A     }=0A =0A     // Buffer for resu=
lt of lookup.=0A     char result_buf[500];=0A     int isYellow =3D 0;=0A =
=0A+    status_code =3D 200; // "OK"=0A+    if (send_status_line(clnt_w, st=
atus_code) < 0 || send_blank_line(clnt_w) < 0) {=0A+        perror("send");=
=0A+    }=0A+=0A     if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\=
n", form) < 0)=0A         perror("send");=0A =0A@@ -196,7 +206,7 @@ static =
void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *=
=0A     if (fflush(clnt_w) < 0)=0A         perror("send");=0A =0A-    retur=
n;=0A+    return 1;=0A }=0A =0A static int handle_file_request(const char *=
web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)=
=0A@@ -213,15 +223,13 @@ static int handle_file_request(const char *web_roo=
t, const char *request_uri, FI=0A     =0A     // enter if uri is /mdb-looku=
p or it starts with /mdb-lookup?=0A     if(!strcmp(request_uri, "/mdb-looku=
p") || !strncmp(request_uri, "/mdb-lookup?", 12)){=0A-     =0A-        stat=
us_code =3D 200; // "OK"=0A-        if (send_status_line(clnt_w, status_cod=
e) < 0 || send_blank_line(clnt_w) < 0) {=0A-            perror("send");=0A-=
            goto cleanup;=0A-        }=0A =0A         // return the result=
=0A-        handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        =
=0A+        if(handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w)){=0A+ =
           status_code =3D 200;=0A+        }else{=0A+            status_cod=
e =3D 500;=0A+        }     =0A         goto cleanup;=0A     }=0A =0A-- =0A=
2.34.1=0A=0A=0AFrom abd922f7427ed2fb37f27b4d2ded014a2f972f12 Mon Sep 17 00:=
00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sun, 11 Dec 20=
22 03:16:46 -0500=0ASubject: [PATCH 8/9] Fixed a little bug when the defaul=
t lookup page is=0A printed.=0A=0A---=0A part2/http-server.c | 4 ++++=0A 1 =
file changed, 4 insertions(+)=0A=0Adiff --git a/part2/http-server.c b/part2=
/http-server.c=0Aindex 44281c4..d581745 100644=0A--- a/part2/http-server.c=
=0A+++ b/part2/http-server.c=0A@@ -141,6 +141,10 @@ static int handle_looku=
p(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m=0A     int status=
_code;=0A =0A     if(strlen(request) < 5 || strncmp(request, "?key=3D", 5) =
){=0A+        status_code =3D 200; // "OK"=0A+        if (send_status_line(=
clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0)=0A+            per=
ror("send");=0A+=0A         if(fprintf(clnt_w, "<html><body>\n%s</body></ht=
ml>\n", form) < 0)=0A             perror("send");=0A         return 1;=0A--=
 =0A2.34.1=0A=0A=0AFrom 8b71c382d86a5a0205505a6a219936b46b72e707 Mon Sep 17=
 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 14 De=
c 2022 17:50:47 -0500=0ASubject: [PATCH 9/9] Final commit!=0A=0A---=0A part=
2/http-server.c | 16 ++++++++++------=0A 1 file changed, 10 insertions(+), =
6 deletions(-)=0A=0Adiff --git a/part2/http-server.c b/part2/http-server.c=
=0Aindex d581745..c5635b4 100644=0A--- a/part2/http-server.c=0A+++ b/part2/=
http-server.c=0A@@ -150,20 +150,20 @@ static int handle_lookup(const char *=
request, FILE *clnt_w, FILE *mdb_r, FILE *m=0A         return 1;=0A     }=
=0A                 =0A-    fprintf(stderr, "Length of request after =3D %l=
d\n", strlen(request + 5));=0A+    //fprintf(stderr, "Length of request aft=
er =3D %ld\n", strlen(request + 5));=0A =0A     char key[strlen(request + 5=
) + 1];=0A         =0A-    fprintf(stderr, "Size of key array =3D %ld\nThis=
 is the array: ", sizeof(key));=0A+    //fprintf(stderr, "Size of key array=
 =3D %ld\nThis is the array: ", sizeof(key));=0A     =0A     strncpy(key, r=
equest + 5, sizeof(key) - 1);=0A =0A     key[sizeof(key)  - 1] =3D '\n';=0A=
     =0A-    fwrite(key, sizeof(key), 1, stderr);=0A+    //fwrite(key, size=
of(key), 1, stderr);=0A =0A     if(fwrite(key, sizeof(key), 1, mdb_w) !=3D =
1){ =0A-        perror("send");=0A+        perror("mdb-lookup-server send")=
;=0A         status_code =3D 500; // "Not Found"=0A         if (send_error_=
status(clnt_w, status_code) < 0)=0A             perror("send");=0A@@ -182,9=
 +182,10 @@ static int handle_lookup(const char *request, FILE *clnt_w, FIL=
E *mdb_r, FILE *m=0A     if(fprintf(clnt_w, "<html><body>\n%s<p><table bord=
er>\n", form) < 0)=0A         perror("send");=0A =0A+    int i =3D 1;=0A   =
  while(fgets(result_buf, sizeof(result_buf), mdb_r) !=3D NULL ) {=0A      =
   if(!strcmp(result_buf, "\n")){=0A-            fprintf(stderr,"I found ne=
wline character at the response!\n");=0A+            i =3D 0;=0A           =
  break;=0A         }=0A =0A@@ -199,8 +200,11 @@ static int handle_lookup(c=
onst char *request, FILE *clnt_w, FILE *mdb_r, FILE *m=0A         }=0A     =
}=0A     =0A+    if(i)=0A+        perror("mdb-lookup-server recv");=0A+=0A =
    if(ferror(mdb_r))=0A-        perror("mdb_lookup_server");=0A+        pe=
rror("mdb-lookup-server");=0A =0A =0A     if(fprintf(clnt_w, "</table>\n</b=
ody></html>\n") < 0)=0A-- =0A2.34.1=0A=0A
--8npxk+dsqscB+TCs--

From do.not.reply@cloud.cs.columbia.edu Wed Dec 14 20:01:42 2022
Date: Wed, 14 Dec 2022 20:01:42 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, ao2794@columbia.edu, ao2794@barnard.edu
Subject: ao2794-lab7.mbox
Message-ID: <Y5px9ZR6xsG/b4s/@cloud.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="K83sDo3EOYo3DfJy"
Content-Disposition: inline
Status: RO
Content-Length: 115211
Lines: 2670


--K83sDo3EOYo3DfJy
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 5b3cf0a1b0e8127cf80fa450a98c1d32513c8579 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Thu, 8 Dec 2022 22:05:32 -0500
Subject: [PATCH 01/10] First commit.

---
 part1/Makefile            |  22 +++++
 part1/mdb-lookup-server.c | 174 ++++++++++++++++++++++++++++++++++++++
 part1/mdb.c               |  53 ++++++++++++
 part1/mdb.h               |  18 +++-
 4 files changed, 264 insertions(+), 3 deletions(-)
 create mode 100644 part1/Makefile
 create mode 100644 part1/mdb-lookup-server.c
 create mode 100644 part1/mdb.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..6f5a47e
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,22 @@
+CC = gcc
+
+# Support externally overriding CFLAGS
+CFLAGS ?= -g -Wall -Wpedantic -std=c17
+CFLAGS += -I/home/j-hui/cs3157-pub/include
+
+LDFLAGS = -L/home/j-hui/cs3157-pub/lib
+LDLIBS = -lmylist
+
+.PHONY: default
+default: mdb-lookup-server
+
+mdb-lookup-server: mdb-lookup-server.o mdb.o
+mdb-lookup-server.o: mdb-lookup-server.c mdb.h
+mdb.o: mdb.h
+	
+.PHONY: clean
+clean:
+	rm -f *.o a.out core mdb-lookup-server
+
+.PHONY: all
+all: clean default
diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
new file mode 100644
index 0000000..7072e1f
--- /dev/null
+++ b/part1/mdb-lookup-server.c
@@ -0,0 +1,174 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <linux/limits.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <unistd.h>
+#include <mylist.h>
+#include "mdb.h"
+
+#define KeyMax 5
+#define MAX_LINE_LENGTH 1024  // Maximum line length for request and headers
+#define DISK_IO_BUF_SIZE 4096 // Size of buffer for reading and sending files
+
+static void die(const char *message)
+{
+    perror(message);
+    exit(1);
+}
+
+int main(int argc, char **argv) {
+    /*
+     * Check and obtain command-line arguments
+     */
+    if (argc != 2) {
+        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
+        exit(1);
+    }
+
+    char *server_port = argv[1];
+    char *database = argv[2];
+
+    /*
+     * Construct socket address information using getaddrinfo().
+     */
+
+    // Define hints for getaddrinfo(), which we need to zero out first.
+    struct addrinfo hints;
+
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    // N.B. info actually points to a linked list of address information
+    // structures; assume that the first is sufficient and ignore the rest.
+
+    /*
+     * Create socket() and prepare it to accept() connections.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    // bind() socket to a port on the server; the port in info->ai_addr should
+    // be the same port that getaddrinfo() parsed from server_port.
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        // clnt_addr is now populated with information about the client.
+        fprintf(stderr, "Accepted connection from %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        /*
+         * Handle client connection.
+         */
+
+        FILE *fp = fopen(database, "rb");
+        if (fp == NULL)
+            die(database);
+
+        /*
+         * read all records into memory
+         */
+
+        struct List list;
+        initList(&list);
+
+        int loaded = loadmdb(fp, &list);
+        if (loaded < 0)
+            die("loadmdb");
+
+        if (fclose(fp) < 0)
+            perror("file");
+        
+        /*
+         * lookup loop
+         */
+        
+        char line[1024];
+        char key[KeyMax + 1];
+
+       
+        // clear up the key!!
+        
+        // open a file pointer
+        // make 
+
+       /*
+        * search with key
+        */
+
+        // traverse the list, printing out the matching records
+        struct Node *node = list.head;
+        int recNo = 1;
+        while (node) {
+            struct MdbRec *rec = (struct MdbRec *)node->data;
+
+            if (strstr(rec->name, key) || strstr(rec->msg, key))
+                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+
+            node = node->next;
+            recNo++;
+        }
+
+        // Close client connection.
+        close(clnt_fd);
+
+        // Resume server loop to handle next client connection.
+    }
+
+    close(serv_fd);
+    return 0;
+}
diff --git a/part1/mdb.c b/part1/mdb.c
new file mode 100644
index 0000000..ce5243a
--- /dev/null
+++ b/part1/mdb.c
@@ -0,0 +1,53 @@
+/*
+ * mdb.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <mylist.h>
+
+#include "mdb.h"
+
+int loadmdb(FILE *fp, struct List *dest)
+{
+    /*
+     * read all records into memory
+     */
+
+    struct MdbRec r;
+    struct Node *node = NULL;
+    int count = 0;
+
+    while (fread(&r, sizeof(r), 1, fp) == 1) {
+
+        // allocate memory for a new record and copy into it the one
+        // that was just read from the database.
+        struct MdbRec *rec = (struct MdbRec *)malloc(sizeof(r));
+        if (!rec)
+            return -1;
+
+        memcpy(rec, &r, sizeof(r));
+
+        // add the record to the linked list.
+        node = addAfter(dest, node, rec);
+        if (node == NULL)
+            return -1;
+
+        count++;
+    }
+
+    // see if fread() produced error
+    if (ferror(fp))
+        return -1;
+
+    return count;
+}
+
+void freemdb(struct List *list)
+{
+    // free all the records
+    traverseList(list, &free);
+    removeAllNodes(list);
+}
diff --git a/part1/mdb.h b/part1/mdb.h
index fb091b5..6712a6c 100644
--- a/part1/mdb.h
+++ b/part1/mdb.h
@@ -1,9 +1,21 @@
-#ifndef __MDB_H__
-#define __MDB_H__
+/*
+ * mdb.h
+ */
+
+#ifndef _MDB_H_
+#define _MDB_H_
+
+#include <stdio.h>
+
+#include <mylist.h>
 
 struct MdbRec {
     char name[16];
     char msg[24];
 };
 
-#endif
+int loadmdb(FILE *fp, struct List *dest);
+void freemdb(struct List *list);
+
+#endif /* _MDB_H_ */
+
-- 
2.34.1


From af5c8ebf61fc2d15148c940e57849615ab8a723d Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Fri, 9 Dec 2022 23:46:19 -0500
Subject: [PATCH 02/10] I managed to get mdb-lookup-server working, but it only
 can handle one process for now.

---
 part1/Makefile            |  10 ++--
 part1/mdb-lookup-server.c | 116 +++++++++++++++++++++++++++++---------
 2 files changed, 94 insertions(+), 32 deletions(-)

diff --git a/part1/Makefile b/part1/Makefile
index 6f5a47e..3dc4b25 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -7,13 +7,15 @@ CFLAGS += -I/home/j-hui/cs3157-pub/include
 LDFLAGS = -L/home/j-hui/cs3157-pub/lib
 LDLIBS = -lmylist
 
+mdb-lookup-server: mdb-lookup-server.o mdb.o
+
+mdb.o: mdb.c mdb.h
+
+mdb-lookup-server.o: mdb-lookup-server.c mdb.h
+
 .PHONY: default
 default: mdb-lookup-server
 
-mdb-lookup-server: mdb-lookup-server.o mdb.o
-mdb-lookup-server.o: mdb-lookup-server.c mdb.h
-mdb.o: mdb.h
-	
 .PHONY: clean
 clean:
 	rm -f *.o a.out core mdb-lookup-server
diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index 7072e1f..bb1a9fe 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -29,7 +29,7 @@ int main(int argc, char **argv) {
     /*
      * Check and obtain command-line arguments
      */
-    if (argc != 2) {
+    if (argc != 3) {
         fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
         exit(1);
     }
@@ -37,6 +37,11 @@ int main(int argc, char **argv) {
     char *server_port = argv[1];
     char *database = argv[2];
 
+    // Open the database file
+    FILE *fp = fopen(database, "rb");
+    if (fp == NULL)
+        die(database);
+
     /*
      * Construct socket address information using getaddrinfo().
      */
@@ -114,10 +119,18 @@ int main(int argc, char **argv) {
         /*
          * Handle client connection.
          */
+        
+       
+        /*
+        * Open client file descriptor as FILE pointers.
+        */
+        FILE *clnt_r = fdopen(clnt_fd, "rb");
+        if (clnt_r == NULL)
+            die("fdopen");
 
-        FILE *fp = fopen(database, "rb");
-        if (fp == NULL)
-            die(database);
+        FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+        if (clnt_w == NULL)
+            die("fdopen");
 
         /*
          * read all records into memory
@@ -130,45 +143,92 @@ int main(int argc, char **argv) {
         if (loaded < 0)
             die("loadmdb");
 
-        if (fclose(fp) < 0)
-            perror("file");
+        fseek(fp, 0, SEEK_SET);   
         
         /*
          * lookup loop
          */
-        
+              
         char line[1024];
         char key[KeyMax + 1];
-
-       
-        // clear up the key!!
+         
+        while(fgets(line, sizeof(line), clnt_r) != NULL){
+  
+            /*
+             * clean up user input
+             */
+            
+            if(strlen(line) >= 2 && line[strlen(line)-2] == '\r'){
+                line[strlen(line)-2] = '\n';
+                line[strlen(line)-1] = 0;
+            }
+
+            // must null-terminate the string manually after strncpy().
+            strncpy(key, line, sizeof(key) - 1);
+            key[sizeof(key) - 1] = '\0';
+
+            // if newline is within the first KeyMax characters, remove it.
+            size_t last = strlen(key) - 1;
+            if (key[last] == '\n')
+                key[last] = '\0';
+
+            // user might have typed more than sizeof(line) - 1 characters in line;
+            // continue fgets()ing until we encounter a newline.
+            while (line[strlen(line) - 1] != '\n' && fgets(line, sizeof(line), clnt_r))
+                ;
+
+            /*
+             * search with key
+             */
+
+            // traverse the list, printing out the matching records
+            struct Node *node = list.head;
+            int recNo = 1;
+            while (node) {
+                struct MdbRec *rec = (struct MdbRec *)node->data;
+
+                if (strstr(rec->name, key) || strstr(rec->msg, key))
+                    fprintf(clnt_w, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+
+                node = node->next;
+                recNo++;
+            }
+            
+            fflush(clnt_w);
         
-        // open a file pointer
-        // make 
+        }
+       
+        // see if fgets() produced error CHECK THIS! SHOULD YOU DIE?
+        if (ferror(clnt_r))
+            perror("clnt_r");
 
-       /*
-        * search with key
-        */
+        /*
+         * clean up and quit
+         */
 
-        // traverse the list, printing out the matching records
-        struct Node *node = list.head;
-        int recNo = 1;
-        while (node) {
-            struct MdbRec *rec = (struct MdbRec *)node->data;
+        freemdb(&list);
 
-            if (strstr(rec->name, key) || strstr(rec->msg, key))
-                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+       /*
+        * Done with client request; close the connection and log the transaction.
+        */
 
-            node = node->next;
-            recNo++;
-        }
+        // Closing can FILE pointers can also produce errors, which we log.
+        if (fclose(clnt_w) < 0)
+            perror("clnt_w");
 
-        // Close client connection.
-        close(clnt_fd);
+        if (fclose(clnt_r) < 0)
+            perror("clnt_r");
 
         // Resume server loop to handle next client connection.
     }
-
+   
+   /*
+    * UNREACHABLE
+    */
+    
+    if (fclose(fp) < 0)
+        perror("file");
+    
     close(serv_fd);
     return 0;
 }
-- 
2.34.1


From f9827408c9474f66f2efa62a5ac50dc3438824dd Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 01:36:14 -0500
Subject: [PATCH 03/10] I did part 1.

---
 part1/mdb-lookup-server.c | 262 ++++++++++++++++++++++++--------------
 1 file changed, 164 insertions(+), 98 deletions(-)

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index bb1a9fe..f523464 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -25,101 +25,16 @@ static void die(const char *message)
     exit(1);
 }
 
-int main(int argc, char **argv) {
-    /*
-     * Check and obtain command-line arguments
-     */
-    if (argc != 3) {
-        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
-        exit(1);
-    }
-
-    char *server_port = argv[1];
-    char *database = argv[2];
-
-    // Open the database file
-    FILE *fp = fopen(database, "rb");
-    if (fp == NULL)
-        die(database);
-
-    /*
-     * Construct socket address information using getaddrinfo().
-     */
-
-    // Define hints for getaddrinfo(), which we need to zero out first.
-    struct addrinfo hints;
-
-    memset(&hints, 0, sizeof(hints));
-
-    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
-    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
-    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
-    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
-
-    // Define where getaddrinfo() will return the information it found.
-    struct addrinfo *info;
-
-    // Call getaddrinfo(), specifying the server IP address and port as strings.
-    // getaddrinfo() will parse those for us and point info to the result.
-    int addr_err;
-    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
-        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
-        exit(1);
-    }
-
-    // N.B. info actually points to a linked list of address information
-    // structures; assume that the first is sufficient and ignore the rest.
-
-    /*
-     * Create socket() and prepare it to accept() connections.
-     */
-
-    // Create socket() according to the address family, socket type, and
-    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
-    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
-    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
-    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
-    if (serv_fd < 0)
-        die("socket");
-
-    // bind() socket to a port on the server; the port in info->ai_addr should
-    // be the same port that getaddrinfo() parsed from server_port.
-    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
-        die("bind");
-
-    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
-    freeaddrinfo(info);
-
-    // Start listen()ing for connections on this socket, maintaining a queue of
-    // at most 8 pending connections.
-    if (listen(serv_fd, 8) < 0)
-        die("listen");
-
-    for (;;) {
-
-        /*
-         * accept() connection from client.
-         */
-
-        // Define space to receive client address info.
-        struct sockaddr_in clnt_addr;
-        socklen_t clnt_addr_len = sizeof(clnt_addr);
-
-        // accept() blocks until a client connects with the server, and returns
-        // a NEW socket file descriptor for interacting with the client.
-        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
-                             &clnt_addr_len);
-        if (clnt_fd < 0)
-            die("accept");
-
-        // clnt_addr is now populated with information about the client.
-        fprintf(stderr, "Accepted connection from %s\n",
-                inet_ntoa(clnt_addr.sin_addr));
+static void handle_client(char *database, int clnt_fd){
 
         /*
          * Handle client connection.
          */
-        
+
+        // Open the database file
+        FILE *fp = fopen(database, "rb");
+        if (fp == NULL)
+            die(database);
        
         /*
         * Open client file descriptor as FILE pointers.
@@ -141,9 +56,10 @@ int main(int argc, char **argv) {
 
         int loaded = loadmdb(fp, &list);
         if (loaded < 0)
-            die("loadmdb");
-
-        fseek(fp, 0, SEEK_SET);   
+            die("loadmdb");   
+   
+        if (fclose(fp) < 0)
+            perror("file");
         
         /*
          * lookup loop
@@ -192,8 +108,11 @@ int main(int argc, char **argv) {
 
                 node = node->next;
                 recNo++;
+                fflush(clnt_w);
             }
             
+            fprintf(clnt_w, "\n");
+
             fflush(clnt_w);
         
         }
@@ -205,7 +124,7 @@ int main(int argc, char **argv) {
         /*
          * clean up and quit
          */
-
+ 
         freemdb(&list);
 
        /*
@@ -220,15 +139,162 @@ int main(int argc, char **argv) {
             perror("clnt_r");
 
         // Resume server loop to handle next client connection.
+}
+
+static void sigchld_handler(int sig)
+{
+    // Keep reaping dead children until there aren't any to reap.
+    while (waitpid(-1, NULL, WNOHANG) > 0)
+        ;
+}
+
+
+int main(int argc, char **argv) {
+
+    /*
+     * Configure signal-handling.
+     */
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+
+    // Ignore SIGPIPE so that we don't terminate when we call
+    // send() on a disconnected socket.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction(SIGPIPE)");
+
+    // Install a handler for the SIGCHLD signal so that we can reap children
+    // who have finished processing their requests.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
+    sa.sa_handler = &sigchld_handler;
+    if (sigaction(SIGCHLD, &sa, NULL))
+        die("sigaction(SIGCHLD)");
+
+    /*
+     * Check and obtain command-line arguments
+     */
+    if (argc != 3) {
+        fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);
+        exit(1);
+    }
+
+    char *server_port = argv[1];
+    char *database = argv[2];
+
+    /*
+     * Construct socket address information using getaddrinfo().
+     */
+
+    // Define hints for getaddrinfo(), which we need to zero out first.
+    struct addrinfo hints;
+
+    memset(&hints, 0, sizeof(hints));
+
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+    hints.ai_flags = AI_PASSIVE;      // Construct socket address for bind()ing
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, server_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    // N.B. info actually points to a linked list of address information
+    // structures; assume that the first is sufficient and ignore the rest.
+
+    /*
+     * Create socket() and prepare it to accept() connections.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    // bind() socket to a port on the server; the port in info->ai_addr should
+    // be the same port that getaddrinfo() parsed from server_port.
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info);
+
+    // Start listen()ing for connections on this socket, maintaining a queue of
+    // at most 8 pending connections.
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    for (;;) {
+
+        /*
+         * accept() connection from client.
+         */
+
+        // Define space to receive client address info.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_addr_len = sizeof(clnt_addr);
+
+        // accept() blocks until a client connects with the server, and returns
+        // a NEW socket file descriptor for interacting with the client.
+        int clnt_fd = accept(serv_fd, (struct sockaddr *) &clnt_addr,
+                             &clnt_addr_len);
+        if (clnt_fd < 0)
+            die("accept");
+        
+        pid_t pid = fork();
+        if (pid < 0)
+            die("fork");
+
+        if (pid > 0) {
+            /*
+             * Parent process:
+             *
+             * Close client socket and continue accept()ing connections.
+             */
+
+            close(clnt_fd);
+
+            continue;
+        }
+
+        /*
+         * Child process:
+         *
+         * Close server socket, handle the client, and exit.
+         */
+
+        close(serv_fd);
+
+        // clnt_addr is populated with information about the client.
+        fprintf(stderr, "Connection started: %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+
+        handle_client(database, clnt_fd);
+
+        fprintf(stderr, "Connection terminated: %s\n",
+                inet_ntoa(clnt_addr.sin_addr));
+       
+        exit(0);
     }
    
    /*
     * UNREACHABLE
     */
     
-    if (fclose(fp) < 0)
-        perror("file");
-    
     close(serv_fd);
     return 0;
 }
-- 
2.34.1


From 9acec0aafb2a5401645ae224ffee41c01f95de52 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 02:56:44 -0500
Subject: [PATCH 04/10] Added the skeletal code for part2.

---
 README.txt          |   8 +-
 part2/Makefile      |  14 ++
 part2/http-server.c | 452 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 470 insertions(+), 4 deletions(-)
 create mode 100644 part2/Makefile
 create mode 100644 part2/http-server.c

diff --git a/README.txt b/README.txt
index 49c4472..08c20e8 100644
--- a/README.txt
+++ b/README.txt
@@ -1,9 +1,9 @@
 This file should contain:
 
-  - your name
-  - your UNI
-  - lab assignment number
-  - description for each part
+  - Arman Ozcan
+  - ao2794
+  - lab 7
+  - My programs should work as they are supposed to.
 
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..6646a20
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,14 @@
+CC = gcc
+CFLAGS = -g -Wall -Wpedantic -std=c17
+LDFLAGS =
+LDLIBS =
+
+http-server:
+http-server.o:
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core http-server
+
+.PHONY: all
+all: clean http-server
diff --git a/part2/http-server.c b/part2/http-server.c
new file mode 100644
index 0000000..998e393
--- /dev/null
+++ b/part2/http-server.c
@@ -0,0 +1,452 @@
+#define _GNU_SOURCE
+#include <arpa/inet.h>
+#include <linux/limits.h>
+#include <netdb.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <unistd.h>
+
+#define MAXPENDING 5          // Maximum outstanding connection requests
+#define MAX_LINE_LENGTH 1024  // Maximum line length for request and headers
+#define DISK_IO_BUF_SIZE 4096 // Size of buffer for reading and sending files
+
+static void die(const char *message)
+{
+    perror(message);
+    exit(1);
+}
+
+/*
+ * HTTP/1.0 status codes and the corresponding reason phrases.
+ */
+static struct {
+    int status;
+    char *reason;
+} http_status_codes[] = {
+    { 200, "OK" },
+    { 201, "Created" },
+    { 202, "Accepted" },
+    { 204, "No Content" },
+    { 301, "Moved Permanently" },
+    { 302, "Moved Temporarily" },
+    { 304, "Not Modified" },
+    { 400, "Bad Request" },
+    { 401, "Unauthorized" },
+    { 403, "Forbidden" },
+    { 404, "Not Found" },
+    { 500, "Internal Server Error" },
+    { 501, "Not Implemented" },
+    { 502, "Bad Gateway" },
+    { 503, "Service Unavailable" },
+    { 0, NULL } // marks the end of the list
+};
+
+static inline const char *get_reason_phrase(int status_code)
+{
+    int i = -1;
+    while (http_status_codes[++i].status > 0)
+        if (http_status_codes[i].status == status_code)
+            return http_status_codes[i].reason;
+    return "Unknown Status Code";
+}
+
+/*
+ * Send HTTP status line.
+ *
+ * Returns negative if send() failed.
+ */
+static int send_status_line(FILE *fp, int status_code)
+{
+    const char *reason_phrase = get_reason_phrase(status_code);
+    return fprintf(fp, "HTTP/1.0 %d %s\r\n", status_code, reason_phrase);
+}
+
+/*
+ * Send blank line.
+ *
+ * Returns number of bytes sent; returns negative if failed.
+ */
+static int send_blank_line(FILE *fp)
+{
+    return fprintf(fp, "\r\n");
+}
+
+/*
+ * Send a generic HTTP response for error statuses (400+).
+ *
+ * Returns negative if failed.
+ */
+static int send_error_status(FILE *fp, int status_code)
+{
+    if (send_status_line(fp, status_code) < 0)
+        return -1;
+
+    // no headers needed
+    if (send_blank_line(fp) < 0)
+        return -1;
+
+    return fprintf(fp,
+        "<html><body>\n"
+        "<h1>%d %s</h1>\n"
+        "</body></html>\n",
+        status_code, get_reason_phrase(status_code));
+}
+
+/*
+ * Send 301 status: redirect the browser to request_uri with '/' appended to it.
+ *
+ * Returns negative if failed.
+ */
+static int send301(const char *request_uri, FILE *fp)
+{
+    if (send_status_line(fp, 301) < 0)
+        return -1;
+
+    // Send Location header and format redirection link in HTML in case browser
+    // doesn't automatically redirect.
+    return fprintf(fp,
+        "Location: %s/\r\n"
+        "\r\n"
+        "<html><body>\n"
+        "<h1>301 Moved Permanently</h1>\n"
+        "<p>The document has moved "
+        "<a href=\"%s/\">here</a>.</p>\n"
+        "</body></html>\n",
+        request_uri, request_uri);
+}
+
+/*
+ * Handle static file requests.
+ * Returns the HTTP status code that was sent to the browser.
+ *
+ * If send() ever fails (i.e., could not write to clnt_w), report the error and
+ * move on.
+ */
+static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w)
+{
+    /*
+     * Define variables that we will need to use before we return.
+     */
+
+    int status_code; // We'll return this value.
+    FILE *fp = NULL; // We'll fclose() this at the end.
+
+    // Set clnt_w to line-buffering so that lines are flushed immediately.
+    setlinebuf(clnt_w);
+
+    /*
+     * Construct the path of the requested file from web_root and request_uri.
+     */
+
+    char file_path[PATH_MAX];
+
+    if (strlen(web_root) + strlen(request_uri) + 12 > sizeof(file_path)) {
+        // File paths can't exceed sizeof(file_path) on Linux, so just 404.
+        status_code = 404; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    strcpy(file_path, web_root);
+
+    // Note: since the URI definitely begins with '/', we don't need to worry
+    // about appending '/' to web_root.
+
+    strcat(file_path, request_uri);
+
+    // If request_uri ends with '/', append "index.html".
+    if (file_path[strlen(file_path) - 1] == '/')
+        strcat(file_path, "index.html");
+
+    /*
+     * Open the requested file.
+     */
+
+    // See if the requested file is a directory.
+    struct stat st;
+    if (stat(file_path, &st) == 0 && S_ISDIR(st.st_mode)) {
+        status_code = 301; // "Moved Permanently"
+        if (send301(request_uri, clnt_w) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    // If unable to open the file, send "404 Not Found".
+    fp = fopen(file_path, "rb");
+    if (fp == NULL) {
+        status_code = 404; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        goto cleanup;
+    }
+
+    // Otherwise, send "200 OK".
+    status_code = 200; // "OK"
+    if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+        perror("send");
+        goto cleanup;
+    }
+
+    /*
+     * Send the file.
+     */
+
+    // Buffer for file contents.
+    char file_buf[DISK_IO_BUF_SIZE];
+
+    // Turn off buffering for clnt_w because we already have our own file_buf.
+    if (fflush(clnt_w) < 0) {
+        perror("send");
+        goto cleanup;
+    }
+    setbuf(clnt_w, NULL);
+
+    // Read and send file in a block at a time.
+    size_t n;
+    while ((n = fread(file_buf, 1, sizeof(file_buf), fp)) > 0) {
+        if (fwrite(file_buf, 1, n, clnt_w) != n) {
+            perror("send");
+            goto cleanup;
+        }
+    }
+
+    // fread() returns 0 both on EOF and on error; check if there was an error.
+    if (ferror(fp))
+        // Note that if we had an error, we sent the client a truncated (i.e.,
+        // corrupted) file; not much we can do about that at this point since
+        // we already sent the status...
+        perror("fread");
+
+cleanup:
+
+    /*
+     * close() the FILE pointer and return.
+     */
+
+    if (fp)
+        fclose(fp);
+
+    return status_code;
+}
+
+void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
+{
+    /*
+     * Open client file descriptor as FILE pointers.
+     */
+    FILE *clnt_r = fdopen(clnt_fd, "rb");
+    if (clnt_r == NULL)
+        die("fdopen");
+
+    FILE *clnt_w = fdopen(dup(clnt_fd), "wb");
+    if (clnt_w == NULL)
+        die("fdopen");
+
+    /*
+     * Let's parse the request line.
+     */
+
+    // Note: we'll use these fields at the end when we log the connection.
+    int status_code;
+    char *method = NULL, *request_uri = NULL, *http_version = NULL, *extra;
+
+    char request_buf[MAX_LINE_LENGTH];
+
+    if (fgets(request_buf, sizeof(request_buf), clnt_r) == NULL) {
+        // Socket closed prematurely; there isn't much we can do
+        status_code = 400; // "Bad Request"
+        goto terminate_connection;
+    }
+
+    char *token_separators = "\t \r\n"; // tab, space, new line
+
+    method = strtok(request_buf, token_separators);
+    request_uri = strtok(NULL, token_separators);
+    http_version = strtok(NULL, token_separators);
+    extra = strtok(NULL, token_separators);
+
+    // Note: We must not modify request_buf past this point, because method,
+    // request_uri, http_version, and extra point to within request_buf.
+
+    // Check that we have exactly three tokens in the request line.
+    if (!method || !request_uri || !http_version || extra) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // We only support GET requests.
+    if (strcmp(method, "GET")) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // We only support HTTP/1.0 and HTTP/1.1.
+    if (strcmp(http_version, "HTTP/1.0") && strcmp(http_version, "HTTP/1.1")) {
+        status_code = 501; // "Not Implemented"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // request_uri must begin with "/".
+    if (!request_uri || *request_uri != '/') {
+        status_code = 400; // "Bad Request"
+        send_error_status(clnt_w, status_code);
+        goto terminate_connection;
+    }
+
+    // Ensure request_uri does not contain "/../" and does not end with "/..".
+    int uri_len = strlen(request_uri);
+    if (uri_len >= 3) {
+        char *tail = request_uri + (uri_len - 3);
+        if (strcmp(tail, "/..") == 0 || strstr(request_uri, "/../") != NULL) {
+            status_code = 400; // "Bad Request"
+            send_error_status(clnt_w, status_code);
+            goto terminate_connection;
+        }
+    }
+
+    /*
+     * Skip HTTP headers.
+     */
+
+    // We need another buffer for trashing the headers, because request_buf
+    // still currently holds the method, request_uri, and http_version strings.
+    char line_buf[MAX_LINE_LENGTH];
+
+    while (1) {
+        if (fgets(line_buf, sizeof(line_buf), clnt_r) == NULL) {
+            // Socket closed prematurely; there isn't much we can do
+            status_code = 400; // "Bad Request"
+            goto terminate_connection;
+        }
+
+        // Check if we have reached the end of the headers, i.e., an empty line.
+        if (strcmp("\r\n", line_buf) == 0 || strcmp("\n", line_buf) == 0)
+            break;
+    }
+
+    /*
+     * We have a well-formed HTTP GET request; time to handle it.
+     */
+
+    status_code = handle_file_request(web_root, request_uri, clnt_w);
+
+terminate_connection:
+
+    /*
+     * Done with client request; close the connection and log the transaction.
+     */
+
+    // Closing can FILE pointers can also produce errors, which we log.
+    if (fclose(clnt_w) < 0)
+        perror("send");
+
+    if (fclose(clnt_r) < 0)
+        perror("recv");
+
+    fprintf(stderr, "%s \"%s %s %s\" %d %s\n",
+        clnt_ip,
+        method,
+        request_uri,
+        http_version,
+        status_code,
+        get_reason_phrase(status_code));
+}
+
+int main(int argc, char *argv[])
+{
+    /*
+     * Configure signal-handling.
+     */
+
+    struct sigaction sa;
+    memset(&sa, 0, sizeof(sa));
+
+    // Ignore SIGPIPE so that we don't terminate when we call
+    // send() on a disconnected socket.
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL))
+        die("sigaction(SIGPIPE)");
+
+    /*
+     * Parse arguments.
+     */
+
+    if (argc != 3) {
+        fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv[0]);
+        exit(1);
+    }
+
+    char *serv_port = argv[1];
+    char *web_root = argv[2];
+
+    /*
+     * Construct server socket to listen on serv_port.
+     */
+
+    struct addrinfo hints, *info;
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_INET;       // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM; // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP; // TCP protocol
+    hints.ai_flags = AI_PASSIVE;     // Construct socket address for bind()ing
+
+    int addr_err;
+    if ((addr_err = getaddrinfo(NULL, serv_port, &hints, &info)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    int serv_fd = socket(info->ai_family, info->ai_socktype, info->ai_protocol);
+    if (serv_fd < 0)
+        die("socket");
+
+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)
+        die("bind");
+
+    if (listen(serv_fd, 8) < 0)
+        die("listen");
+
+    freeaddrinfo(info);
+
+    /*
+     * Server accept() loop.
+     */
+
+    for (;;) {
+        // We only need sockaddr_in since we only accept IPv4 peers.
+        struct sockaddr_in clnt_addr;
+        socklen_t clnt_len = sizeof(clnt_addr);
+
+        int clnt_fd = accept(serv_fd, (struct sockaddr *)&clnt_addr, &clnt_len);
+        if (clnt_fd < 0)
+            die("accept");
+
+        char clnt_ip[INET_ADDRSTRLEN];
+
+        if (inet_ntop(AF_INET, &clnt_addr.sin_addr, clnt_ip, sizeof(clnt_ip))
+            == NULL)
+            die("inet_ntop");
+
+        handle_client(web_root, clnt_fd, clnt_ip);
+    }
+
+    /*
+     * UNREACHABLE
+     */
+
+    close(serv_fd);
+
+    return 0;
+}
-- 
2.34.1


From de8e9262d9f21956eb524d448b8ee747d84ba0a7 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 17:41:04 -0500
Subject: [PATCH 05/10] Now, part2 works partially. When mdb-lookup is called,
 it always prints the default page.

---
 part2/http-server.c | 99 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 93 insertions(+), 6 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 998e393..8748882 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -127,7 +127,21 @@ static int send301(const char *request_uri, FILE *fp)
  * If send() ever fails (i.e., could not write to clnt_w), report the error and
  * move on.
  */
-static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w)
+
+static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
+    const char *form =
+          "<h1>mdb-lookup</h1>\n"
+          "<p>\n"
+          "<form method=GET action=/mdb-lookup>\n"
+          "lookup: <input type=text name=key>\n"
+          "<input type=submit>\n"
+          "</form>\n"
+          "<p>\n";
+
+    fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form);
+}
+
+static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
 {
     /*
      * Define variables that we will need to use before we return.
@@ -138,6 +152,21 @@ static int handle_file_request(const char *web_root, const char *request_uri, FI
 
     // Set clnt_w to line-buffering so that lines are flushed immediately.
     setlinebuf(clnt_w);
+    
+    // enter if uri is /mdb-lookup or it starts with /mdb-lookup?
+    if(!strcmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "/mdb-lookup?", 12)){
+     
+        status_code = 200; // "OK"
+        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+            perror("send");
+            goto cleanup;
+        }
+
+        // return the result
+        handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        
+        goto cleanup;
+    }
+
 
     /*
      * Construct the path of the requested file from web_root and request_uri.
@@ -235,7 +264,7 @@ cleanup:
     return status_code;
 }
 
-void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
+void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip, FILE *mdb_r, FILE *mdb_w)
 {
     /*
      * Open client file descriptor as FILE pointers.
@@ -337,7 +366,7 @@ void handle_client(const char *web_root, int clnt_fd, const char *clnt_ip)
      * We have a well-formed HTTP GET request; time to handle it.
      */
 
-    status_code = handle_file_request(web_root, request_uri, clnt_w);
+    status_code = handle_file_request(web_root, request_uri, clnt_w, mdb_r, mdb_w);
 
 terminate_connection:
 
@@ -382,13 +411,15 @@ int main(int argc, char *argv[])
      * Parse arguments.
      */
 
-    if (argc != 3) {
-        fprintf(stderr, "usage: %s <server-port> <web-root>\n", argv[0]);
+    if (argc != 5) {
+        fprintf(stderr, "usage: %s <server-port> <web-root> <mdb-host> <mdb-port>\n", argv[0]);
         exit(1);
     }
 
     char *serv_port = argv[1];
     char *web_root = argv[2];
+    char *mdb_host = argv[3];
+    char *mdb_port = argv[4];
 
     /*
      * Construct server socket to listen on serv_port.
@@ -420,6 +451,60 @@ int main(int argc, char *argv[])
 
     freeaddrinfo(info);
 
+    /*
+     * Construct client socket to connect to mdb-lookup-server.
+     */
+
+    // Zero out hints first.
+    memset(&hints, 0, sizeof(hints));
+
+    // Specify what kind of connection we intend to make; these values tell
+    // getaddrinfo() that we don't care about other kinds of addresses.
+    hints.ai_family = AF_INET;        // Only accept IPv4 addresses
+    hints.ai_socktype = SOCK_STREAM;  // stream socket for TCP connections
+    hints.ai_protocol = IPPROTO_TCP;  // TCP protocol
+
+    // Define where getaddrinfo() will return the information it found.
+    struct addrinfo *info_mdb;
+
+    // Call getaddrinfo(), specifying the server IP address and port as strings.
+    // getaddrinfo() will parse those for us and point info to the result.
+    if ((addr_err = getaddrinfo(mdb_host, mdb_port, &hints, &info_mdb)) != 0) {
+        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));
+        exit(1);
+    }
+
+    /*
+     * Create socket() and connect() it to server.
+     */
+
+    // Create socket() according to the address family, socket type, and
+    // protocol of the address info.  Since we specified AF_INET, SOCK_STREAM,
+    // and IPPROTO_TCP in the hints, this should be equivalent to just calling
+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).
+    int mdb_fd = socket(info_mdb->ai_family, info_mdb->ai_socktype, info_mdb->ai_protocol);
+    if (mdb_fd < 0)
+        die("socket");
+
+    // Connect socket with server address; the IP address and port in
+    // info->ai_addr should be the same address and port that getaddrinfo()
+    // parsed from server_address and server_port.
+    if (connect(mdb_fd, info_mdb->ai_addr, info_mdb->ai_addrlen) < 0)
+        die("connect");
+
+    // BTW: we're done with the info retrieved by getaddrinfo(), so free it.
+    freeaddrinfo(info_mdb);
+
+    /*
+     * Open mdb-lookup-server file descriptor as FILE pointers.
+     */
+    FILE *mdb_r = fdopen(mdb_fd, "rb");
+    if (mdb_r == NULL)
+        die("fdopen");
+
+    FILE *mdb_w = fdopen(dup(mdb_fd), "wb");
+    if (mdb_w == NULL)
+        die("fdopen");
     /*
      * Server accept() loop.
      */
@@ -439,13 +524,15 @@ int main(int argc, char *argv[])
             == NULL)
             die("inet_ntop");
 
-        handle_client(web_root, clnt_fd, clnt_ip);
+        handle_client(web_root, clnt_fd, clnt_ip, mdb_r, mdb_w);
     }
 
     /*
      * UNREACHABLE
      */
 
+    fclose(mdb_r);
+    fclose(mdb_w);
     close(serv_fd);
 
     return 0;
-- 
2.34.1


From 537bcddf9cea379212bb4ffafff70962f1692dfc Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 20:46:04 -0500
Subject: [PATCH 06/10] I am not quite sure, but it seems like part2 is working
 okay now. I have to check if the memory leaks are constant.

---
 part2/http-server.c | 65 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 63 insertions(+), 2 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 8748882..7de5023 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -130,7 +130,7 @@ static int send301(const char *request_uri, FILE *fp)
 
 static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
     const char *form =
-          "<h1>mdb-lookup</h1>\n"
+          "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n"
           "<p>\n"
           "<form method=GET action=/mdb-lookup>\n"
           "lookup: <input type=text name=key>\n"
@@ -138,7 +138,65 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
           "</form>\n"
           "<p>\n";
 
-    fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form);
+    if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
+        if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
+            perror("send");
+        return;
+    }
+                
+    fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
+
+    char key[strlen(request + 5) + 1];
+        
+    fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
+    
+    strncpy(key, request + 5, sizeof(key) - 1);
+
+    key[sizeof(key)  - 1] = '\n';
+    
+    fwrite(key, sizeof(key), 1, stderr);
+
+    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){
+        perror("send");
+        return;
+    }
+
+    // Buffer for result of lookup.
+    char result_buf[500];
+    int isYellow = 0;
+
+    if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
+        perror("send");
+
+    while(fgets(result_buf, sizeof(result_buf), mdb_r) != NULL ) {
+        if(!strcmp(result_buf, "\n")){
+            fprintf(stderr,"I found newline character at the response!\n");
+            break;
+        }
+
+        if(isYellow){
+            if(fprintf(clnt_w, "<tr><td bgcolor=yellow>\n%s\n", result_buf) < 0)
+            perror("send");
+            isYellow = 0;
+        }else{
+            if(fprintf(clnt_w, "<tr><td>\n%s\n", result_buf) < 0)
+            perror("send");
+            isYellow = 1;
+        }
+    }
+    
+    if(ferror(mdb_r))
+        perror("mdb_lookup_server");
+
+
+    if(fprintf(clnt_w, "</table>\n</body></html>\n") < 0)
+        perror("send");
+ 
+
+    if (fflush(clnt_w) < 0)
+        perror("send");
+
+    return;
 }
 
 static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
@@ -505,6 +563,9 @@ int main(int argc, char *argv[])
     FILE *mdb_w = fdopen(dup(mdb_fd), "wb");
     if (mdb_w == NULL)
         die("fdopen");
+
+    setbuf(mdb_w, NULL);
+
     /*
      * Server accept() loop.
      */
-- 
2.34.1


From 66f20d2a0fe0a1547190d4a34e9d2bb0ec00daa6 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sat, 10 Dec 2022 23:27:33 -0500
Subject: [PATCH 07/10] Now part2 can send 500 Internal Server Error.

---
 part2/http-server.c | 34 +++++++++++++++++++++-------------
 1 file changed, 21 insertions(+), 13 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index 7de5023..44281c4 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -128,20 +128,22 @@ static int send301(const char *request_uri, FILE *fp)
  * move on.
  */
 
-static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
+static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){
     const char *form =
-          "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n"
+          "<h1>mdb-lookup</h1>\n"
           "<p>\n"
           "<form method=GET action=/mdb-lookup>\n"
           "lookup: <input type=text name=key>\n"
           "<input type=submit>\n"
           "</form>\n"
           "<p>\n";
+        
+    int status_code;
 
     if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
         if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
             perror("send");
-        return;
+        return 1;
     }
                 
     fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
@@ -156,15 +158,23 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
     
     fwrite(key, sizeof(key), 1, stderr);
 
-    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){
+    if(fwrite(key, sizeof(key), 1, mdb_w) != 1){ 
         perror("send");
-        return;
+        status_code = 500; // "Not Found"
+        if (send_error_status(clnt_w, status_code) < 0)
+            perror("send");
+        return 0;
     }
 
     // Buffer for result of lookup.
     char result_buf[500];
     int isYellow = 0;
 
+    status_code = 200; // "OK"
+    if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
+        perror("send");
+    }
+
     if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
         perror("send");
 
@@ -196,7 +206,7 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *
     if (fflush(clnt_w) < 0)
         perror("send");
 
-    return;
+    return 1;
 }
 
 static int handle_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)
@@ -213,15 +223,13 @@ static int handle_file_request(const char *web_root, const char *request_uri, FI
     
     // enter if uri is /mdb-lookup or it starts with /mdb-lookup?
     if(!strcmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "/mdb-lookup?", 12)){
-     
-        status_code = 200; // "OK"
-        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {
-            perror("send");
-            goto cleanup;
-        }
 
         // return the result
-        handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        
+        if(handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w)){
+            status_code = 200;
+        }else{
+            status_code = 500;
+        }     
         goto cleanup;
     }
 
-- 
2.34.1


From abd922f7427ed2fb37f27b4d2ded014a2f972f12 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Sun, 11 Dec 2022 03:16:46 -0500
Subject: [PATCH 08/10] Fixed a little bug when the default lookup page is
 printed.

---
 part2/http-server.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/part2/http-server.c b/part2/http-server.c
index 44281c4..d581745 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -141,6 +141,10 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
     int status_code;
 
     if(strlen(request) < 5 || strncmp(request, "?key=", 5) ){
+        status_code = 200; // "OK"
+        if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0)
+            perror("send");
+
         if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n", form) < 0)
             perror("send");
         return 1;
-- 
2.34.1


From 8b71c382d86a5a0205505a6a219936b46b72e707 Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 14 Dec 2022 17:50:47 -0500
Subject: [PATCH 09/10] Final commit!

---
 part2/http-server.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/part2/http-server.c b/part2/http-server.c
index d581745..c5635b4 100644
--- a/part2/http-server.c
+++ b/part2/http-server.c
@@ -150,20 +150,20 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
         return 1;
     }
                 
-    fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
+    //fprintf(stderr, "Length of request after = %ld\n", strlen(request + 5));
 
     char key[strlen(request + 5) + 1];
         
-    fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
+    //fprintf(stderr, "Size of key array = %ld\nThis is the array: ", sizeof(key));
     
     strncpy(key, request + 5, sizeof(key) - 1);
 
     key[sizeof(key)  - 1] = '\n';
     
-    fwrite(key, sizeof(key), 1, stderr);
+    //fwrite(key, sizeof(key), 1, stderr);
 
     if(fwrite(key, sizeof(key), 1, mdb_w) != 1){ 
-        perror("send");
+        perror("mdb-lookup-server send");
         status_code = 500; // "Not Found"
         if (send_error_status(clnt_w, status_code) < 0)
             perror("send");
@@ -182,9 +182,10 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
     if(fprintf(clnt_w, "<html><body>\n%s<p><table border>\n", form) < 0)
         perror("send");
 
+    int i = 1;
     while(fgets(result_buf, sizeof(result_buf), mdb_r) != NULL ) {
         if(!strcmp(result_buf, "\n")){
-            fprintf(stderr,"I found newline character at the response!\n");
+            i = 0;
             break;
         }
 
@@ -199,8 +200,11 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m
         }
     }
     
+    if(i)
+        perror("mdb-lookup-server recv");
+
     if(ferror(mdb_r))
-        perror("mdb_lookup_server");
+        perror("mdb-lookup-server");
 
 
     if(fprintf(clnt_w, "</table>\n</body></html>\n") < 0)
-- 
2.34.1


From ffff1628f2dae8cdd5a7044f01d301a69732b5fb Mon Sep 17 00:00:00 2001
From: Arman Ozcan <ao2794@columbia.edu>
Date: Wed, 14 Dec 2022 19:58:54 -0500
Subject: [PATCH 10/10] One last commit (fixed the case when the database file
 doesn't exist, now it logs the terminated line)

---
 part1/mdb-lookup-server.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index f523464..5c058bc 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -33,9 +33,10 @@ static void handle_client(char *database, int clnt_fd){
 
         // Open the database file
         FILE *fp = fopen(database, "rb");
-        if (fp == NULL)
-            die(database);
-       
+        if (fp == NULL){
+            perror("fopen");
+            return;
+        }
         /*
         * Open client file descriptor as FILE pointers.
         */
@@ -138,6 +139,7 @@ static void handle_client(char *database, int clnt_fd){
         if (fclose(clnt_r) < 0)
             perror("clnt_r");
 
+        return;
         // Resume server loop to handle next client connection.
 }
 
-- 
2.34.1


--K83sDo3EOYo3DfJy
Content-Type: application/mbox
Content-Disposition: attachment; filename="ao2794-lab7.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 5b3cf0a1b0e8127cf80fa450a98c1d32513c8579 Mon Sep 17 00:00:00 2001=0A=
=46rom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Thu, 8 Dec 2022 22:05:32 =
-0500=0ASubject: [PATCH 01/10] First commit.=0A=0A---=0A part1/Makefile    =
        |  22 +++++=0A part1/mdb-lookup-server.c | 174 ++++++++++++++++++++=
++++++++++++++++++=0A part1/mdb.c               |  53 ++++++++++++=0A part1=
/mdb.h               |  18 +++-=0A 4 files changed, 264 insertions(+), 3 de=
letions(-)=0A create mode 100644 part1/Makefile=0A create mode 100644 part1=
/mdb-lookup-server.c=0A create mode 100644 part1/mdb.c=0A=0Adiff --git a/pa=
rt1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 0000000..6f5a4=
7e=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,22 @@=0A+CC =3D gcc=
=0A+=0A+# Support externally overriding CFLAGS=0A+CFLAGS ?=3D -g -Wall -Wpe=
dantic -std=3Dc17=0A+CFLAGS +=3D -I/home/j-hui/cs3157-pub/include=0A+=0A+LD=
FLAGS =3D -L/home/j-hui/cs3157-pub/lib=0A+LDLIBS =3D -lmylist=0A+=0A+.PHONY=
: default=0A+default: mdb-lookup-server=0A+=0A+mdb-lookup-server: mdb-looku=
p-server.o mdb.o=0A+mdb-lookup-server.o: mdb-lookup-server.c mdb.h=0A+mdb.o=
: mdb.h=0A+	=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core mdb-lookup=
-server=0A+=0A+.PHONY: all=0A+all: clean default=0Adiff --git a/part1/mdb-l=
ookup-server.c b/part1/mdb-lookup-server.c=0Anew file mode 100644=0Aindex 0=
000000..7072e1f=0A--- /dev/null=0A+++ b/part1/mdb-lookup-server.c=0A@@ -0,0=
 +1,174 @@=0A+#define _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#include <li=
nux/limits.h>=0A+#include <netdb.h>=0A+#include <signal.h>=0A+#include <std=
io.h>=0A+#include <stdlib.h>=0A+#include <string.h>=0A+#include <sys/socket=
=2Eh>=0A+#include <sys/stat.h>=0A+#include <sys/types.h>=0A+#include <sys/w=
ait.h>=0A+#include <time.h>=0A+#include <unistd.h>=0A+#include <mylist.h>=
=0A+#include "mdb.h"=0A+=0A+#define KeyMax 5=0A+#define MAX_LINE_LENGTH 102=
4  // Maximum line length for request and headers=0A+#define DISK_IO_BUF_SI=
ZE 4096 // Size of buffer for reading and sending files=0A+=0A+static void =
die(const char *message)=0A+{=0A+    perror(message);=0A+    exit(1);=0A+}=
=0A+=0A+int main(int argc, char **argv) {=0A+    /*=0A+     * Check and obt=
ain command-line arguments=0A+     */=0A+    if (argc !=3D 2) {=0A+        =
fprintf(stderr, "Usage: %s <server-port> <database>\n", argv[0]);=0A+      =
  exit(1);=0A+    }=0A+=0A+    char *server_port =3D argv[1];=0A+    char *=
database =3D argv[2];=0A+=0A+    /*=0A+     * Construct socket address info=
rmation using getaddrinfo().=0A+     */=0A+=0A+    // Define hints for geta=
ddrinfo(), which we need to zero out first.=0A+    struct addrinfo hints;=
=0A+=0A+    memset(&hints, 0, sizeof(hints));=0A+=0A+    hints.ai_family =
=3D AF_INET;        // Only accept IPv4 addresses=0A+    hints.ai_socktype =
=3D SOCK_STREAM;  // stream socket for TCP connections=0A+    hints.ai_prot=
ocol =3D IPPROTO_TCP;  // TCP protocol=0A+    hints.ai_flags =3D AI_PASSIVE=
;      // Construct socket address for bind()ing=0A+=0A+    // Define where=
 getaddrinfo() will return the information it found.=0A+    struct addrinfo=
 *info;=0A+=0A+    // Call getaddrinfo(), specifying the server IP address =
and port as strings.=0A+    // getaddrinfo() will parse those for us and po=
int info to the result.=0A+    int addr_err;=0A+    if ((addr_err =3D getad=
drinfo(NULL, server_port, &hints, &info)) !=3D 0) {=0A+        fprintf(stde=
rr, "getaddrinfo: %s\n", gai_strerror(addr_err));=0A+        exit(1);=0A+  =
  }=0A+=0A+    // N.B. info actually points to a linked list of address inf=
ormation=0A+    // structures; assume that the first is sufficient and igno=
re the rest.=0A+=0A+    /*=0A+     * Create socket() and prepare it to acce=
pt() connections.=0A+     */=0A+=0A+    // Create socket() according to the=
 address family, socket type, and=0A+    // protocol of the address info.  =
Since we specified AF_INET, SOCK_STREAM,=0A+    // and IPPROTO_TCP in the h=
ints, this should be equivalent to just calling=0A+    // socket(AF_INET, S=
OCK_STREAM, IPPROTO_TCP).=0A+    int serv_fd =3D socket(info->ai_family, in=
fo->ai_socktype, info->ai_protocol);=0A+    if (serv_fd < 0)=0A+        die=
("socket");=0A+=0A+    // bind() socket to a port on the server; the port i=
n info->ai_addr should=0A+    // be the same port that getaddrinfo() parsed=
 from server_port.=0A+    if (bind(serv_fd, info->ai_addr, info->ai_addrlen=
) < 0)=0A+        die("bind");=0A+=0A+    // BTW: we're done with the info =
retrieved by getaddrinfo(), so free it.=0A+    freeaddrinfo(info);=0A+=0A+ =
   // Start listen()ing for connections on this socket, maintaining a queue=
 of=0A+    // at most 8 pending connections.=0A+    if (listen(serv_fd, 8) =
< 0)=0A+        die("listen");=0A+=0A+    for (;;) {=0A+=0A+        /*=0A+ =
        * accept() connection from client.=0A+         */=0A+=0A+        //=
 Define space to receive client address info.=0A+        struct sockaddr_in=
 clnt_addr;=0A+        socklen_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=
=0A+        // accept() blocks until a client connects with the server, and=
 returns=0A+        // a NEW socket file descriptor for interacting with th=
e client.=0A+        int clnt_fd =3D accept(serv_fd, (struct sockaddr *) &c=
lnt_addr,=0A+                             &clnt_addr_len);=0A+        if (c=
lnt_fd < 0)=0A+            die("accept");=0A+=0A+        // clnt_addr is no=
w populated with information about the client.=0A+        fprintf(stderr, "=
Accepted connection from %s\n",=0A+                inet_ntoa(clnt_addr.sin_=
addr));=0A+=0A+        /*=0A+         * Handle client connection.=0A+      =
   */=0A+=0A+        FILE *fp =3D fopen(database, "rb");=0A+        if (fp =
=3D=3D NULL)=0A+            die(database);=0A+=0A+        /*=0A+         * =
read all records into memory=0A+         */=0A+=0A+        struct List list=
;=0A+        initList(&list);=0A+=0A+        int loaded =3D loadmdb(fp, &li=
st);=0A+        if (loaded < 0)=0A+            die("loadmdb");=0A+=0A+     =
   if (fclose(fp) < 0)=0A+            perror("file");=0A+        =0A+      =
  /*=0A+         * lookup loop=0A+         */=0A+        =0A+        char l=
ine[1024];=0A+        char key[KeyMax + 1];=0A+=0A+       =0A+        // cl=
ear up the key!!=0A+        =0A+        // open a file pointer=0A+        /=
/ make =0A+=0A+       /*=0A+        * search with key=0A+        */=0A+=0A+=
        // traverse the list, printing out the matching records=0A+        =
struct Node *node =3D list.head;=0A+        int recNo =3D 1;=0A+        whi=
le (node) {=0A+            struct MdbRec *rec =3D (struct MdbRec *)node->da=
ta;=0A+=0A+            if (strstr(rec->name, key) || strstr(rec->msg, key))=
=0A+                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->n=
ame, rec->msg);=0A+=0A+            node =3D node->next;=0A+            recN=
o++;=0A+        }=0A+=0A+        // Close client connection.=0A+        clo=
se(clnt_fd);=0A+=0A+        // Resume server loop to handle next client con=
nection.=0A+    }=0A+=0A+    close(serv_fd);=0A+    return 0;=0A+}=0Adiff -=
-git a/part1/mdb.c b/part1/mdb.c=0Anew file mode 100644=0Aindex 0000000..ce=
5243a=0A--- /dev/null=0A+++ b/part1/mdb.c=0A@@ -0,0 +1,53 @@=0A+/*=0A+ * md=
b.c=0A+ */=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <st=
ring.h>=0A+=0A+#include <mylist.h>=0A+=0A+#include "mdb.h"=0A+=0A+int loadm=
db(FILE *fp, struct List *dest)=0A+{=0A+    /*=0A+     * read all records i=
nto memory=0A+     */=0A+=0A+    struct MdbRec r;=0A+    struct Node *node =
=3D NULL;=0A+    int count =3D 0;=0A+=0A+    while (fread(&r, sizeof(r), 1,=
 fp) =3D=3D 1) {=0A+=0A+        // allocate memory for a new record and cop=
y into it the one=0A+        // that was just read from the database.=0A+  =
      struct MdbRec *rec =3D (struct MdbRec *)malloc(sizeof(r));=0A+       =
 if (!rec)=0A+            return -1;=0A+=0A+        memcpy(rec, &r, sizeof(=
r));=0A+=0A+        // add the record to the linked list.=0A+        node =
=3D addAfter(dest, node, rec);=0A+        if (node =3D=3D NULL)=0A+        =
    return -1;=0A+=0A+        count++;=0A+    }=0A+=0A+    // see if fread(=
) produced error=0A+    if (ferror(fp))=0A+        return -1;=0A+=0A+    re=
turn count;=0A+}=0A+=0A+void freemdb(struct List *list)=0A+{=0A+    // free=
 all the records=0A+    traverseList(list, &free);=0A+    removeAllNodes(li=
st);=0A+}=0Adiff --git a/part1/mdb.h b/part1/mdb.h=0Aindex fb091b5..6712a6c=
 100644=0A--- a/part1/mdb.h=0A+++ b/part1/mdb.h=0A@@ -1,9 +1,21 @@=0A-#ifnd=
ef __MDB_H__=0A-#define __MDB_H__=0A+/*=0A+ * mdb.h=0A+ */=0A+=0A+#ifndef _=
MDB_H_=0A+#define _MDB_H_=0A+=0A+#include <stdio.h>=0A+=0A+#include <mylist=
=2Eh>=0A =0A struct MdbRec {=0A     char name[16];=0A     char msg[24];=0A =
};=0A =0A-#endif=0A+int loadmdb(FILE *fp, struct List *dest);=0A+void freem=
db(struct List *list);=0A+=0A+#endif /* _MDB_H_ */=0A+=0A-- =0A2.34.1=0A=0A=
=0AFrom af5c8ebf61fc2d15148c940e57849615ab8a723d Mon Sep 17 00:00:00 2001=
=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Fri, 9 Dec 2022 23:46:19=
 -0500=0ASubject: [PATCH 02/10] I managed to get mdb-lookup-server working,=
 but it only=0A can handle one process for now.=0A=0A---=0A part1/Makefile =
           |  10 ++--=0A part1/mdb-lookup-server.c | 116 ++++++++++++++++++=
+++++++++++---------=0A 2 files changed, 94 insertions(+), 32 deletions(-)=
=0A=0Adiff --git a/part1/Makefile b/part1/Makefile=0Aindex 6f5a47e..3dc4b25=
 100644=0A--- a/part1/Makefile=0A+++ b/part1/Makefile=0A@@ -7,13 +7,15 @@ C=
FLAGS +=3D -I/home/j-hui/cs3157-pub/include=0A LDFLAGS =3D -L/home/j-hui/cs=
3157-pub/lib=0A LDLIBS =3D -lmylist=0A =0A+mdb-lookup-server: mdb-lookup-se=
rver.o mdb.o=0A+=0A+mdb.o: mdb.c mdb.h=0A+=0A+mdb-lookup-server.o: mdb-look=
up-server.c mdb.h=0A+=0A .PHONY: default=0A default: mdb-lookup-server=0A =
=0A-mdb-lookup-server: mdb-lookup-server.o mdb.o=0A-mdb-lookup-server.o: md=
b-lookup-server.c mdb.h=0A-mdb.o: mdb.h=0A-	=0A .PHONY: clean=0A clean:=0A =
	rm -f *.o a.out core mdb-lookup-server=0Adiff --git a/part1/mdb-lookup-ser=
ver.c b/part1/mdb-lookup-server.c=0Aindex 7072e1f..bb1a9fe 100644=0A--- a/p=
art1/mdb-lookup-server.c=0A+++ b/part1/mdb-lookup-server.c=0A@@ -29,7 +29,7=
 @@ int main(int argc, char **argv) {=0A     /*=0A      * Check and obtain =
command-line arguments=0A      */=0A-    if (argc !=3D 2) {=0A+    if (argc=
 !=3D 3) {=0A         fprintf(stderr, "Usage: %s <server-port> <database>\n=
", argv[0]);=0A         exit(1);=0A     }=0A@@ -37,6 +37,11 @@ int main(int=
 argc, char **argv) {=0A     char *server_port =3D argv[1];=0A     char *da=
tabase =3D argv[2];=0A =0A+    // Open the database file=0A+    FILE *fp =
=3D fopen(database, "rb");=0A+    if (fp =3D=3D NULL)=0A+        die(databa=
se);=0A+=0A     /*=0A      * Construct socket address information using get=
addrinfo().=0A      */=0A@@ -114,10 +119,18 @@ int main(int argc, char **ar=
gv) {=0A         /*=0A          * Handle client connection.=0A          */=
=0A+        =0A+       =0A+        /*=0A+        * Open client file descrip=
tor as FILE pointers.=0A+        */=0A+        FILE *clnt_r =3D fdopen(clnt=
_fd, "rb");=0A+        if (clnt_r =3D=3D NULL)=0A+            die("fdopen")=
;=0A =0A-        FILE *fp =3D fopen(database, "rb");=0A-        if (fp =3D=
=3D NULL)=0A-            die(database);=0A+        FILE *clnt_w =3D fdopen(=
dup(clnt_fd), "wb");=0A+        if (clnt_w =3D=3D NULL)=0A+            die(=
"fdopen");=0A =0A         /*=0A          * read all records into memory=0A@=
@ -130,45 +143,92 @@ int main(int argc, char **argv) {=0A         if (loade=
d < 0)=0A             die("loadmdb");=0A =0A-        if (fclose(fp) < 0)=0A=
-            perror("file");=0A+        fseek(fp, 0, SEEK_SET);   =0A      =
   =0A         /*=0A          * lookup loop=0A          */=0A-        =0A+ =
             =0A         char line[1024];=0A         char key[KeyMax + 1];=
=0A-=0A-       =0A-        // clear up the key!!=0A+         =0A+        wh=
ile(fgets(line, sizeof(line), clnt_r) !=3D NULL){=0A+  =0A+            /*=
=0A+             * clean up user input=0A+             */=0A+            =
=0A+            if(strlen(line) >=3D 2 && line[strlen(line)-2] =3D=3D '\r')=
{=0A+                line[strlen(line)-2] =3D '\n';=0A+                line=
[strlen(line)-1] =3D 0;=0A+            }=0A+=0A+            // must null-te=
rminate the string manually after strncpy().=0A+            strncpy(key, li=
ne, sizeof(key) - 1);=0A+            key[sizeof(key) - 1] =3D '\0';=0A+=0A+=
            // if newline is within the first KeyMax characters, remove it.=
=0A+            size_t last =3D strlen(key) - 1;=0A+            if (key[las=
t] =3D=3D '\n')=0A+                key[last] =3D '\0';=0A+=0A+            /=
/ user might have typed more than sizeof(line) - 1 characters in line;=0A+ =
           // continue fgets()ing until we encounter a newline.=0A+        =
    while (line[strlen(line) - 1] !=3D '\n' && fgets(line, sizeof(line), cl=
nt_r))=0A+                ;=0A+=0A+            /*=0A+             * search =
with key=0A+             */=0A+=0A+            // traverse the list, printi=
ng out the matching records=0A+            struct Node *node =3D list.head;=
=0A+            int recNo =3D 1;=0A+            while (node) {=0A+         =
       struct MdbRec *rec =3D (struct MdbRec *)node->data;=0A+=0A+         =
       if (strstr(rec->name, key) || strstr(rec->msg, key))=0A+            =
        fprintf(clnt_w, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg=
);=0A+=0A+                node =3D node->next;=0A+                recNo++;=
=0A+            }=0A+            =0A+            fflush(clnt_w);=0A        =
 =0A-        // open a file pointer=0A-        // make =0A+        }=0A+   =
    =0A+        // see if fgets() produced error CHECK THIS! SHOULD YOU DIE=
?=0A+        if (ferror(clnt_r))=0A+            perror("clnt_r");=0A =0A-  =
     /*=0A-        * search with key=0A-        */=0A+        /*=0A+       =
  * clean up and quit=0A+         */=0A =0A-        // traverse the list, p=
rinting out the matching records=0A-        struct Node *node =3D list.head=
;=0A-        int recNo =3D 1;=0A-        while (node) {=0A-            stru=
ct MdbRec *rec =3D (struct MdbRec *)node->data;=0A+        freemdb(&list);=
=0A =0A-            if (strstr(rec->name, key) || strstr(rec->msg, key))=0A=
-                fprintf(clnt_fd, "%4d: {%s} said {%s}\n", recNo, rec->name=
, rec->msg);=0A+       /*=0A+        * Done with client request; close the =
connection and log the transaction.=0A+        */=0A =0A-            node =
=3D node->next;=0A-            recNo++;=0A-        }=0A+        // Closing =
can FILE pointers can also produce errors, which we log.=0A+        if (fcl=
ose(clnt_w) < 0)=0A+            perror("clnt_w");=0A =0A-        // Close c=
lient connection.=0A-        close(clnt_fd);=0A+        if (fclose(clnt_r) =
< 0)=0A+            perror("clnt_r");=0A =0A         // Resume server loop =
to handle next client connection.=0A     }=0A-=0A+   =0A+   /*=0A+    * UNR=
EACHABLE=0A+    */=0A+    =0A+    if (fclose(fp) < 0)=0A+        perror("fi=
le");=0A+    =0A     close(serv_fd);=0A     return 0;=0A }=0A-- =0A2.34.1=
=0A=0A=0AFrom f9827408c9474f66f2efa62a5ac50dc3438824dd Mon Sep 17 00:00:00 =
2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 01:=
36:14 -0500=0ASubject: [PATCH 03/10] I did part 1.=0A=0A---=0A part1/mdb-lo=
okup-server.c | 262 ++++++++++++++++++++++++--------------=0A 1 file change=
d, 164 insertions(+), 98 deletions(-)=0A=0Adiff --git a/part1/mdb-lookup-se=
rver.c b/part1/mdb-lookup-server.c=0Aindex bb1a9fe..f523464 100644=0A--- a/=
part1/mdb-lookup-server.c=0A+++ b/part1/mdb-lookup-server.c=0A@@ -25,101 +2=
5,16 @@ static void die(const char *message)=0A     exit(1);=0A }=0A =0A-in=
t main(int argc, char **argv) {=0A-    /*=0A-     * Check and obtain comman=
d-line arguments=0A-     */=0A-    if (argc !=3D 3) {=0A-        fprintf(st=
derr, "Usage: %s <server-port> <database>\n", argv[0]);=0A-        exit(1);=
=0A-    }=0A-=0A-    char *server_port =3D argv[1];=0A-    char *database =
=3D argv[2];=0A-=0A-    // Open the database file=0A-    FILE *fp =3D fopen=
(database, "rb");=0A-    if (fp =3D=3D NULL)=0A-        die(database);=0A-=
=0A-    /*=0A-     * Construct socket address information using getaddrinfo=
().=0A-     */=0A-=0A-    // Define hints for getaddrinfo(), which we need =
to zero out first.=0A-    struct addrinfo hints;=0A-=0A-    memset(&hints, =
0, sizeof(hints));=0A-=0A-    hints.ai_family =3D AF_INET;        // Only a=
ccept IPv4 addresses=0A-    hints.ai_socktype =3D SOCK_STREAM;  // stream s=
ocket for TCP connections=0A-    hints.ai_protocol =3D IPPROTO_TCP;  // TCP=
 protocol=0A-    hints.ai_flags =3D AI_PASSIVE;      // Construct socket ad=
dress for bind()ing=0A-=0A-    // Define where getaddrinfo() will return th=
e information it found.=0A-    struct addrinfo *info;=0A-=0A-    // Call ge=
taddrinfo(), specifying the server IP address and port as strings.=0A-    /=
/ getaddrinfo() will parse those for us and point info to the result.=0A-  =
  int addr_err;=0A-    if ((addr_err =3D getaddrinfo(NULL, server_port, &hi=
nts, &info)) !=3D 0) {=0A-        fprintf(stderr, "getaddrinfo: %s\n", gai_=
strerror(addr_err));=0A-        exit(1);=0A-    }=0A-=0A-    // N.B. info a=
ctually points to a linked list of address information=0A-    // structures=
; assume that the first is sufficient and ignore the rest.=0A-=0A-    /*=0A=
-     * Create socket() and prepare it to accept() connections.=0A-     */=
=0A-=0A-    // Create socket() according to the address family, socket type=
, and=0A-    // protocol of the address info.  Since we specified AF_INET, =
SOCK_STREAM,=0A-    // and IPPROTO_TCP in the hints, this should be equival=
ent to just calling=0A-    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).=0A=
-    int serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_pr=
otocol);=0A-    if (serv_fd < 0)=0A-        die("socket");=0A-=0A-    // bi=
nd() socket to a port on the server; the port in info->ai_addr should=0A-  =
  // be the same port that getaddrinfo() parsed from server_port.=0A-    if=
 (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A-        die("bind"=
);=0A-=0A-    // BTW: we're done with the info retrieved by getaddrinfo(), =
so free it.=0A-    freeaddrinfo(info);=0A-=0A-    // Start listen()ing for =
connections on this socket, maintaining a queue of=0A-    // at most 8 pend=
ing connections.=0A-    if (listen(serv_fd, 8) < 0)=0A-        die("listen"=
);=0A-=0A-    for (;;) {=0A-=0A-        /*=0A-         * accept() connectio=
n from client.=0A-         */=0A-=0A-        // Define space to receive cli=
ent address info.=0A-        struct sockaddr_in clnt_addr;=0A-        sockl=
en_t clnt_addr_len =3D sizeof(clnt_addr);=0A-=0A-        // accept() blocks=
 until a client connects with the server, and returns=0A-        // a NEW s=
ocket file descriptor for interacting with the client.=0A-        int clnt_=
fd =3D accept(serv_fd, (struct sockaddr *) &clnt_addr,=0A-                 =
            &clnt_addr_len);=0A-        if (clnt_fd < 0)=0A-            die=
("accept");=0A-=0A-        // clnt_addr is now populated with information a=
bout the client.=0A-        fprintf(stderr, "Accepted connection from %s\n"=
,=0A-                inet_ntoa(clnt_addr.sin_addr));=0A+static void handle_=
client(char *database, int clnt_fd){=0A =0A         /*=0A          * Handle=
 client connection.=0A          */=0A-        =0A+=0A+        // Open the d=
atabase file=0A+        FILE *fp =3D fopen(database, "rb");=0A+        if (=
fp =3D=3D NULL)=0A+            die(database);=0A        =0A         /*=0A  =
       * Open client file descriptor as FILE pointers.=0A@@ -141,9 +56,10 @=
@ int main(int argc, char **argv) {=0A =0A         int loaded =3D loadmdb(f=
p, &list);=0A         if (loaded < 0)=0A-            die("loadmdb");=0A-=0A=
-        fseek(fp, 0, SEEK_SET);   =0A+            die("loadmdb");   =0A+  =
 =0A+        if (fclose(fp) < 0)=0A+            perror("file");=0A         =
=0A         /*=0A          * lookup loop=0A@@ -192,8 +108,11 @@ int main(in=
t argc, char **argv) {=0A =0A                 node =3D node->next;=0A      =
           recNo++;=0A+                fflush(clnt_w);=0A             }=0A =
            =0A+            fprintf(clnt_w, "\n");=0A+=0A             fflus=
h(clnt_w);=0A         =0A         }=0A@@ -205,7 +124,7 @@ int main(int argc=
, char **argv) {=0A         /*=0A          * clean up and quit=0A          =
*/=0A-=0A+ =0A         freemdb(&list);=0A =0A        /*=0A@@ -220,15 +139,1=
62 @@ int main(int argc, char **argv) {=0A             perror("clnt_r");=0A=
 =0A         // Resume server loop to handle next client connection.=0A+}=
=0A+=0A+static void sigchld_handler(int sig)=0A+{=0A+    // Keep reaping de=
ad children until there aren't any to reap.=0A+    while (waitpid(-1, NULL,=
 WNOHANG) > 0)=0A+        ;=0A+}=0A+=0A+=0A+int main(int argc, char **argv)=
 {=0A+=0A+    /*=0A+     * Configure signal-handling.=0A+     */=0A+=0A+   =
 struct sigaction sa;=0A+    memset(&sa, 0, sizeof(sa));=0A+=0A+    // Igno=
re SIGPIPE so that we don't terminate when we call=0A+    // send() on a di=
sconnected socket.=0A+    sigemptyset(&sa.sa_mask);=0A+    sa.sa_flags =3D =
0;=0A+    sa.sa_handler =3D SIG_IGN;=0A+    if (sigaction(SIGPIPE, &sa, NUL=
L))=0A+        die("sigaction(SIGPIPE)");=0A+=0A+    // Install a handler f=
or the SIGCHLD signal so that we can reap children=0A+    // who have finis=
hed processing their requests.=0A+    sigemptyset(&sa.sa_mask);=0A+    sa.s=
a_flags =3D SA_RESTART | SA_NOCLDSTOP;=0A+    sa.sa_handler =3D &sigchld_ha=
ndler;=0A+    if (sigaction(SIGCHLD, &sa, NULL))=0A+        die("sigaction(=
SIGCHLD)");=0A+=0A+    /*=0A+     * Check and obtain command-line arguments=
=0A+     */=0A+    if (argc !=3D 3) {=0A+        fprintf(stderr, "Usage: %s=
 <server-port> <database>\n", argv[0]);=0A+        exit(1);=0A+    }=0A+=0A=
+    char *server_port =3D argv[1];=0A+    char *database =3D argv[2];=0A+=
=0A+    /*=0A+     * Construct socket address information using getaddrinfo=
().=0A+     */=0A+=0A+    // Define hints for getaddrinfo(), which we need =
to zero out first.=0A+    struct addrinfo hints;=0A+=0A+    memset(&hints, =
0, sizeof(hints));=0A+=0A+    hints.ai_family =3D AF_INET;        // Only a=
ccept IPv4 addresses=0A+    hints.ai_socktype =3D SOCK_STREAM;  // stream s=
ocket for TCP connections=0A+    hints.ai_protocol =3D IPPROTO_TCP;  // TCP=
 protocol=0A+    hints.ai_flags =3D AI_PASSIVE;      // Construct socket ad=
dress for bind()ing=0A+=0A+    // Define where getaddrinfo() will return th=
e information it found.=0A+    struct addrinfo *info;=0A+=0A+    // Call ge=
taddrinfo(), specifying the server IP address and port as strings.=0A+    /=
/ getaddrinfo() will parse those for us and point info to the result.=0A+  =
  int addr_err;=0A+    if ((addr_err =3D getaddrinfo(NULL, server_port, &hi=
nts, &info)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\n", gai_=
strerror(addr_err));=0A+        exit(1);=0A+    }=0A+=0A+    // N.B. info a=
ctually points to a linked list of address information=0A+    // structures=
; assume that the first is sufficient and ignore the rest.=0A+=0A+    /*=0A=
+     * Create socket() and prepare it to accept() connections.=0A+     */=
=0A+=0A+    // Create socket() according to the address family, socket type=
, and=0A+    // protocol of the address info.  Since we specified AF_INET, =
SOCK_STREAM,=0A+    // and IPPROTO_TCP in the hints, this should be equival=
ent to just calling=0A+    // socket(AF_INET, SOCK_STREAM, IPPROTO_TCP).=0A=
+    int serv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_pr=
otocol);=0A+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    // bi=
nd() socket to a port on the server; the port in info->ai_addr should=0A+  =
  // be the same port that getaddrinfo() parsed from server_port.=0A+    if=
 (bind(serv_fd, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind"=
);=0A+=0A+    // BTW: we're done with the info retrieved by getaddrinfo(), =
so free it.=0A+    freeaddrinfo(info);=0A+=0A+    // Start listen()ing for =
connections on this socket, maintaining a queue of=0A+    // at most 8 pend=
ing connections.=0A+    if (listen(serv_fd, 8) < 0)=0A+        die("listen"=
);=0A+=0A+    for (;;) {=0A+=0A+        /*=0A+         * accept() connectio=
n from client.=0A+         */=0A+=0A+        // Define space to receive cli=
ent address info.=0A+        struct sockaddr_in clnt_addr;=0A+        sockl=
en_t clnt_addr_len =3D sizeof(clnt_addr);=0A+=0A+        // accept() blocks=
 until a client connects with the server, and returns=0A+        // a NEW s=
ocket file descriptor for interacting with the client.=0A+        int clnt_=
fd =3D accept(serv_fd, (struct sockaddr *) &clnt_addr,=0A+                 =
            &clnt_addr_len);=0A+        if (clnt_fd < 0)=0A+            die=
("accept");=0A+        =0A+        pid_t pid =3D fork();=0A+        if (pid=
 < 0)=0A+            die("fork");=0A+=0A+        if (pid > 0) {=0A+        =
    /*=0A+             * Parent process:=0A+             *=0A+             =
* Close client socket and continue accept()ing connections.=0A+            =
 */=0A+=0A+            close(clnt_fd);=0A+=0A+            continue;=0A+    =
    }=0A+=0A+        /*=0A+         * Child process:=0A+         *=0A+     =
    * Close server socket, handle the client, and exit.=0A+         */=0A+=
=0A+        close(serv_fd);=0A+=0A+        // clnt_addr is populated with i=
nformation about the client.=0A+        fprintf(stderr, "Connection started=
: %s\n",=0A+                inet_ntoa(clnt_addr.sin_addr));=0A+=0A+        =
handle_client(database, clnt_fd);=0A+=0A+        fprintf(stderr, "Connectio=
n terminated: %s\n",=0A+                inet_ntoa(clnt_addr.sin_addr));=0A+=
       =0A+        exit(0);=0A     }=0A    =0A    /*=0A     * UNREACHABLE=
=0A     */=0A     =0A-    if (fclose(fp) < 0)=0A-        perror("file");=0A=
-    =0A     close(serv_fd);=0A     return 0;=0A }=0A-- =0A2.34.1=0A=0A=0AF=
rom 9acec0aafb2a5401645ae224ffee41c01f95de52 Mon Sep 17 00:00:00 2001=0AFro=
m: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 Dec 2022 02:56:44 -050=
0=0ASubject: [PATCH 04/10] Added the skeletal code for part2.=0A=0A---=0A R=
EADME.txt          |   8 +-=0A part2/Makefile      |  14 ++=0A part2/http-s=
erver.c | 452 ++++++++++++++++++++++++++++++++++++++++++++=0A 3 files chang=
ed, 470 insertions(+), 4 deletions(-)=0A create mode 100644 part2/Makefile=
=0A create mode 100644 part2/http-server.c=0A=0Adiff --git a/README.txt b/R=
EADME.txt=0Aindex 49c4472..08c20e8 100644=0A--- a/README.txt=0A+++ b/README=
=2Etxt=0A@@ -1,9 +1,9 @@=0A This file should contain:=0A =0A-  - your name=
=0A-  - your UNI=0A-  - lab assignment number=0A-  - description for each p=
art=0A+  - Arman Ozcan=0A+  - ao2794=0A+  - lab 7=0A+  - My programs should=
 work as they are supposed to.=0A =0A The description should indicate wheth=
er your solution for the part is=0A working or not.  You may also want to i=
nclude anything else you would=0Adiff --git a/part2/Makefile b/part2/Makefi=
le=0Anew file mode 100644=0Aindex 0000000..6646a20=0A--- /dev/null=0A+++ b/=
part2/Makefile=0A@@ -0,0 +1,14 @@=0A+CC =3D gcc=0A+CFLAGS =3D -g -Wall -Wpe=
dantic -std=3Dc17=0A+LDFLAGS =3D=0A+LDLIBS =3D=0A+=0A+http-server:=0A+http-=
server.o:=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core http-serv=
er=0A+=0A+.PHONY: all=0A+all: clean http-server=0Adiff --git a/part2/http-s=
erver.c b/part2/http-server.c=0Anew file mode 100644=0Aindex 0000000..998e3=
93=0A--- /dev/null=0A+++ b/part2/http-server.c=0A@@ -0,0 +1,452 @@=0A+#defi=
ne _GNU_SOURCE=0A+#include <arpa/inet.h>=0A+#include <linux/limits.h>=0A+#i=
nclude <netdb.h>=0A+#include <signal.h>=0A+#include <stdio.h>=0A+#include <=
stdlib.h>=0A+#include <string.h>=0A+#include <sys/socket.h>=0A+#include <sy=
s/stat.h>=0A+#include <time.h>=0A+#include <unistd.h>=0A+=0A+#define MAXPEN=
DING 5          // Maximum outstanding connection requests=0A+#define MAX_L=
INE_LENGTH 1024  // Maximum line length for request and headers=0A+#define =
DISK_IO_BUF_SIZE 4096 // Size of buffer for reading and sending files=0A+=
=0A+static void die(const char *message)=0A+{=0A+    perror(message);=0A+  =
  exit(1);=0A+}=0A+=0A+/*=0A+ * HTTP/1.0 status codes and the corresponding=
 reason phrases.=0A+ */=0A+static struct {=0A+    int status;=0A+    char *=
reason;=0A+} http_status_codes[] =3D {=0A+    { 200, "OK" },=0A+    { 201, =
"Created" },=0A+    { 202, "Accepted" },=0A+    { 204, "No Content" },=0A+ =
   { 301, "Moved Permanently" },=0A+    { 302, "Moved Temporarily" },=0A+  =
  { 304, "Not Modified" },=0A+    { 400, "Bad Request" },=0A+    { 401, "Un=
authorized" },=0A+    { 403, "Forbidden" },=0A+    { 404, "Not Found" },=0A=
+    { 500, "Internal Server Error" },=0A+    { 501, "Not Implemented" },=
=0A+    { 502, "Bad Gateway" },=0A+    { 503, "Service Unavailable" },=0A+ =
   { 0, NULL } // marks the end of the list=0A+};=0A+=0A+static inline cons=
t char *get_reason_phrase(int status_code)=0A+{=0A+    int i =3D -1;=0A+   =
 while (http_status_codes[++i].status > 0)=0A+        if (http_status_codes=
[i].status =3D=3D status_code)=0A+            return http_status_codes[i].r=
eason;=0A+    return "Unknown Status Code";=0A+}=0A+=0A+/*=0A+ * Send HTTP =
status line.=0A+ *=0A+ * Returns negative if send() failed.=0A+ */=0A+stati=
c int send_status_line(FILE *fp, int status_code)=0A+{=0A+    const char *r=
eason_phrase =3D get_reason_phrase(status_code);=0A+    return fprintf(fp, =
"HTTP/1.0 %d %s\r\n", status_code, reason_phrase);=0A+}=0A+=0A+/*=0A+ * Sen=
d blank line.=0A+ *=0A+ * Returns number of bytes sent; returns negative if=
 failed.=0A+ */=0A+static int send_blank_line(FILE *fp)=0A+{=0A+    return =
fprintf(fp, "\r\n");=0A+}=0A+=0A+/*=0A+ * Send a generic HTTP response for =
error statuses (400+).=0A+ *=0A+ * Returns negative if failed.=0A+ */=0A+st=
atic int send_error_status(FILE *fp, int status_code)=0A+{=0A+    if (send_=
status_line(fp, status_code) < 0)=0A+        return -1;=0A+=0A+    // no he=
aders needed=0A+    if (send_blank_line(fp) < 0)=0A+        return -1;=0A+=
=0A+    return fprintf(fp,=0A+        "<html><body>\n"=0A+        "<h1>%d %=
s</h1>\n"=0A+        "</body></html>\n",=0A+        status_code, get_reason=
_phrase(status_code));=0A+}=0A+=0A+/*=0A+ * Send 301 status: redirect the b=
rowser to request_uri with '/' appended to it.=0A+ *=0A+ * Returns negative=
 if failed.=0A+ */=0A+static int send301(const char *request_uri, FILE *fp)=
=0A+{=0A+    if (send_status_line(fp, 301) < 0)=0A+        return -1;=0A+=
=0A+    // Send Location header and format redirection link in HTML in case=
 browser=0A+    // doesn't automatically redirect.=0A+    return fprintf(fp=
,=0A+        "Location: %s/\r\n"=0A+        "\r\n"=0A+        "<html><body>=
\n"=0A+        "<h1>301 Moved Permanently</h1>\n"=0A+        "<p>The docume=
nt has moved "=0A+        "<a href=3D\"%s/\">here</a>.</p>\n"=0A+        "<=
/body></html>\n",=0A+        request_uri, request_uri);=0A+}=0A+=0A+/*=0A+ =
* Handle static file requests.=0A+ * Returns the HTTP status code that was =
sent to the browser.=0A+ *=0A+ * If send() ever fails (i.e., could not writ=
e to clnt_w), report the error and=0A+ * move on.=0A+ */=0A+static int hand=
le_file_request(const char *web_root, const char *request_uri, FILE *clnt_w=
)=0A+{=0A+    /*=0A+     * Define variables that we will need to use before=
 we return.=0A+     */=0A+=0A+    int status_code; // We'll return this val=
ue.=0A+    FILE *fp =3D NULL; // We'll fclose() this at the end.=0A+=0A+   =
 // Set clnt_w to line-buffering so that lines are flushed immediately.=0A+=
    setlinebuf(clnt_w);=0A+=0A+    /*=0A+     * Construct the path of the r=
equested file from web_root and request_uri.=0A+     */=0A+=0A+    char fil=
e_path[PATH_MAX];=0A+=0A+    if (strlen(web_root) + strlen(request_uri) + 1=
2 > sizeof(file_path)) {=0A+        // File paths can't exceed sizeof(file_=
path) on Linux, so just 404.=0A+        status_code =3D 404; // "Not Found"=
=0A+        if (send_error_status(clnt_w, status_code) < 0)=0A+            =
perror("send");=0A+        goto cleanup;=0A+    }=0A+=0A+    strcpy(file_pa=
th, web_root);=0A+=0A+    // Note: since the URI definitely begins with '/'=
, we don't need to worry=0A+    // about appending '/' to web_root.=0A+=0A+=
    strcat(file_path, request_uri);=0A+=0A+    // If request_uri ends with =
'/', append "index.html".=0A+    if (file_path[strlen(file_path) - 1] =3D=
=3D '/')=0A+        strcat(file_path, "index.html");=0A+=0A+    /*=0A+     =
* Open the requested file.=0A+     */=0A+=0A+    // See if the requested fi=
le is a directory.=0A+    struct stat st;=0A+    if (stat(file_path, &st) =
=3D=3D 0 && S_ISDIR(st.st_mode)) {=0A+        status_code =3D 301; // "Move=
d Permanently"=0A+        if (send301(request_uri, clnt_w) < 0)=0A+        =
    perror("send");=0A+        goto cleanup;=0A+    }=0A+=0A+    // If unab=
le to open the file, send "404 Not Found".=0A+    fp =3D fopen(file_path, "=
rb");=0A+    if (fp =3D=3D NULL) {=0A+        status_code =3D 404; // "Not =
Found"=0A+        if (send_error_status(clnt_w, status_code) < 0)=0A+      =
      perror("send");=0A+        goto cleanup;=0A+    }=0A+=0A+    // Other=
wise, send "200 OK".=0A+    status_code =3D 200; // "OK"=0A+    if (send_st=
atus_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {=0A+   =
     perror("send");=0A+        goto cleanup;=0A+    }=0A+=0A+    /*=0A+   =
  * Send the file.=0A+     */=0A+=0A+    // Buffer for file contents.=0A+  =
  char file_buf[DISK_IO_BUF_SIZE];=0A+=0A+    // Turn off buffering for cln=
t_w because we already have our own file_buf.=0A+    if (fflush(clnt_w) < 0=
) {=0A+        perror("send");=0A+        goto cleanup;=0A+    }=0A+    set=
buf(clnt_w, NULL);=0A+=0A+    // Read and send file in a block at a time.=
=0A+    size_t n;=0A+    while ((n =3D fread(file_buf, 1, sizeof(file_buf),=
 fp)) > 0) {=0A+        if (fwrite(file_buf, 1, n, clnt_w) !=3D n) {=0A+   =
         perror("send");=0A+            goto cleanup;=0A+        }=0A+    }=
=0A+=0A+    // fread() returns 0 both on EOF and on error; check if there w=
as an error.=0A+    if (ferror(fp))=0A+        // Note that if we had an er=
ror, we sent the client a truncated (i.e.,=0A+        // corrupted) file; n=
ot much we can do about that at this point since=0A+        // we already s=
ent the status...=0A+        perror("fread");=0A+=0A+cleanup:=0A+=0A+    /*=
=0A+     * close() the FILE pointer and return.=0A+     */=0A+=0A+    if (f=
p)=0A+        fclose(fp);=0A+=0A+    return status_code;=0A+}=0A+=0A+void h=
andle_client(const char *web_root, int clnt_fd, const char *clnt_ip)=0A+{=
=0A+    /*=0A+     * Open client file descriptor as FILE pointers.=0A+     =
*/=0A+    FILE *clnt_r =3D fdopen(clnt_fd, "rb");=0A+    if (clnt_r =3D=3D =
NULL)=0A+        die("fdopen");=0A+=0A+    FILE *clnt_w =3D fdopen(dup(clnt=
_fd), "wb");=0A+    if (clnt_w =3D=3D NULL)=0A+        die("fdopen");=0A+=
=0A+    /*=0A+     * Let's parse the request line.=0A+     */=0A+=0A+    //=
 Note: we'll use these fields at the end when we log the connection.=0A+   =
 int status_code;=0A+    char *method =3D NULL, *request_uri =3D NULL, *htt=
p_version =3D NULL, *extra;=0A+=0A+    char request_buf[MAX_LINE_LENGTH];=
=0A+=0A+    if (fgets(request_buf, sizeof(request_buf), clnt_r) =3D=3D NULL=
) {=0A+        // Socket closed prematurely; there isn't much we can do=0A+=
        status_code =3D 400; // "Bad Request"=0A+        goto terminate_con=
nection;=0A+    }=0A+=0A+    char *token_separators =3D "\t \r\n"; // tab, =
space, new line=0A+=0A+    method =3D strtok(request_buf, token_separators)=
;=0A+    request_uri =3D strtok(NULL, token_separators);=0A+    http_versio=
n =3D strtok(NULL, token_separators);=0A+    extra =3D strtok(NULL, token_s=
eparators);=0A+=0A+    // Note: We must not modify request_buf past this po=
int, because method,=0A+    // request_uri, http_version, and extra point t=
o within request_buf.=0A+=0A+    // Check that we have exactly three tokens=
 in the request line.=0A+    if (!method || !request_uri || !http_version |=
| extra) {=0A+        status_code =3D 501; // "Not Implemented"=0A+        =
send_error_status(clnt_w, status_code);=0A+        goto terminate_connectio=
n;=0A+    }=0A+=0A+    // We only support GET requests.=0A+    if (strcmp(m=
ethod, "GET")) {=0A+        status_code =3D 501; // "Not Implemented"=0A+  =
      send_error_status(clnt_w, status_code);=0A+        goto terminate_con=
nection;=0A+    }=0A+=0A+    // We only support HTTP/1.0 and HTTP/1.1.=0A+ =
   if (strcmp(http_version, "HTTP/1.0") && strcmp(http_version, "HTTP/1.1")=
) {=0A+        status_code =3D 501; // "Not Implemented"=0A+        send_er=
ror_status(clnt_w, status_code);=0A+        goto terminate_connection;=0A+ =
   }=0A+=0A+    // request_uri must begin with "/".=0A+    if (!request_uri=
 || *request_uri !=3D '/') {=0A+        status_code =3D 400; // "Bad Reques=
t"=0A+        send_error_status(clnt_w, status_code);=0A+        goto termi=
nate_connection;=0A+    }=0A+=0A+    // Ensure request_uri does not contain=
 "/../" and does not end with "/..".=0A+    int uri_len =3D strlen(request_=
uri);=0A+    if (uri_len >=3D 3) {=0A+        char *tail =3D request_uri + =
(uri_len - 3);=0A+        if (strcmp(tail, "/..") =3D=3D 0 || strstr(reques=
t_uri, "/../") !=3D NULL) {=0A+            status_code =3D 400; // "Bad Req=
uest"=0A+            send_error_status(clnt_w, status_code);=0A+           =
 goto terminate_connection;=0A+        }=0A+    }=0A+=0A+    /*=0A+     * S=
kip HTTP headers.=0A+     */=0A+=0A+    // We need another buffer for trash=
ing the headers, because request_buf=0A+    // still currently holds the me=
thod, request_uri, and http_version strings.=0A+    char line_buf[MAX_LINE_=
LENGTH];=0A+=0A+    while (1) {=0A+        if (fgets(line_buf, sizeof(line_=
buf), clnt_r) =3D=3D NULL) {=0A+            // Socket closed prematurely; t=
here isn't much we can do=0A+            status_code =3D 400; // "Bad Reque=
st"=0A+            goto terminate_connection;=0A+        }=0A+=0A+        /=
/ Check if we have reached the end of the headers, i.e., an empty line.=0A+=
        if (strcmp("\r\n", line_buf) =3D=3D 0 || strcmp("\n", line_buf) =3D=
=3D 0)=0A+            break;=0A+    }=0A+=0A+    /*=0A+     * We have a wel=
l-formed HTTP GET request; time to handle it.=0A+     */=0A+=0A+    status_=
code =3D handle_file_request(web_root, request_uri, clnt_w);=0A+=0A+termina=
te_connection:=0A+=0A+    /*=0A+     * Done with client request; close the =
connection and log the transaction.=0A+     */=0A+=0A+    // Closing can FI=
LE pointers can also produce errors, which we log.=0A+    if (fclose(clnt_w=
) < 0)=0A+        perror("send");=0A+=0A+    if (fclose(clnt_r) < 0)=0A+   =
     perror("recv");=0A+=0A+    fprintf(stderr, "%s \"%s %s %s\" %d %s\n",=
=0A+        clnt_ip,=0A+        method,=0A+        request_uri,=0A+        =
http_version,=0A+        status_code,=0A+        get_reason_phrase(status_c=
ode));=0A+}=0A+=0A+int main(int argc, char *argv[])=0A+{=0A+    /*=0A+     =
* Configure signal-handling.=0A+     */=0A+=0A+    struct sigaction sa;=0A+=
    memset(&sa, 0, sizeof(sa));=0A+=0A+    // Ignore SIGPIPE so that we don=
't terminate when we call=0A+    // send() on a disconnected socket.=0A+   =
 sigemptyset(&sa.sa_mask);=0A+    sa.sa_flags =3D 0;=0A+    sa.sa_handler =
=3D SIG_IGN;=0A+    if (sigaction(SIGPIPE, &sa, NULL))=0A+        die("siga=
ction(SIGPIPE)");=0A+=0A+    /*=0A+     * Parse arguments.=0A+     */=0A+=
=0A+    if (argc !=3D 3) {=0A+        fprintf(stderr, "usage: %s <server-po=
rt> <web-root>\n", argv[0]);=0A+        exit(1);=0A+    }=0A+=0A+    char *=
serv_port =3D argv[1];=0A+    char *web_root =3D argv[2];=0A+=0A+    /*=0A+=
     * Construct server socket to listen on serv_port.=0A+     */=0A+=0A+  =
  struct addrinfo hints, *info;=0A+=0A+    memset(&hints, 0, sizeof(hints))=
;=0A+    hints.ai_family =3D AF_INET;       // Only accept IPv4 addresses=
=0A+    hints.ai_socktype =3D SOCK_STREAM; // stream socket for TCP connect=
ions=0A+    hints.ai_protocol =3D IPPROTO_TCP; // TCP protocol=0A+    hints=
=2Eai_flags =3D AI_PASSIVE;     // Construct socket address for bind()ing=
=0A+=0A+    int addr_err;=0A+    if ((addr_err =3D getaddrinfo(NULL, serv_p=
ort, &hints, &info)) !=3D 0) {=0A+        fprintf(stderr, "getaddrinfo: %s\=
n", gai_strerror(addr_err));=0A+        exit(1);=0A+    }=0A+=0A+    int se=
rv_fd =3D socket(info->ai_family, info->ai_socktype, info->ai_protocol);=0A=
+    if (serv_fd < 0)=0A+        die("socket");=0A+=0A+    if (bind(serv_fd=
, info->ai_addr, info->ai_addrlen) < 0)=0A+        die("bind");=0A+=0A+    =
if (listen(serv_fd, 8) < 0)=0A+        die("listen");=0A+=0A+    freeaddrin=
fo(info);=0A+=0A+    /*=0A+     * Server accept() loop.=0A+     */=0A+=0A+ =
   for (;;) {=0A+        // We only need sockaddr_in since we only accept I=
Pv4 peers.=0A+        struct sockaddr_in clnt_addr;=0A+        socklen_t cl=
nt_len =3D sizeof(clnt_addr);=0A+=0A+        int clnt_fd =3D accept(serv_fd=
, (struct sockaddr *)&clnt_addr, &clnt_len);=0A+        if (clnt_fd < 0)=0A=
+            die("accept");=0A+=0A+        char clnt_ip[INET_ADDRSTRLEN];=
=0A+=0A+        if (inet_ntop(AF_INET, &clnt_addr.sin_addr, clnt_ip, sizeof=
(clnt_ip))=0A+            =3D=3D NULL)=0A+            die("inet_ntop");=0A+=
=0A+        handle_client(web_root, clnt_fd, clnt_ip);=0A+    }=0A+=0A+    =
/*=0A+     * UNREACHABLE=0A+     */=0A+=0A+    close(serv_fd);=0A+=0A+    r=
eturn 0;=0A+}=0A-- =0A2.34.1=0A=0A=0AFrom de8e9262d9f21956eb524d448b8ee747d=
84ba0a7 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=
=0ADate: Sat, 10 Dec 2022 17:41:04 -0500=0ASubject: [PATCH 05/10] Now, part=
2 works partially. When mdb-lookup is called,=0A it always prints the defau=
lt page.=0A=0A---=0A part2/http-server.c | 99 +++++++++++++++++++++++++++++=
+++++++++++++---=0A 1 file changed, 93 insertions(+), 6 deletions(-)=0A=0Ad=
iff --git a/part2/http-server.c b/part2/http-server.c=0Aindex 998e393..8748=
882 100644=0A--- a/part2/http-server.c=0A+++ b/part2/http-server.c=0A@@ -12=
7,7 +127,21 @@ static int send301(const char *request_uri, FILE *fp)=0A  * =
If send() ever fails (i.e., could not write to clnt_w), report the error an=
d=0A  * move on.=0A  */=0A-static int handle_file_request(const char *web_r=
oot, const char *request_uri, FILE *clnt_w)=0A+=0A+static void handle_looku=
p(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){=0A+    cons=
t char *form =3D=0A+          "<h1>mdb-lookup</h1>\n"=0A+          "<p>\n"=
=0A+          "<form method=3DGET action=3D/mdb-lookup>\n"=0A+          "lo=
okup: <input type=3Dtext name=3Dkey>\n"=0A+          "<input type=3Dsubmit>=
\n"=0A+          "</form>\n"=0A+          "<p>\n";=0A+=0A+    fprintf(clnt_=
w, "<html><body>\n%s</body></html>\n", form);=0A+}=0A+=0A+static int handle=
_file_request(const char *web_root, const char *request_uri, FILE *clnt_w, =
FILE *mdb_r, FILE *mdb_w)=0A {=0A     /*=0A      * Define variables that we=
 will need to use before we return.=0A@@ -138,6 +152,21 @@ static int handl=
e_file_request(const char *web_root, const char *request_uri, FI=0A =0A    =
 // Set clnt_w to line-buffering so that lines are flushed immediately.=0A =
    setlinebuf(clnt_w);=0A+    =0A+    // enter if uri is /mdb-lookup or it=
 starts with /mdb-lookup?=0A+    if(!strcmp(request_uri, "/mdb-lookup") || =
!strncmp(request_uri, "/mdb-lookup?", 12)){=0A+     =0A+        status_code=
 =3D 200; // "OK"=0A+        if (send_status_line(clnt_w, status_code) < 0 =
|| send_blank_line(clnt_w) < 0) {=0A+            perror("send");=0A+       =
     goto cleanup;=0A+        }=0A+=0A+        // return the result=0A+    =
    handle_lookup(request_uri + 11, clnt_w, mdb_r, mdb_w);        =0A+     =
   goto cleanup;=0A+    }=0A+=0A =0A     /*=0A      * Construct the path of=
 the requested file from web_root and request_uri.=0A@@ -235,7 +264,7 @@ cl=
eanup:=0A     return status_code;=0A }=0A =0A-void handle_client(const char=
 *web_root, int clnt_fd, const char *clnt_ip)=0A+void handle_client(const c=
har *web_root, int clnt_fd, const char *clnt_ip, FILE *mdb_r, FILE *mdb_w)=
=0A {=0A     /*=0A      * Open client file descriptor as FILE pointers.=0A@=
@ -337,7 +366,7 @@ void handle_client(const char *web_root, int clnt_fd, co=
nst char *clnt_ip)=0A      * We have a well-formed HTTP GET request; time t=
o handle it.=0A      */=0A =0A-    status_code =3D handle_file_request(web_=
root, request_uri, clnt_w);=0A+    status_code =3D handle_file_request(web_=
root, request_uri, clnt_w, mdb_r, mdb_w);=0A =0A terminate_connection:=0A =
=0A@@ -382,13 +411,15 @@ int main(int argc, char *argv[])=0A      * Parse a=
rguments.=0A      */=0A =0A-    if (argc !=3D 3) {=0A-        fprintf(stder=
r, "usage: %s <server-port> <web-root>\n", argv[0]);=0A+    if (argc !=3D 5=
) {=0A+        fprintf(stderr, "usage: %s <server-port> <web-root> <mdb-hos=
t> <mdb-port>\n", argv[0]);=0A         exit(1);=0A     }=0A =0A     char *s=
erv_port =3D argv[1];=0A     char *web_root =3D argv[2];=0A+    char *mdb_h=
ost =3D argv[3];=0A+    char *mdb_port =3D argv[4];=0A =0A     /*=0A      *=
 Construct server socket to listen on serv_port.=0A@@ -420,6 +451,60 @@ int=
 main(int argc, char *argv[])=0A =0A     freeaddrinfo(info);=0A =0A+    /*=
=0A+     * Construct client socket to connect to mdb-lookup-server.=0A+    =
 */=0A+=0A+    // Zero out hints first.=0A+    memset(&hints, 0, sizeof(hin=
ts));=0A+=0A+    // Specify what kind of connection we intend to make; thes=
e values tell=0A+    // getaddrinfo() that we don't care about other kinds =
of addresses.=0A+    hints.ai_family =3D AF_INET;        // Only accept IPv=
4 addresses=0A+    hints.ai_socktype =3D SOCK_STREAM;  // stream socket for=
 TCP connections=0A+    hints.ai_protocol =3D IPPROTO_TCP;  // TCP protocol=
=0A+=0A+    // Define where getaddrinfo() will return the information it fo=
und.=0A+    struct addrinfo *info_mdb;=0A+=0A+    // Call getaddrinfo(), sp=
ecifying the server IP address and port as strings.=0A+    // getaddrinfo()=
 will parse those for us and point info to the result.=0A+    if ((addr_err=
 =3D getaddrinfo(mdb_host, mdb_port, &hints, &info_mdb)) !=3D 0) {=0A+     =
   fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(addr_err));=0A+       =
 exit(1);=0A+    }=0A+=0A+    /*=0A+     * Create socket() and connect() it=
 to server.=0A+     */=0A+=0A+    // Create socket() according to the addre=
ss family, socket type, and=0A+    // protocol of the address info.  Since =
we specified AF_INET, SOCK_STREAM,=0A+    // and IPPROTO_TCP in the hints, =
this should be equivalent to just calling=0A+    // socket(AF_INET, SOCK_ST=
REAM, IPPROTO_TCP).=0A+    int mdb_fd =3D socket(info_mdb->ai_family, info_=
mdb->ai_socktype, info_mdb->ai_protocol);=0A+    if (mdb_fd < 0)=0A+       =
 die("socket");=0A+=0A+    // Connect socket with server address; the IP ad=
dress and port in=0A+    // info->ai_addr should be the same address and po=
rt that getaddrinfo()=0A+    // parsed from server_address and server_port.=
=0A+    if (connect(mdb_fd, info_mdb->ai_addr, info_mdb->ai_addrlen) < 0)=
=0A+        die("connect");=0A+=0A+    // BTW: we're done with the info ret=
rieved by getaddrinfo(), so free it.=0A+    freeaddrinfo(info_mdb);=0A+=0A+=
    /*=0A+     * Open mdb-lookup-server file descriptor as FILE pointers.=
=0A+     */=0A+    FILE *mdb_r =3D fdopen(mdb_fd, "rb");=0A+    if (mdb_r =
=3D=3D NULL)=0A+        die("fdopen");=0A+=0A+    FILE *mdb_w =3D fdopen(du=
p(mdb_fd), "wb");=0A+    if (mdb_w =3D=3D NULL)=0A+        die("fdopen");=
=0A     /*=0A      * Server accept() loop.=0A      */=0A@@ -439,13 +524,15 =
@@ int main(int argc, char *argv[])=0A             =3D=3D NULL)=0A         =
    die("inet_ntop");=0A =0A-        handle_client(web_root, clnt_fd, clnt_=
ip);=0A+        handle_client(web_root, clnt_fd, clnt_ip, mdb_r, mdb_w);=0A=
     }=0A =0A     /*=0A      * UNREACHABLE=0A      */=0A =0A+    fclose(mdb=
_r);=0A+    fclose(mdb_w);=0A     close(serv_fd);=0A =0A     return 0;=0A--=
 =0A2.34.1=0A=0A=0AFrom 537bcddf9cea379212bb4ffafff70962f1692dfc Mon Sep 17=
 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.edu>=0ADate: Sat, 10 De=
c 2022 20:46:04 -0500=0ASubject: [PATCH 06/10] I am not quite sure, but it =
seems like part2 is working=0A okay now. I have to check if the memory leak=
s are constant.=0A=0A---=0A part2/http-server.c | 65 ++++++++++++++++++++++=
+++++++++++++++++++++--=0A 1 file changed, 63 insertions(+), 2 deletions(-)=
=0A=0Adiff --git a/part2/http-server.c b/part2/http-server.c=0Aindex 874888=
2..7de5023 100644=0A--- a/part2/http-server.c=0A+++ b/part2/http-server.c=
=0A@@ -130,7 +130,7 @@ static int send301(const char *request_uri, FILE *fp=
)=0A =0A static void handle_lookup(const char *request, FILE *clnt_w, FILE =
*mdb_r, FILE *mdb_w){=0A     const char *form =3D=0A-          "<h1>mdb-loo=
kup</h1>\n"=0A+          "<h1>mdb-liasdsadasdasdasdasdasdasdasdookup</h1>\n=
"=0A           "<p>\n"=0A           "<form method=3DGET action=3D/mdb-looku=
p>\n"=0A           "lookup: <input type=3Dtext name=3Dkey>\n"=0A@@ -138,7 +=
138,65 @@ static void handle_lookup(const char *request, FILE *clnt_w, FILE=
 *mdb_r, FILE *=0A           "</form>\n"=0A           "<p>\n";=0A =0A-    f=
printf(clnt_w, "<html><body>\n%s</body></html>\n", form);=0A+    if(strlen(=
request) < 5 || strncmp(request, "?key=3D", 5) ){=0A+        if(fprintf(cln=
t_w, "<html><body>\n%s</body></html>\n", form) < 0)=0A+            perror("=
send");=0A+        return;=0A+    }=0A+                =0A+    fprintf(stde=
rr, "Length of request after =3D %ld\n", strlen(request + 5));=0A+=0A+    c=
har key[strlen(request + 5) + 1];=0A+        =0A+    fprintf(stderr, "Size =
of key array =3D %ld\nThis is the array: ", sizeof(key));=0A+    =0A+    st=
rncpy(key, request + 5, sizeof(key) - 1);=0A+=0A+    key[sizeof(key)  - 1] =
=3D '\n';=0A+    =0A+    fwrite(key, sizeof(key), 1, stderr);=0A+=0A+    if=
(fwrite(key, sizeof(key), 1, mdb_w) !=3D 1){=0A+        perror("send");=0A+=
        return;=0A+    }=0A+=0A+    // Buffer for result of lookup.=0A+    =
char result_buf[500];=0A+    int isYellow =3D 0;=0A+=0A+    if(fprintf(clnt=
_w, "<html><body>\n%s<p><table border>\n", form) < 0)=0A+        perror("se=
nd");=0A+=0A+    while(fgets(result_buf, sizeof(result_buf), mdb_r) !=3D NU=
LL ) {=0A+        if(!strcmp(result_buf, "\n")){=0A+            fprintf(std=
err,"I found newline character at the response!\n");=0A+            break;=
=0A+        }=0A+=0A+        if(isYellow){=0A+            if(fprintf(clnt_w=
, "<tr><td bgcolor=3Dyellow>\n%s\n", result_buf) < 0)=0A+            perror=
("send");=0A+            isYellow =3D 0;=0A+        }else{=0A+            i=
f(fprintf(clnt_w, "<tr><td>\n%s\n", result_buf) < 0)=0A+            perror(=
"send");=0A+            isYellow =3D 1;=0A+        }=0A+    }=0A+    =0A+  =
  if(ferror(mdb_r))=0A+        perror("mdb_lookup_server");=0A+=0A+=0A+    =
if(fprintf(clnt_w, "</table>\n</body></html>\n") < 0)=0A+        perror("se=
nd");=0A+ =0A+=0A+    if (fflush(clnt_w) < 0)=0A+        perror("send");=0A=
+=0A+    return;=0A }=0A =0A static int handle_file_request(const char *web=
_root, const char *request_uri, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)=0A@=
@ -505,6 +563,9 @@ int main(int argc, char *argv[])=0A     FILE *mdb_w =3D =
fdopen(dup(mdb_fd), "wb");=0A     if (mdb_w =3D=3D NULL)=0A         die("fd=
open");=0A+=0A+    setbuf(mdb_w, NULL);=0A+=0A     /*=0A      * Server acce=
pt() loop.=0A      */=0A-- =0A2.34.1=0A=0A=0AFrom 66f20d2a0fe0a1547190d4a34=
e9d2bb0ec00daa6 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columb=
ia.edu>=0ADate: Sat, 10 Dec 2022 23:27:33 -0500=0ASubject: [PATCH 07/10] No=
w part2 can send 500 Internal Server Error.=0A=0A---=0A part2/http-server.c=
 | 34 +++++++++++++++++++++-------------=0A 1 file changed, 21 insertions(+=
), 13 deletions(-)=0A=0Adiff --git a/part2/http-server.c b/part2/http-serve=
r.c=0Aindex 7de5023..44281c4 100644=0A--- a/part2/http-server.c=0A+++ b/par=
t2/http-server.c=0A@@ -128,20 +128,22 @@ static int send301(const char *req=
uest_uri, FILE *fp)=0A  * move on.=0A  */=0A =0A-static void handle_lookup(=
const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w){=0A+static int=
 handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *mdb_w)=
{=0A     const char *form =3D=0A-          "<h1>mdb-liasdsadasdasdasdasdasd=
asdasdookup</h1>\n"=0A+          "<h1>mdb-lookup</h1>\n"=0A           "<p>\=
n"=0A           "<form method=3DGET action=3D/mdb-lookup>\n"=0A           "=
lookup: <input type=3Dtext name=3Dkey>\n"=0A           "<input type=3Dsubmi=
t>\n"=0A           "</form>\n"=0A           "<p>\n";=0A+        =0A+    int=
 status_code;=0A =0A     if(strlen(request) < 5 || strncmp(request, "?key=
=3D", 5) ){=0A         if(fprintf(clnt_w, "<html><body>\n%s</body></html>\n=
", form) < 0)=0A             perror("send");=0A-        return;=0A+        =
return 1;=0A     }=0A                 =0A     fprintf(stderr, "Length of re=
quest after =3D %ld\n", strlen(request + 5));=0A@@ -156,15 +158,23 @@ stati=
c void handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *=
=0A     =0A     fwrite(key, sizeof(key), 1, stderr);=0A =0A-    if(fwrite(k=
ey, sizeof(key), 1, mdb_w) !=3D 1){=0A+    if(fwrite(key, sizeof(key), 1, m=
db_w) !=3D 1){ =0A         perror("send");=0A-        return;=0A+        st=
atus_code =3D 500; // "Not Found"=0A+        if (send_error_status(clnt_w, =
status_code) < 0)=0A+            perror("send");=0A+        return 0;=0A   =
  }=0A =0A     // Buffer for result of lookup.=0A     char result_buf[500];=
=0A     int isYellow =3D 0;=0A =0A+    status_code =3D 200; // "OK"=0A+    =
if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < =
0) {=0A+        perror("send");=0A+    }=0A+=0A     if(fprintf(clnt_w, "<ht=
ml><body>\n%s<p><table border>\n", form) < 0)=0A         perror("send");=0A=
 =0A@@ -196,7 +206,7 @@ static void handle_lookup(const char *request, FILE=
 *clnt_w, FILE *mdb_r, FILE *=0A     if (fflush(clnt_w) < 0)=0A         per=
ror("send");=0A =0A-    return;=0A+    return 1;=0A }=0A =0A static int han=
dle_file_request(const char *web_root, const char *request_uri, FILE *clnt_=
w, FILE *mdb_r, FILE *mdb_w)=0A@@ -213,15 +223,13 @@ static int handle_file=
_request(const char *web_root, const char *request_uri, FI=0A     =0A     /=
/ enter if uri is /mdb-lookup or it starts with /mdb-lookup?=0A     if(!str=
cmp(request_uri, "/mdb-lookup") || !strncmp(request_uri, "/mdb-lookup?", 12=
)){=0A-     =0A-        status_code =3D 200; // "OK"=0A-        if (send_st=
atus_line(clnt_w, status_code) < 0 || send_blank_line(clnt_w) < 0) {=0A-   =
         perror("send");=0A-            goto cleanup;=0A-        }=0A =0A  =
       // return the result=0A-        handle_lookup(request_uri + 11, clnt=
_w, mdb_r, mdb_w);        =0A+        if(handle_lookup(request_uri + 11, cl=
nt_w, mdb_r, mdb_w)){=0A+            status_code =3D 200;=0A+        }else{=
=0A+            status_code =3D 500;=0A+        }     =0A         goto clea=
nup;=0A     }=0A =0A-- =0A2.34.1=0A=0A=0AFrom abd922f7427ed2fb37f27b4d2ded0=
14a2f972f12 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@columbia.e=
du>=0ADate: Sun, 11 Dec 2022 03:16:46 -0500=0ASubject: [PATCH 08/10] Fixed =
a little bug when the default lookup page is=0A printed.=0A=0A---=0A part2/=
http-server.c | 4 ++++=0A 1 file changed, 4 insertions(+)=0A=0Adiff --git a=
/part2/http-server.c b/part2/http-server.c=0Aindex 44281c4..d581745 100644=
=0A--- a/part2/http-server.c=0A+++ b/part2/http-server.c=0A@@ -141,6 +141,1=
0 @@ static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_=
r, FILE *m=0A     int status_code;=0A =0A     if(strlen(request) < 5 || str=
ncmp(request, "?key=3D", 5) ){=0A+        status_code =3D 200; // "OK"=0A+ =
       if (send_status_line(clnt_w, status_code) < 0 || send_blank_line(cln=
t_w) < 0)=0A+            perror("send");=0A+=0A         if(fprintf(clnt_w, =
"<html><body>\n%s</body></html>\n", form) < 0)=0A             perror("send"=
);=0A         return 1;=0A-- =0A2.34.1=0A=0A=0AFrom 8b71c382d86a5a0205505a6=
a219936b46b72e707 Mon Sep 17 00:00:00 2001=0AFrom: Arman Ozcan <ao2794@colu=
mbia.edu>=0ADate: Wed, 14 Dec 2022 17:50:47 -0500=0ASubject: [PATCH 09/10] =
Final commit!=0A=0A---=0A part2/http-server.c | 16 ++++++++++------=0A 1 fi=
le changed, 10 insertions(+), 6 deletions(-)=0A=0Adiff --git a/part2/http-s=
erver.c b/part2/http-server.c=0Aindex d581745..c5635b4 100644=0A--- a/part2=
/http-server.c=0A+++ b/part2/http-server.c=0A@@ -150,20 +150,20 @@ static i=
nt handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, FILE *m=0A=
         return 1;=0A     }=0A                 =0A-    fprintf(stderr, "Len=
gth of request after =3D %ld\n", strlen(request + 5));=0A+    //fprintf(std=
err, "Length of request after =3D %ld\n", strlen(request + 5));=0A =0A     =
char key[strlen(request + 5) + 1];=0A         =0A-    fprintf(stderr, "Size=
 of key array =3D %ld\nThis is the array: ", sizeof(key));=0A+    //fprintf=
(stderr, "Size of key array =3D %ld\nThis is the array: ", sizeof(key));=0A=
     =0A     strncpy(key, request + 5, sizeof(key) - 1);=0A =0A     key[siz=
eof(key)  - 1] =3D '\n';=0A     =0A-    fwrite(key, sizeof(key), 1, stderr)=
;=0A+    //fwrite(key, sizeof(key), 1, stderr);=0A =0A     if(fwrite(key, s=
izeof(key), 1, mdb_w) !=3D 1){ =0A-        perror("send");=0A+        perro=
r("mdb-lookup-server send");=0A         status_code =3D 500; // "Not Found"=
=0A         if (send_error_status(clnt_w, status_code) < 0)=0A             =
perror("send");=0A@@ -182,9 +182,10 @@ static int handle_lookup(const char =
*request, FILE *clnt_w, FILE *mdb_r, FILE *m=0A     if(fprintf(clnt_w, "<ht=
ml><body>\n%s<p><table border>\n", form) < 0)=0A         perror("send");=0A=
 =0A+    int i =3D 1;=0A     while(fgets(result_buf, sizeof(result_buf), md=
b_r) !=3D NULL ) {=0A         if(!strcmp(result_buf, "\n")){=0A-           =
 fprintf(stderr,"I found newline character at the response!\n");=0A+       =
     i =3D 0;=0A             break;=0A         }=0A =0A@@ -199,8 +200,11 @@=
 static int handle_lookup(const char *request, FILE *clnt_w, FILE *mdb_r, F=
ILE *m=0A         }=0A     }=0A     =0A+    if(i)=0A+        perror("mdb-lo=
okup-server recv");=0A+=0A     if(ferror(mdb_r))=0A-        perror("mdb_loo=
kup_server");=0A+        perror("mdb-lookup-server");=0A =0A =0A     if(fpr=
intf(clnt_w, "</table>\n</body></html>\n") < 0)=0A-- =0A2.34.1=0A=0A=0AFrom=
 ffff1628f2dae8cdd5a7044f01d301a69732b5fb Mon Sep 17 00:00:00 2001=0AFrom: =
Arman Ozcan <ao2794@columbia.edu>=0ADate: Wed, 14 Dec 2022 19:58:54 -0500=
=0ASubject: [PATCH 10/10] One last commit (fixed the case when the database=
 file=0A doesn't exist, now it logs the terminated line)=0A=0A---=0A part1/=
mdb-lookup-server.c | 8 +++++---=0A 1 file changed, 5 insertions(+), 3 dele=
tions(-)=0A=0Adiff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-ser=
ver.c=0Aindex f523464..5c058bc 100644=0A--- a/part1/mdb-lookup-server.c=0A+=
++ b/part1/mdb-lookup-server.c=0A@@ -33,9 +33,10 @@ static void handle_clie=
nt(char *database, int clnt_fd){=0A =0A         // Open the database file=
=0A         FILE *fp =3D fopen(database, "rb");=0A-        if (fp =3D=3D NU=
LL)=0A-            die(database);=0A-       =0A+        if (fp =3D=3D NULL)=
{=0A+            perror("fopen");=0A+            return;=0A+        }=0A   =
      /*=0A         * Open client file descriptor as FILE pointers.=0A     =
    */=0A@@ -138,6 +139,7 @@ static void handle_client(char *database, int =
clnt_fd){=0A         if (fclose(clnt_r) < 0)=0A             perror("clnt_r"=
);=0A =0A+        return;=0A         // Resume server loop to handle next c=
lient connection.=0A }=0A =0A-- =0A2.34.1=0A=0A
--K83sDo3EOYo3DfJy--

